---
layout: main
title: FAQ - Eagle Eyes
permalink: /faq/
---

<!-- Content -->
<div class="content clearfix reveal-footer">
    <!-- Page Header -->
    <div class="section-block bkg-grey-ultralight" style="padding: 100px 0 30px 0;">
        <div class="row">
            <div class="column width-10 offset-1 center">
                <div style="position: relative; height: 90px; margin-bottom: 20px;">
                    <div style="position: absolute; font-size: 5.5rem; line-height: 1; color: #1e90ff; transform: rotate(20deg); left: 48%; top: 0;">   ü¶Ö   </div>
                    <div style="position: absolute; font-size: 4rem; line-height: 1; color: #1e90ff; left: 46%; top: 65px;">‚ùì   </div>
                </div>
                <h1 class="mb-10">Frequently Asked Questions</h1>
            </div>
        </div>
    </div>

    <!-- FAQ Section -->
    <section class="section-block pt-30 pb-90 bkg-white">
        <div class="row">
            <div class="column width-8 offset-2">
                <!-- FAQ Search -->
                <div class="faq-search" role="search" aria-label="Search FAQs">
                    <input id="faq-search-input" type="search" placeholder="Search FAQs..." aria-label="Search FAQs" />
                    <div id="faq-search-meta" class="faq-search-meta" aria-live="polite"></div>
                </div>
                <div class="faq-container">
                    <!-- FAQ Items -->
                    {% for faq in site.data.faqs.faqs %}
                    <div class="faq-item" id="{{ faq.id }}">
                        <div class="faq-question">
                            <span class="faq-question-text">{{ faq.emoji }} {{ faq.question }}</span>
                            <div class="faq-actions">
                                <span class="toggle-icon">+</span>
                                <button class="faq-share-btn" onclick="event.stopPropagation(); shareFaqQuestion('{{ faq.id }}'); return false;" title="Share this FAQ">
                                </button>
                            </div>
                        </div>
                        <div class="faq-answer">
                            {{ faq.content }}
                        </div>
                    </div>
                    {% endfor %}
                </div>

                <!-- Contact Section -->
                <div class="faq-contact-section" style="margin-top: 40px; padding: 30px; background: linear-gradient(135deg, #f8f9fa 0%, #e3f2fd 100%); border-radius: 12px; text-align: center; border: 1px solid #e9ecef;">
                    <h3 style="margin-bottom: 15px; color: #333; font-size: 2.2rem; font-weight: 600;">Question not answered here?</h3>
                    <p style="margin-bottom: 20px; color: #555; font-size: 1.7rem; line-height: 1.5;">
                        Contact us at 
                        <span class="faq-email-link" onclick="copyEmailToClipboard()" style="color: #1e90ff; cursor: pointer; text-decoration: underline; font-weight: 500; transition: all 0.3s ease; padding: 4px 8px; border-radius: 4px; display: inline-block; font-size: 1.7rem;" 
                             onmouseover="this.style.backgroundColor='#1e90ff'; this.style.color='white';" 
                             onmouseout="this.style.backgroundColor='transparent'; this.style.color='#1e90ff';">
                            info@EagleEyesSearch.com
                        </span>
                    </p>
                </div>
            </div>
        </div>
    </section>

    {% include footer.html %}
</div>

<!-- Js -->
<!-- These scripts are already included in the main layout, so remove them -->
<!-- <script src="js/jquery-3.2.1.min.js"></script>
<script src="js/jquery.tm.avalanche.js"></script>
<script src="js/timber.master.min.js"></script> -->

<!-- MiniSearch Library for BM25 -->
<script src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js"></script>

<!-- FAQ Toggle Script -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    const faqQuestions = document.querySelectorAll('.faq-question');
    
    // Function to open a specific FAQ item (without scrolling the page)
    function openFaqItem(faqItem) {
        // Close all other FAQ items first
        faqQuestions.forEach(otherQuestion => {
            otherQuestion.parentNode.classList.remove('active');
        });
        
        // Open the specified item
        faqItem.classList.add('active');
        // Do not scroll the page; let content expand in place
    }

    // Function to pause all videos in a FAQ item
    function pauseVideosInFaqItem(faqItem) {
        const videos = faqItem.querySelectorAll('iframe');
        videos.forEach(video => {
            // For YouTube videos - use postMessage to pause
            if (video.src.includes('youtube.com')) {
                try {
                    video.contentWindow.postMessage('{"event":"command","func":"pauseVideo","args":""}', '*');
                } catch (e) {
                    // If postMessage fails, reload the video
                    const currentSrc = video.src;
                    video.src = '';
                    video.src = currentSrc;
                }
            }
            // For Streamable videos - reload to stop playback
            else if (video.src.includes('streamable.com')) {
                const currentSrc = video.src;
                video.src = '';
                video.src = currentSrc;
            }
        });
    }

    // Handle click events on FAQ questions
    faqQuestions.forEach(question => {
        question.addEventListener('click', function() {
            const parent = this.parentNode;
            if (!parent.classList.contains('active')) {
                openFaqItem(parent);
                // Update URL hash without triggering scroll
                const id = parent.getAttribute('id');
                history.pushState(null, null, `#${id}`);
            } else {
                // Pause videos before closing
                pauseVideosInFaqItem(parent);
                parent.classList.remove('active');
                history.pushState(null, null, window.location.pathname);
            }
        });
    });

    // Handle initial load and hash changes
    function handleHash() {
        const hash = window.location.hash.substring(1);
        if (hash) {
            const targetFaq = document.getElementById(hash);
            if (targetFaq) {
                openFaqItem(targetFaq);
            }
        }
    }

    // Handle hash changes
    window.addEventListener('hashchange', handleHash);

    // Handle initial load
    handleHash();

    // ============================================================
    // FAQ SEARCH SYSTEM - MiniSearch with BM25 Ranking
    // ============================================================
    // When adding new FAQs: Scroll down ~50 lines to the metadata
    // section and add alternates + tags for optimal search ranking!
    // Search the file for: "IMPORTANT: When adding NEW FAQs"
    // ============================================================
    
    const searchInput = document.getElementById('faq-search-input');
    const searchMeta = document.getElementById('faq-search-meta');
    const faqItems = Array.from(document.querySelectorAll('.faq-item'));

    // Stopwords to remove from queries
    const stopwords = new Set([
        'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
        'of', 'with', 'by', 'from', 'is', 'are', 'was', 'were', 'be', 'been',
        'can', 'could', 'do', 'does', 'did', 'has', 'have', 'had',
        'how', 'what', 'when', 'where', 'why', 'who', 'which',
        'i', 'my', 'me', 'we', 'you', 'your',
        'if', 'so', 'than', 'that', 'this', 'these', 'those',
        'will', 'would', 'should', 'there', 'their',
        'dont', 'doesnt', 'didnt', 'wont', 'wouldnt', 'shouldnt', 'cant', 'couldnt',
        'it', 'its', 'am', 'not'
    ]);

    // Concept groups for query expansion
    const concepts = {
        connectivity: ['wifi', 'internet', 'network', 'offline', 'online', 'signal'],
        licensing: ['license', 'key', 'activate', 'activation', 'unlock', 'register', 'trial'],
        hardware: ['drone', 'controller', 'remote', 'dji', 'computer', 'laptop'],
        setup: ['install', 'setup', 'download', 'configure'],
        detection: ['detect', 'detector', 'detection', 'vision', 'ai'],
        compatibility: ['compatible', 'support', 'works', 'requirements'],
        versions: ['beta', 'stable', 'version', 'release']
    };

    // Build reverse map
    const termToConcepts = {};
    Object.keys(concepts).forEach(conceptName => {
        concepts[conceptName].forEach(term => {
            if (!termToConcepts[term]) termToConcepts[term] = [];
            termToConcepts[term].push(conceptName);
        });
    });

    // Structure FAQ data with metadata
    const faqData = faqItems.map((item, idx) => {
        const id = item.getAttribute('id') || `faq-${idx}`;
        const questionEl = item.querySelector('.faq-question');
        const answerEl = item.querySelector('.faq-answer');
        const questionText = (questionEl ? questionEl.textContent : '').trim();
        const answerText = (answerEl ? answerEl.textContent : '').trim();
        
        // ============================================================
        // IMPORTANT: When adding NEW FAQs, add metadata here for optimal search!
        // ============================================================
        // 
        // For each new FAQ, add an entry below with:
        //
        // ALTERNATES: 2-4 common ways users might ask this question
        //   - Use natural language variations (5-10 words)
        //   - Think: "How else would someone search for this?"
        //   - Example: "unlock scan desktop laptop computer machine id"
        //
        // TAGS: 3-8 key concepts/keywords from the FAQ
        //   - Single words or short 2-word phrases
        //   - Include product names, technical terms, action words
        //   - Example: "license key activation desktop laptop"
        //
        // TEMPLATE:
        // } else if (id === 'your-faq-id') {
        //     alternates = 'phrase one phrase two phrase three';
        //     tags = 'keyword1 keyword2 keyword3 keyword4';
        // }
        //
        // NOTE: FAQs without metadata still work but may rank lower!
        // ============================================================
        
        // Metadata auto-generated from YAML data
        const faqMetadata = {
            {% for faq in site.data.faqs.faqs %}
            '{{ faq.id }}': {
                alternates: '{{ faq.search.alternates }}',
                tags: '{{ faq.search.tags }}'
            }{% unless forloop.last %},{% endunless %}
            {% endfor %}
        };

        let alternates = '';
        let tags = '';

        if (faqMetadata[id]) {
            alternates = faqMetadata[id].alternates;
            tags = faqMetadata[id].tags;
        }

        return {
            id,
            item,
            question: questionText,
            alternates,
            tags,
            answer: answerText.substring(0, 500) // Limit answer length for indexing
        };
    });

    // Initialize MiniSearch with BM25
    const miniSearch = new MiniSearch({
        fields: ['question', 'alternates', 'tags', 'answer'],
        storeFields: ['id'],
        searchOptions: {
            boost: { question: 3, alternates: 2, tags: 2, answer: 1 },
            fuzzy: 0.2,
            prefix: true
        }
    });

    // Add documents to index
    miniSearch.addAll(faqData);

    // Configuration for embedding search
    const EMBEDDING_SEARCH_CONFIG = {
        FUNCTION_URL: 'https://us-central1-eagleeyessearch.cloudfunctions.net/faq_search',
        TIMEOUT_MS: 5000,  // 5 second timeout
        ENABLE_EMBEDDINGS: true
    };

    // Expand query with concepts (conservative)
    function expandQuery(queryText) {
        const tokens = queryText.toLowerCase().split(/\s+/).filter(Boolean);
        
        // FIRST: Remove stopwords
        const meaningfulTokens = tokens.filter(t => !stopwords.has(t));
        
        // If no meaningful tokens, return empty (don't search stopwords)
        if (meaningfulTokens.length === 0) {
            return '';
        }
        
        const expanded = new Set(meaningfulTokens);
        
        // THEN: Expand with concepts
        meaningfulTokens.forEach(token => {
            if (termToConcepts[token]) {
                // Add only the first matched concept's terms (not all)
                const firstConcept = termToConcepts[token][0];
                concepts[firstConcept].forEach(term => expanded.add(term));
            }
        });
        
        return Array.from(expanded).join(' ');
    }

    /**
     * Escape HTML special characters to prevent XSS and display issues
     */
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Search using OpenAI embeddings via Cloud Function
     * @param {string} query - User query
     * @returns {Promise<Array|null>} - Embedding search results or null on failure
     */
    async function searchWithEmbeddings(query) {
        if (!EMBEDDING_SEARCH_CONFIG.ENABLE_EMBEDDINGS) {
            console.log('üî§ Embeddings disabled, using BM25');
            return null;
        }

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), EMBEDDING_SEARCH_CONFIG.TIMEOUT_MS);

        try {
            console.log(`üî¨ Attempting embedding search for: "${query}"`);

            // Prepare FAQ data for the API (without embeddings)
            const faqsForApi = faqData.map(({ id, question, answer, alternates, tags }) => ({
                id,
                question,
                answer: answer ? answer.substring(0, 500) : '',
                alternates: alternates || '',
                tags: tags || ''
            }));

            const response = await fetch(EMBEDDING_SEARCH_CONFIG.FUNCTION_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query, faqs: faqsForApi }),
                signal: controller.signal
            });

            clearTimeout(timeoutId);

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `HTTP ${response.status}`);
            }

            const data = await response.json();
            const results = data.results || [];

            if (results.length === 0) {
                console.log('üì≠ Embedding search returned 0 results - falling back to BM25');
                return null;
            }

            console.log(`‚úÖ Embedding search succeeded - ${results.length} results`);
            return results;

        } catch (error) {
            clearTimeout(timeoutId);

            if (error.name === 'AbortError') {
                console.log('‚è±Ô∏è Embedding search timed out - falling back to BM25');
            } else {
                console.log(`‚ùå Embedding search failed: ${error.message} - falling back to BM25`);
            }

            return null;
        }
    }

    /**
     * Search using BM25 algorithm with fuzzy matching
     * @param {string} expandedQuery - Query with stopwords removed and concepts expanded
     * @returns {Array} - BM25 search results
     */
    function searchWithBM25(expandedQuery) {
        return miniSearch.search(expandedQuery, {
            boost: { question: 3, alternates: 2, tags: 2, answer: 1 }
        });
    }

    /**
     * Intelligently choose the best search results
     * @param {Array|null} embeddingResults - Results from embedding search
     * @param {Array} bm25Results - Results from BM25 search
     * @param {string} query - Original user query
     * @returns {Object} - { results: Array, method: string }
     */
    function chooseBestResults(embeddingResults, bm25Results, query) {
        // Scenario 1: Embeddings failed/empty ‚Üí use BM25
        if (!embeddingResults || embeddingResults.length === 0) {
            console.log('üî§ Using BM25 (embeddings returned no results)');
            return { results: bm25Results, method: 'bm25' };
        }

        // Scenario 2: BM25 has significantly more results (2x) ‚Üí likely typo/fuzzy benefit
        if (bm25Results.length >= embeddingResults.length * 2 && bm25Results.length > 2) {
            console.log(`üîç Using BM25 fuzzy (${bm25Results.length} results vs ${embeddingResults.length} from embeddings - likely typo handling)`);
            return { results: bm25Results, method: 'bm25-fuzzy' };
        }

        // Scenario 3: Similar counts ‚Üí prefer embeddings (better semantic understanding)
        console.log(`üî¨ Using embeddings (${embeddingResults.length} results vs ${bm25Results.length} from BM25 - semantic match)`);
        return { results: embeddingResults, method: 'embeddings' };
    }

    async function renderResults(query) {
        const q = (query || '').trim();
        history.replaceState(null, null, window.location.pathname);

        if (q.length === 0) {
            faqData.forEach(({ item }) => item.style.display = '');
            searchMeta.textContent = '';
            // Show contact section when search is cleared
            const contactSection = document.querySelector('.faq-contact-section');
            if (contactSection) contactSection.style.display = 'block';
            return;
        }

        // Expand query with concepts (also filters stopwords)
        const expandedQuery = expandQuery(q);

        // If query is all stopwords, show all FAQs
        if (expandedQuery.length === 0) {
            faqData.forEach(({ item }) => item.style.display = '');
            searchMeta.textContent = 'Search for specific terms (common words filtered)';
            // Show contact section when showing all FAQs
            const contactSection = document.querySelector('.faq-contact-section');
            if (contactSection) contactSection.style.display = 'block';
            return;
        }

        // Run both searches in parallel for hybrid approach
        const [embeddingResults, bm25Results] = await Promise.all([
            searchWithEmbeddings(q),
            searchWithBM25(expandedQuery)
        ]);

        // Intelligently choose the best results
        const { results: chosenResults, method: searchMethod } = chooseBestResults(embeddingResults, bm25Results, q);

        // Normalize results format
        let results;
        if (searchMethod === 'embeddings') {
            results = chosenResults.map((r, idx) => ({
                id: r.id,
                score: r.score || (1 - (idx * 0.1)) // Use API score or fallback to position-based
            }));
        } else {
            results = chosenResults; // BM25 results already in correct format
        }

        // Limit to top 5 results when filtering by query
        const limitedResults = results.slice(0, 5);

        // Create a map of id -> rank for sorting
        const idToRank = {};
        limitedResults.forEach((r, idx) => {
            idToRank[r.id] = idx;
        });

        const resultIds = new Set(limitedResults.map(r => r.id));
        
        // Sort FAQ items by BM25 rank
        const sortedFaqData = [...faqData].sort((a, b) => {
            const aHasResult = resultIds.has(a.id);
            const bHasResult = resultIds.has(b.id);
            
            if (!aHasResult && !bHasResult) return 0;
            if (!aHasResult) return 1;
            if (!bHasResult) return -1;
            
            // Both have results - sort by BM25 rank
            return idToRank[a.id] - idToRank[b.id];
        });
        
        // Update display in sorted order
        const container = document.querySelector('.faq-container');
        sortedFaqData.forEach(({ id, item }) => {
            item.classList.remove('active');
            item.style.display = resultIds.has(id) ? '' : 'none';
            // Re-append to reorder in DOM
            if (resultIds.has(id)) {
                container.appendChild(item);
            }
        });

        // Get the contact section
        const contactSection = document.querySelector('.faq-contact-section');
        
        if (limitedResults.length === 0) {
            searchMeta.innerHTML = `<span style="font-size: 1.6rem; line-height: 1.6;">We're updating our FAQ resources and don't have an answer available for your specific question at this time. Please reach out to us at <span class="faq-email-link" onclick="copyEmailToClipboard()" style="color: #1e90ff; cursor: pointer; text-decoration: underline; font-weight: 500; font-size: 1.6rem;">info@EagleEyesSearch.com</span> with your question and we'll be happy to get back to you with an answer.</span>`;
            // Hide contact section when no results (it's redundant)
            if (contactSection) contactSection.style.display = 'none';
        } else {
            searchMeta.innerHTML = `<span style="font-size: 1.2rem;">${limitedResults.length} result${limitedResults.length === 1 ? '' : 's'} for "${escapeHtml(q)}"</span>`;
            // Show contact section when there are results
            if (contactSection) contactSection.style.display = 'block';
        }
    }

    // Debounce for smoother typing
    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }

    // Check for query parameter in URL on page load
    function checkUrlQuery() {
        const urlParams = new URLSearchParams(window.location.search);
        const queryParam = urlParams.get('query');
        
        if (queryParam && searchInput) {
            // Set the search input value
            searchInput.value = queryParam;
            // Trigger search immediately (no debounce on initial load)
            renderResults(queryParam);
            // Scroll to search bar
            searchInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }

    if (searchInput) {
        const debouncedSearch = debounce((value) => renderResults(value), 150);
        searchInput.addEventListener('input', (e) => debouncedSearch(e.target.value));
        
        // Check for URL query parameter on page load
        checkUrlQuery();
    }

    // FAQ Share Function - moved outside DOMContentLoaded to be globally accessible
    window.shareFaqQuestion = function(faqId) {
        // Prevent the click from bubbling up to the FAQ question
        event.stopPropagation();
        event.preventDefault();
        
        // Generate the correct URL format
        const faqUrl = `https://www.eagleeyessearch.com/faq/#${faqId}`;
        
        // Detect mobile devices more accurately
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) && 
                        ('ontouchstart' in window || navigator.maxTouchPoints > 0) &&
                        window.innerWidth <= 768;
        
        // Use Web Share API on mobile devices
        if (isMobile && navigator.share) {
            navigator.share({
                title: 'Eagle Eyes FAQ',
                text: 'Check out this FAQ from Eagle Eyes',
                url: faqUrl
            }).then(() => {
                // Share successful
                console.log('Shared successfully');
            }).catch(err => {
                // User cancelled or error - fallback to clipboard
                console.log('Share cancelled or failed, using clipboard fallback');
                copyToClipboard(faqUrl);
            });
        } else {
            // Desktop - always copy to clipboard
            copyToClipboard(faqUrl);
        }
    }

    function copyToClipboard(text) {
        if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard.writeText(text).then(() => {
                showCopyNotification();
            }).catch(err => {
                console.log('Clipboard API failed:', err);
                fallbackCopyToClipboard(text);
            });
        } else {
            fallbackCopyToClipboard(text);
        }
    }

    function fallbackCopyToClipboard(text) {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.left = '-999999px';
        textArea.style.top = '-999999px';
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        
        try {
            const success = document.execCommand('copy');
            if (success) {
                showCopyNotification();
            }
        } catch (err) {
            console.log('Fallback copy failed:', err);
        }
        
        document.body.removeChild(textArea);
    }

    function showCopyNotification() {
        // Create notification element
        const notification = document.createElement('div');
        notification.textContent = 'Link copied to clipboard!';
        notification.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1e90ff;
            color: white;
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            animation: slideIn 0.3s ease-out;
        `;
        
        // Add animation keyframes
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
                to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            }
        `;
        document.head.appendChild(style);
        
        document.body.appendChild(notification);
        
        // Remove notification after 3 seconds
        setTimeout(() => {
            notification.style.animation = 'slideIn 0.3s ease-out reverse';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }

});
</script>

<!-- Email Copy Functions -->
<script>
// Email Copy Function
window.copyEmailToClipboard = function() {
    const email = 'info@EagleEyesSearch.com';
    
    if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(email).then(() => {
            showEmailCopyNotification();
        }).catch(err => {
            console.log('Clipboard API failed:', err);
            fallbackCopyEmailToClipboard(email);
        });
    } else {
        fallbackCopyEmailToClipboard(email);
    }
}

function fallbackCopyEmailToClipboard(text) {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
        document.execCommand('copy');
        showEmailCopyNotification();
    } catch (err) {
        console.log('Fallback copy failed:', err);
    }
    
    document.body.removeChild(textArea);
}

function showEmailCopyNotification() {
    // Create notification element
    const notification = document.createElement('div');
    notification.textContent = 'Email copied to clipboard!';
    notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #1e90ff;
        color: white;
        padding: 12px 20px;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        z-index: 10000;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        animation: slideIn 0.3s ease-out;
    `;
    
    document.body.appendChild(notification);
    
    // Remove notification after 3 seconds
    setTimeout(() => {
        notification.style.animation = 'slideIn 0.3s ease-out reverse';
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 300);
    }, 3000);
}
</script>

<!-- FAQ Styling -->
<style>
.faq-container {
    width: 100%;
}

.faq-item {
    margin-bottom: 0;
    border-bottom: 1px solid #f0f0f0;
    position: relative;
}

.faq-question {
    background-color: #fff;
    padding: 15px;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: 600;
    font-size: 18px;
    transition: all 0.3s ease;
    flex: 1;
}

.faq-question-text {
    flex: 1;
    margin-right: 15px;
    font-size: 18px;
}

.faq-actions {
    display: flex;
    align-items: center;
    gap: 10px;
}

.faq-question-actions {
    display: flex;
    align-items: center;
    gap: 10px;
}

.faq-share-btn {
    display: none;
    background: transparent;
    color: #666;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 6px 8px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.3s ease;
    align-items: center;
    justify-content: center;
    min-width: 32px;
    height: 32px;
}

/* Show share button only when FAQ is expanded */
.faq-item.active .faq-share-btn {
    display: flex;
}

.faq-share-btn::before {
    content: "";
    display: block;
    width: 16px;
    height: 16px;
    background-image: url('{{ "/images/share_icon.png" | relative_url }}');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
}

.faq-share-btn:hover {
    background: #f8f9fa;
    border-color: #bbb;
    color: #333;
}

.faq-share-btn:active {
    background: #e9ecef;
}

/* Removed conflicting icon CSS */

.faq-question:hover {
    color: #1e90ff;
}

.toggle-icon {
    font-size: 18px;
    font-weight: bold;
    color: #999;
    transition: all 0.3s ease;
}

.faq-item.active .toggle-icon {
    transform: rotate(45deg);
    color: #1e90ff;
}

.faq-answer {
    display: none;
    padding: 0 15px 20px 15px;
    background-color: #fff;
    border-top: none;
    font-size: 16px;
    line-height: 1.6;
}

.faq-item.active .faq-answer {
    display: block;
}

/* FAQ Search */
.faq-search {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 8px;
    margin: 10px 0 25px;
}

#faq-search-input {
    width: 100%;
    max-width: 640px;
    padding: 12px 14px;
    border: 1px solid #e2e2e2;
    border-radius: 8px;
    font-size: 16px;
}

.faq-search-meta {
    color: #666;
    font-size: 14px;
    text-align: center;
}

/* Mobile Responsive Styles */
@media (max-width: 768px) {
    .faq-question {
        font-size: 15px !important;
        padding: 12px 10px !important;
    }
    
    .faq-question-text {
        font-size: 15px !important;
        line-height: 1.4 !important;
    }
    
    .faq-answer {
        font-size: 13px !important;
        padding: 0 10px 15px 10px !important;
    }
    
    .faq-actions {
        gap: 8px !important;
    }
    
    .toggle-icon {
        font-size: 18px !important;
        min-width: 24px !important;
        height: 24px !important;
    }
    
    .faq-share-btn {
        min-width: 28px !important;
        height: 28px !important;
        padding: 4px 6px !important;
    }
    
    .faq-share-btn::before {
        width: 14px !important;
        height: 14px !important;
    }
    
    .faq-search input {
        font-size: 16px !important;
        padding: 12px 15px !important;
    }
    
    .faq-search-meta {
        font-size: 1.2rem !important;
        margin-top: 10px !important;
    }
    
    .faq-contact-section h3 {
        font-size: 1.6rem !important;
    }
    
    .faq-contact-section p {
        font-size: 1.2rem !important;
    }
    
    .faq-email-link {
        font-size: 1.2rem !important;
    }
    
    .faq-item {
        margin-bottom: 0 !important;
    }
    
    /* Better touch targets for mobile */
    .faq-question {
        min-height: 50px !important;
        display: flex !important;
        align-items: center !important;
    }
    
    .faq-actions {
        flex-shrink: 0 !important;
    }
}

@media (max-width: 480px) {
    .faq-question {
        font-size: 14px !important;
        padding: 10px 8px !important;
    }
    
    .faq-question-text {
        font-size: 14px !important;
    }
    
    .faq-answer {
        font-size: 12px !important;
        padding: 0 8px 12px 8px !important;
    }
    
    .faq-share-btn {
        min-width: 26px !important;
        height: 26px !important;
    }
    
    .faq-share-btn::before {
        width: 12px !important;
        height: 12px !important;
    }
}
</style>

<!-- FAQ Analytics Tracking -->
<script>
(function() {
    'use strict';
    
    const TRACKING_ENDPOINT = 'https://script.google.com/macros/s/AKfycbwoF1eGxs1D2BCYIoWZfkgwzSEKfCy4EYxj3SFlnylOVGoVKyR8ivo4BUzdKzXpzxZF/exec';
    
    // Generate or retrieve persistent session ID
    function getSessionId() {
        let sessionId = localStorage.getItem('faq_session_id');
        if (!sessionId) {
            sessionId = 'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('faq_session_id', sessionId);
        }
        return sessionId;
    }
    
    // Common event data
    function getCommonData() {
        return {
            page_path: location.pathname + location.search,
            session_id: getSessionId(),
            user_agent: navigator.userAgent,
            timestamp: new Date().toISOString()
        };
    }
    
    // Send event to tracking endpoint
    function sendEvent(eventData) {
        const fullData = { ...getCommonData(), ...eventData };
        const payload = JSON.stringify(fullData);
        
        // Send to Google Apps Script endpoint
        fetch(TRACKING_ENDPOINT, {
            method: 'POST',
            headers: {
                'Content-Type': 'text/plain',
            },
            body: payload
        }).catch(err => {
            // Silently fail - don't interrupt user experience
            console.error('Analytics tracking error:', err);
        });
    }
    
    // Track search events
    let searchStartTime = null;
    
    function trackSearch() {
        const searchInput = document.getElementById('faq-search-input');
        if (!searchInput) return;
        
        searchInput.addEventListener('input', function(e) {
            const query = e.target.value.trim();
            
            if (query.length > 2) { // Only track searches with 3+ characters
                // Debounce search tracking
                clearTimeout(window.searchTrackTimeout);
                window.searchTrackTimeout = setTimeout(() => {
                    // Count visible FAQ items as results
                    const visibleResults = document.querySelectorAll('.faq-item:not([style*="display: none"])').length;
                    
                    sendEvent({
                        event_type: 'search',
                        search_query: query,
                        results_count: visibleResults
                    });
                    
                    searchStartTime = Date.now();
                }, 1000); // Wait 1 second after typing stops
            }
        });
    }
    
    // Track question clicks
    function trackQuestionClicks() {
        document.addEventListener('click', function(e) {
            // Find if click was on a FAQ question
            const faqQuestion = e.target.closest('.faq-question');
            if (!faqQuestion) return;
            
            const faqItem = faqQuestion.closest('.faq-item');
            if (!faqItem) return;
            
            const questionId = faqItem.id;
            const questionText = faqQuestion.querySelector('.faq-question-text');
            const questionTitle = questionText ? questionText.textContent.trim() : '';
            
            // Calculate time to click if this was from a search
            const timeToClick = searchStartTime ? Date.now() - searchStartTime : null;
            
            sendEvent({
                event_type: 'question_click',
                question_id: questionId,
                question_title: questionTitle,
                time_to_click_ms: timeToClick
            });
        });
    }
    
    // Track links clicked inside FAQ answers
    function trackAnswerLinkClicks() {
        document.addEventListener('click', function(e) {
            // Check if clicked element is a link
            if (e.target.tagName !== 'A') return;
            
            // Check if link is inside a FAQ answer
            const faqAnswer = e.target.closest('.faq-answer');
            if (!faqAnswer) return;
            
            const faqItem = faqAnswer.closest('.faq-item');
            if (!faqItem) return;
            
            const questionId = faqItem.id;
            const questionTitle = faqItem.querySelector('.faq-question-text')?.textContent.trim() || '';
            const linkUrl = e.target.href;
            
            sendEvent({
                event_type: 'answer_link_click',
                link_url: linkUrl,
                question_id: questionId,
                question_title: questionTitle
            });
        });
    }
    
    // Initialize tracking when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            trackSearch();
            trackQuestionClicks();
            trackAnswerLinkClicks();
        });
    } else {
        trackSearch();
        trackQuestionClicks();
        trackAnswerLinkClicks();
    }

    // Load drone compatibility data for the general compatibility FAQ
    loadGeneralCompatibilityData();
})();

// Function to create a hash of drone data for change detection
function hashDroneData(droneData) {
    const str = JSON.stringify(droneData);
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32-bit integer
    }
    return hash.toString();
}

// Function to create a table row for a drone
function createDroneRow(drone, index) {
    const row = document.createElement('tr');
    row.style.backgroundColor = index % 2 === 0 ? '#f8f9fa' : 'white';
    row.setAttribute('data-drone-id', `${drone.brand}-${drone.name}`.replace(/\s+/g, '-').toLowerCase());

    // Drone Model
    const modelCell = document.createElement('td');
    modelCell.style.cssText = 'padding: 12px 10px; border: 1px solid #dee2e6; font-weight: 500;';
    modelCell.textContent = `${drone.brand} ${drone.name}`;

    // Controllers
    const controllersCell = document.createElement('td');
    controllersCell.style.cssText = 'padding: 12px 10px; border: 1px solid #dee2e6;';

    // Controllers that don't support third-party apps
    const noThirdPartyApps = ['RC', 'RC1', 'RC2', 'RC3'];

    // Controllers that are working on partial compatibility
    const partialCompatControllers = ['RC-Pro', 'RC-Pro 2', 'RC-Pro2'];

    const controllersList = [];

    // Add internally tested controllers
    (drone.controllers_internally_tested || []).forEach(controller => {
        controllersList.push(`${controller} - ‚úÖ compatible (tested internally)`);
    });

    // Add user tested controllers
    (drone.controllers_user_tested || []).forEach(controller => {
        controllersList.push(`${controller} - ‚úÖ compatible (tested internally)`);
    });

    // Add not tested controllers
    (drone.controllers_not_tested || []).forEach(controller => {
        controllersList.push(`${controller} - ‚òëÔ∏è compatible (not tested internally)`);
    });

    // Add incompatible controllers with appropriate messaging
    (drone.controllers_incompatible || []).forEach(controller => {
        if (noThirdPartyApps.includes(controller)) {
            controllersList.push(`${controller} - ‚ùå incompatible (3rd party apps not supported)`);
        } else if (partialCompatControllers.includes(controller)) {
            controllersList.push(`${controller} - ‚è≥ working on partial-compatibility`);
        } else {
            controllersList.push(`${controller} - ‚ùå incompatible (3rd party apps not supported)`);
        }
    });

    if (drone.scanOnly) {
        controllersCell.textContent = 'Note: Eagle Eyes Scan Only üíª';
    } else {
        controllersCell.innerHTML = controllersList.length > 0 ? controllersList.join('<br>') : 'See notes';
    }

    row.appendChild(modelCell);
    row.appendChild(controllersCell);
    return row;
}

// Function to load cached data and show immediately
function loadCachedDroneData() {
    const cached = localStorage.getItem('droneCompatibilityData');
    const cacheTimestamp = localStorage.getItem('droneCompatibilityTimestamp');
    
    if (!cached) return false;
    
    try {
        const data = JSON.parse(cached);
        const tbody = document.getElementById('general-compatibility-tbody');
        const loadingDiv = document.getElementById('general-compatibility-loading');
        const tableDiv = document.getElementById('general-compatibility-table');
        
        if (!tbody || !data.length) return false;
        
        // Clear and populate with cached data
        tbody.innerHTML = '';
        data.forEach((drone, index) => {
            const row = createDroneRow(drone, index);
            tbody.appendChild(row);
        });
        
        // Show table immediately
        loadingDiv.style.display = 'none';
        tableDiv.style.display = 'block';
        
        // Add a small indicator that data is cached
        const timestamp = new Date(parseInt(cacheTimestamp));
        const timeAgo = Math.round((Date.now() - timestamp.getTime()) / (1000 * 60));
        if (timeAgo > 0) {
            const indicator = document.createElement('div');
            indicator.id = 'cache-indicator';
            indicator.style.cssText = 'font-size: 12px; color: #666; text-align: right; margin-top: 5px; font-style: italic;';
            indicator.textContent = `Data cached ${timeAgo} minutes ago ‚Ä¢ Checking for updates...`;
            tableDiv.appendChild(indicator);
        }
        
        return true;
    } catch (e) {
        console.error('Error loading cached data:', e);
        return false;
    }
}

// Function to update only changed rows
function updateChangedRows(newData, oldData) {
    const tbody = document.getElementById('general-compatibility-tbody');
    if (!tbody) return;
    
    // Create maps for easier comparison
    const oldMap = new Map();
    oldData.forEach(drone => {
        const key = `${drone.brand}-${drone.name}`.replace(/\s+/g, '-').toLowerCase();
        oldMap.set(key, drone);
    });
    
    const newMap = new Map();
    newData.forEach(drone => {
        const key = `${drone.brand}-${drone.name}`.replace(/\s+/g, '-').toLowerCase();
        newMap.set(key, drone);
    });
    
    // Check for changes and updates
    let hasChanges = false;
    
    newData.forEach((drone, index) => {
        const key = `${drone.brand}-${drone.name}`.replace(/\s+/g, '-').toLowerCase();
        const oldDrone = oldMap.get(key);
        
        if (!oldDrone || hashDroneData(drone) !== hashDroneData(oldDrone)) {
            hasChanges = true;
            
            // Find and replace the row
            const existingRow = tbody.querySelector(`tr[data-drone-id="${key}"]`);
            const newRow = createDroneRow(drone, index);
            
            if (existingRow) {
                tbody.replaceChild(newRow, existingRow);
            } else {
                // New drone, add to table
                tbody.appendChild(newRow);
            }
        }
    });
    
    // Remove any drones that no longer exist
    oldData.forEach(drone => {
        const key = `${drone.brand}-${drone.name}`.replace(/\s+/g, '-').toLowerCase();
        if (!newMap.has(key)) {
            hasChanges = true;
            const existingRow = tbody.querySelector(`tr[data-drone-id="${key}"]`);
            if (existingRow) {
                existingRow.remove();
            }
        }
    });
    
    return hasChanges;
}


// Function to load compatibility data for the general compatibility question
async function loadGeneralCompatibilityData() {
    const loadingDiv = document.getElementById('general-compatibility-loading');
    const tableDiv = document.getElementById('general-compatibility-table');
    const errorDiv = document.getElementById('general-compatibility-error');
    const tbody = document.getElementById('general-compatibility-tbody');
    
    if (!loadingDiv || !tableDiv || !errorDiv || !tbody) {
        return; // Elements not found, probably on a different page
    }
    
    // Try to load cached data first
    const hasCachedData = loadCachedDroneData();
    
    try {
        // Always fetch fresh data (but don't show loading if we have cache)
        const response = await fetch('https://us-central1-eagleeyessearch.cloudfunctions.net/get_drone_models', {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' }
        });
        
        if (!response.ok) throw new Error('Failed to fetch drone models');
        
        const data = await response.json();
        const allDrones = data.drones || [];
        
        // Filter for Pilot-compatible drones only
        const pilotDrones = allDrones.filter(drone => {
            const compat = Array.isArray(drone.compatibility) ? drone.compatibility :
                          Array.isArray(drone.Compatibility) ? drone.Compatibility : [];
            return compat.map(x => String(x).toLowerCase()).includes('pilot');
        });
        
        // Sort drones alphabetically
        const sortedDrones = pilotDrones.filter(drone => drone.name && drone.brand).sort((a, b) => {
            const nameA = `${a.brand} ${a.name}`.toLowerCase();
            const nameB = `${b.brand} ${b.name}`.toLowerCase();
            return nameA.localeCompare(nameB);
        });
        
        // Add Autel and Skydio entries for Scan compatibility
        const additionalDrones = [
            {
                brand: 'Autel',
                name: 'Various Models',
                controllers_internally_tested: [],
                controllers_user_tested: [],
                controllers_not_tested: [],
                controllers_incompatible: [],
                scanOnly: true
            },
            {
                brand: 'Skydio',
                name: 'Various Models', 
                controllers_internally_tested: [],
                controllers_user_tested: [],
                controllers_not_tested: [],
                controllers_incompatible: [],
                scanOnly: true
            }
        ];
        
        // Combine and sort all drones
        const allDronesWithExtras = [...sortedDrones, ...additionalDrones].sort((a, b) => {
            const nameA = `${a.brand} ${a.name}`.toLowerCase();
            const nameB = `${b.brand} ${b.name}`.toLowerCase();
            return nameA.localeCompare(nameB);
        });
        
        if (allDronesWithExtras.length === 0) {
            throw new Error('No compatible drones found');
        }
        
        // Get cached data for comparison
        const cachedData = localStorage.getItem('droneCompatibilityData');
        const oldData = cachedData ? JSON.parse(cachedData) : [];
        
        if (hasCachedData && oldData.length > 0) {
            // Update only changed rows
            const hasChanges = updateChangedRows(allDronesWithExtras, oldData);
            
            // Remove cache indicator
            const indicator = document.getElementById('cache-indicator');
            if (indicator) indicator.remove();
            
            if (hasChanges) {
                console.log('Drone compatibility data updated with changes');
            } else {
                console.log('No changes in drone compatibility data');
            }
        } else {
            // No cached data, populate table normally
            tbody.innerHTML = '';
            allDronesWithExtras.forEach((drone, index) => {
                const row = createDroneRow(drone, index);
                tbody.appendChild(row);
            });
            
            loadingDiv.style.display = 'none';
            tableDiv.style.display = 'block';
        }
        
        // Update cache
        localStorage.setItem('droneCompatibilityData', JSON.stringify(allDronesWithExtras));
        localStorage.setItem('droneCompatibilityTimestamp', Date.now().toString());
        
        errorDiv.style.display = 'none';
        
    } catch (error) {
        console.error('Error loading drone compatibility data:', error);
        
        // If we have cached data, keep showing it
        if (hasCachedData) {
            const indicator = document.getElementById('cache-indicator');
            if (indicator) {
                indicator.textContent = 'Using cached data ‚Ä¢ Unable to check for updates';
                indicator.style.color = '#856404';
            }
        } else {
            // No cached data and fetch failed, show error
            loadingDiv.style.display = 'none';
            tableDiv.style.display = 'none';
            errorDiv.style.display = 'block';
        }
    }
}
</script> 
