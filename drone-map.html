<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EDS-B Drone Tracker Map</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <!-- Chart.js Zoom Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    
    <!-- Three.js for 3D flight profile viewer -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', 'Monaco', 'Menlo', monospace;
            background-color: #0a0a0a;
            color: #a0a0a0;
            overflow: hidden;
            height: 100vh;
        }

        /* Header */
        .tactical-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50px !important;
            min-height: 50px !important;
            max-height: 50px !important;
            background: linear-gradient(180deg, #1a1a1a 0%, #0a0a0a 100%);
            border-bottom: 2px solid #4a7c59;
            z-index: 100000 !important;
            display: flex !important;
            align-items: center;
            padding: 0 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            flex-wrap: nowrap !important;
            overflow: visible !important;
        }

        .tactical-header h1 {
            font-size: 22px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: #d4a574;
            text-shadow: 0 0 5px rgba(212, 165, 116, 0.3);
            margin: 0;
        }
        
        .tactical-header h1 span {
            font-size: 0.55em !important;
            text-shadow: 0 0 8px rgba(136, 136, 136, 0.4), 0 0 15px rgba(136, 136, 136, 0.2), 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .tactical-header .logo-link {
            display: flex;
            align-items: center;
            margin-right: 15px;
            text-decoration: none;
            position: relative;
            left: 5px; /* Shift slightly right to align with North Arrow center */
        }

        .tactical-header .logo-link img {
            height: 40px;
            width: 40px;
            border-radius: 6px;
            transition: opacity 0.2s;
        }

        .tactical-header .logo-link:hover img {
            opacity: 0.8;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-shrink: 1;
            flex-grow: 0;
            min-width: 0;
            max-width: 60%;
            z-index: 2;
            position: relative;
        }
        
        .header-center {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            display: none; /* Hidden by default to prevent overlap */
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 1;
            width: auto;
            max-width: 50%;
        }
        
        /* Only show tagline on very wide screens where there's plenty of space */
        @media (min-width: 1600px) {
            .header-center {
                display: flex;
            }
        }

        .tactical-header .subtitle {
            font-size: 10px;
            color: #666;
            letter-spacing: 2px;
            margin-left: 10px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            min-width: 150px;
            justify-content: flex-end;
            flex-shrink: 0;
        }
        
        .download-text {
            font-size: 12px;
            color: #b0b0b0;
            white-space: nowrap;
            margin-right: 0;
            line-height: 1.2;
        }
        
        .map-control-container {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-shrink: 0;
            margin-left: auto;
            position: absolute !important;
            right: 20px !important;
            top: 50% !important;
            transform: translateY(-50%) !important;
            z-index: 100001 !important;
            flex-wrap: nowrap !important;
        }
        
        .map-control-container button {
            height: 32px !important;
            min-height: 32px !important;
            max-height: 32px !important;
            box-sizing: border-box;
            padding: 8px 12px !important;
            display: flex !important;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            width: auto !important;
        }
        
        #baseMapControl {
            position: relative;
            z-index: 100002 !important;
        }
        
        #baseMapBtn {
            background: rgba(10, 10, 10, 0.9) !important;
            border: 1px solid #4a7c59 !important;
            color: #b0b0b0 !important;
            padding: 8px 12px !important;
            font-family: 'Courier New', monospace !important;
            font-size: 16px !important;
            cursor: pointer;
            border-radius: 4px;
            outline: none;
            font-weight: 500;
            transition: all 0.2s;
            min-height: 32px !important;
            max-height: 32px !important;
            height: 32px !important;
            display: flex !important;
            align-items: center;
            justify-content: center;
            position: relative;
            box-sizing: border-box !important;
            width: auto !important;
        }
        
        #baseMapBtn:hover {
            background: rgba(26, 26, 26, 0.95);
            border-color: #5a8a6a;
            color: #d4a574;
        }
        
        #baseMapBtn:focus {
            border-color: #5a8a6a;
            box-shadow: 0 0 5px rgba(74, 124, 89, 0.5);
        }
        
        .base-map-menu {
            position: absolute;
            top: calc(100% + 5px);
            right: 0;
            background: rgba(10, 10, 10, 0.98);
            border: 1px solid #4a7c59;
            border-radius: 4px;
            padding: 10px;
            z-index: 999999 !important;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }
        
        .base-map-option {
            background: rgba(10, 10, 10, 0.9);
            border: 1px solid #4a7c59;
            color: #b0b0b0;
            padding: 6px 12px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            cursor: pointer;
            border-radius: 4px;
            outline: none;
            font-weight: 500;
            transition: all 0.2s;
            min-width: 150px;
        }
        
        .base-map-option:hover {
            background: rgba(26, 26, 26, 0.95);
            border-color: #5a8a6a;
            color: #d4a574;
        }
        
        .base-map-option:active {
            background: rgba(30, 30, 30, 0.9);
        }
        
        
        .tagline-text {
            font-size: 14px;
            color: #5a8a6a;
            font-style: italic;
            letter-spacing: 0.5px;
            text-align: center;
            opacity: 1;
            transition: opacity 2.5s ease-in-out !important;
            font-weight: 400;
            text-shadow: 0 0 8px rgba(90, 138, 106, 0.4), 0 0 15px rgba(90, 138, 106, 0.2), 0 1px 2px rgba(0, 0, 0, 0.3);
            white-space: nowrap;
            max-width: 500px;
            overflow: hidden;
            text-overflow: ellipsis;
            will-change: opacity;
        }
        
        .tagline-text.fade-out {
            opacity: 0 !important;
        }
        
        /* Tagline is hidden by default - only shows on very wide screens (1600px+) */
        /* This prevents overlap with "Broadcast your drone's live location" text */
        
        /* Step 1: Hide subtitle when left and right sides get too close */
        @media (max-width: 1300px) {
            .tactical-header h1 span {
                display: none; /* Hide "Eagle Dependent Surveillance-Broadcast" */
            }
        }
        
        /* Step 2: Hide "Broadcast your drone's live location for free" text when it overlaps */
        @media (max-width: 1000px) {
            .download-text {
                display: none !important;
            }
        }
        
        /* Step 3: Hide status indicator to make room for buttons, keep everything in one row */
        @media (max-width: 1000px) {
            /* Hide status indicator to make room for buttons */
            .status-indicator {
                display: none !important;
            }
            
            /* Shrink north arrow on mobile but keep position */
            .north-arrow-image {
                width: 50px;
                height: 50px;
            }
            
            .north-arrow-label {
                font-size: 14px;
                top: 6px;
            }
        }
        
        @media (max-width: 768px) {
            .tactical-header {
                padding: 6px 10px;
                height: 48px !important;
                min-height: 48px !important;
                max-height: 48px !important;
                flex-wrap: nowrap !important;
                overflow: hidden;
            }
            
            .tactical-header h1 {
                font-size: 16px;
                letter-spacing: 1.5px;
            }
            
            .tactical-header .logo-link img {
                height: 30px;
                width: 30px;
            }
            
            /* Keep buttons in top nav bar on right side - never drop */
            .header-left {
                flex: 0 0 auto;
                min-width: 0;
                max-width: 50%;
            }
            
            .map-control-container {
                position: absolute !important;
                right: 10px !important;
                top: 50% !important;
                transform: translateY(-50%) !important;
                width: auto !important;
                margin-top: 0 !important;
                margin-left: 0 !important;
                flex-wrap: nowrap !important;
                max-width: 50% !important;
            }
            
            /* Status already hidden at 1000px, but ensure it stays hidden */
            .status-indicator {
                display: none !important;
            }
            
            /* Keep download text hidden */
            .download-text {
                display: none !important;
            }
            
            #downloadBtn {
                font-size: 9px !important;
                padding: 6px 8px !important;
                min-width: 60px;
            }
            
            #legendBtn {
                font-size: 10px !important;
                padding: 6px 10px !important;
            }
            
            #baseMapBtn {
                font-size: 12px !important;
                padding: 6px 10px !important;
            }
            
            .status-text {
                font-size: 9px;
            }
            
            .status-text:first-of-type {
                display: none;
            }
            
            .north-arrow-image {
                width: 40px;
                height: 40px;
            }
            
            .north-arrow-label {
                font-size: 12px;
                top: 5px;
            }
            
            #map {
                top: 48px;
            }
        }
        
        @media (max-width: 480px) {
            .tactical-header {
                padding: 5px 8px;
                height: 44px !important;
                min-height: 44px !important;
                max-height: 44px !important;
                flex-wrap: nowrap !important;
                overflow: hidden;
            }
            
            .tactical-header h1 {
                font-size: 14px;
            }
            
            .tactical-header .logo-link img {
                height: 26px;
                width: 26px;
            }
            
            /* Keep buttons in top nav bar on right side - never drop */
            .header-left {
                flex: 0 0 auto;
                min-width: 0;
                max-width: 45%;
            }
            
            .map-control-container {
                position: absolute !important;
                right: 8px !important;
                top: 50% !important;
                transform: translateY(-50%) !important;
                width: auto !important;
                margin-top: 0 !important;
                margin-left: 0 !important;
                flex-wrap: nowrap !important;
                max-width: 55% !important;
                gap: 4px;
            }
            
            /* Hide status indicator (pulsing green dot) on narrow mobile */
            .status-indicator {
                display: none !important;
            }
            
            /* Keep download text hidden */
            .download-text {
                display: none !important;
            }
            
            #downloadBtn {
                font-size: 8px !important;
                padding: 5px 6px !important;
                min-width: 50px;
            }
            
            #legendBtn {
                font-size: 9px !important;
                padding: 5px 8px !important;
            }
            
            #baseMapBtn {
                font-size: 11px !important;
                padding: 5px 8px !important;
            }
            
            .status-text {
                font-size: 8px;
            }
            
            .north-arrow-image {
                width: 35px;
                height: 35px;
            }
            
            .north-arrow-label {
                font-size: 10px;
                top: 4px;
            }
            
            #map {
                top: 44px;
            }
        }
        
        @media (max-width: 360px) {
            .tactical-header {
                padding: 4px 6px;
                min-height: 42px;
                flex-wrap: nowrap !important;
                overflow: hidden;
            }
            
            .tactical-header h1 {
                font-size: 12px;
            }
            
            .tactical-header .logo-link img {
                height: 24px;
                width: 24px;
            }
            
            /* Keep buttons in top nav bar - make them smaller if needed */
            .header-left {
                max-width: 40%;
            }
            
            .map-control-container {
                position: absolute !important;
                right: 6px !important;
                top: 50% !important;
                transform: translateY(-50%) !important;
                max-width: 60% !important;
                gap: 3px;
            }
            
            /* Keep status hidden on very narrow screens */
            .status-indicator {
                display: none !important;
            }
            
            .status-text {
                font-size: 7px;
            }
            
            #downloadBtn {
                font-size: 7px !important;
                padding: 4px 5px !important;
                min-width: 45px;
            }
            
            #legendBtn {
                font-size: 8px !important;
                padding: 4px 6px !important;
            }
            
            #baseMapBtn {
                font-size: 10px !important;
                padding: 4px 6px !important;
            }
            
            .north-arrow-image {
                width: 30px;
                height: 30px;
            }
            
            .north-arrow-label {
                font-size: 9px;
                top: 3px;
            }
            
            #map {
                top: 42px;
            }
        }
        
        #downloadTestDataBtn {
            background: rgba(10, 10, 10, 0.9);
            border: 1px solid #4a7c59;
            color: #b0b0b0;
            padding: 6px 12px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            cursor: pointer;
            border-radius: 4px;
            outline: none;
            font-weight: 500;
            transition: all 0.2s;
            text-decoration: none;
            display: inline-block;
        }
        
        #downloadTestDataBtn:hover {
            background: rgba(26, 26, 26, 0.95);
            border-color: #5a8a6a;
            color: #d4a574;
        }
        
        #downloadTestDataBtn:focus {
            border-color: #5a8a6a;
            box-shadow: 0 0 5px rgba(74, 124, 89, 0.5);
        }
        
        #downloadTestDataBtn.pulse {
            animation: greenPulse 3s ease-in-out infinite;
        }
        
        @keyframes greenPulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(74, 124, 89, 0);
                border-color: #4a7c59;
            }
            50% {
                box-shadow: 0 0 10px 3px rgba(74, 124, 89, 0.6);
                border-color: #5a8a6a;
            }
        }
        
        #downloadBtn {
            background: rgba(10, 10, 10, 0.9) !important;
            border: 1px solid #4a7c59 !important;
            color: #b0b0b0 !important;
            padding: 8px 12px !important;
            font-family: 'Courier New', monospace !important;
            font-size: 12px !important;
            line-height: 1.2 !important;
            cursor: pointer;
            border-radius: 4px;
            outline: none;
            font-weight: 500;
            transition: all 0.2s;
            text-align: center;
            white-space: normal;
            min-height: 32px !important;
            max-height: 32px !important;
            height: 32px !important;
            display: flex !important;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            box-sizing: border-box !important;
        }
        
        #downloadBtn:hover {
            background: rgba(26, 26, 26, 0.95);
            border-color: #5a8a6a;
            color: #d4a574;
        }
        
        #downloadBtn:focus {
            border-color: #5a8a6a;
            box-shadow: 0 0 5px rgba(74, 124, 89, 0.5);
        }

        #legendBtn {
            background: rgba(10, 10, 10, 0.9) !important;
            border: 1px solid #4a7c59 !important;
            color: #b0b0b0 !important;
            padding: 8px 12px !important;
            font-family: 'Courier New', monospace !important;
            font-size: 12px !important;
            cursor: pointer;
            border-radius: 4px;
            outline: none;
            font-weight: 500;
            min-height: 32px !important;
            max-height: 32px !important;
            height: 32px !important;
            display: flex !important;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-sizing: border-box !important;
        }
        
        #legendBtn:hover {
            background: rgba(26, 26, 26, 0.95);
            border-color: #5a8a6a;
            color: #d4a574;
        }
        
        #legendBtn:focus {
            border-color: #5a8a6a;
            box-shadow: 0 0 5px rgba(74, 124, 89, 0.5);
        }
        
        .legend-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid #4a7c59;
            border-radius: 4px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #b0b0b0;
            z-index: 1000;
            display: none;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            min-width: 200px;
        }
        
        .legend-panel.visible {
            display: block;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 10px;
        }
        
        .legend-item:last-child {
            margin-bottom: 0;
        }
        
        .legend-symbol {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .legend-line {
            width: 30px;
            height: 2px;
            border-top: 2px dashed;
        }
        
        .legend-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        .legend-dot-pulse {
            animation: pulse 2s infinite;
        }
        
        .legend-circle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #5a8a6a;
            box-shadow: 0 0 5px rgba(90, 138, 106, 0.5);
            animation: pulse 2s infinite;
            margin: 0 5px;
        }

        .status-dot.connected {
            background-color: #5a8a6a;
            box-shadow: 0 0 5px rgba(90, 138, 106, 0.5);
        }

        .status-dot.disconnected {
            background-color: #d4a574;
            box-shadow: 0 0 5px rgba(212, 165, 116, 0.5);
        }

        .status-dot.failed {
            background-color: #dc143c;
            box-shadow: 0 0 5px rgba(220, 20, 60, 0.5);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }


        .status-text {
            font-size: 11px;
            color: #a0a0a0;
            letter-spacing: 1px;
        }
        
        .status-indicator .status-text:first-of-type {
            margin-right: 0;
        }
        
        .status-text-right {
            margin-left: auto;
        }

        /* Map Container */
        #map {
            position: absolute;
            top: 50px;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #0a0a0a;
            z-index: 1;
        }

        /* Controls */
        .tactical-controls {
            position: absolute;
            top: 60px;
            right: 20px;
            z-index: 1000;
            background: rgba(10, 10, 10, 0.9);
            border: 1px solid #4a7c59;
            border-radius: 4px;
            padding: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            max-width: 300px;
        }

        .control-panel {
            font-size: 13px;
            color: #b0b0b0;
            font-weight: 500;
        }

        .control-panel h3 {
            font-size: 14px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 1px solid #4a7c59;
            padding-bottom: 5px;
            color: #d4a574;
            font-weight: bold;
        }

        .control-item {
            margin: 8px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-item label {
            min-width: 80px;
            font-size: 12px;
            font-weight: 500;
        }

        .control-item input[type="text"],
        .control-item input[type="number"] {
            background: #1a1a1a;
            border: 1px solid #4a7c59;
            color: #b0b0b0;
            padding: 4px 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            width: 150px;
            font-weight: 500;
        }

        .control-item input:focus {
            outline: none;
            box-shadow: 0 0 5px rgba(74, 124, 89, 0.5);
            border-color: #5a8a6a;
        }

        .tactical-button {
            background: #1a1a1a;
            border: 1px solid #4a7c59;
            color: #b0b0b0;
            padding: 6px 12px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
            font-weight: 500;
        }

        .tactical-button:hover {
            background: #4a7c59;
            color: #ffffff;
            box-shadow: 0 0 10px rgba(74, 124, 89, 0.3);
        }

        /* Info Panel */
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(10, 10, 10, 0.9);
            border: 1px solid #4a7c59;
            border-radius: 4px;
            padding: 15px;
            min-width: 250px;
            max-height: 300px;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .info-panel h3 {
            font-size: 14px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 1px solid #4a7c59;
            padding-bottom: 5px;
            color: #d4a574;
            font-weight: bold;
        }

        .info-item {
            font-size: 14px;
            margin: 6px 0;
            color: #b0b0b0;
            display: flex;
            justify-content: space-between;
            font-weight: 400;
        }

        .info-item .label {
            color: #b0b0b0;
            font-weight: 400;
        }

        .info-item .value {
            color: #d4a574;
            font-weight: 500;
        }

        /* Custom Leaflet Controls */
        .leaflet-control {
            background: rgba(10, 10, 10, 0.9) !important;
            border: 1px solid #4a7c59 !important;
        }

        .leaflet-control a {
            background-color: #1a1a1a !important;
            color: #a0a0a0 !important;
            border: 1px solid #4a7c59 !important;
        }

        .leaflet-control a:hover {
            background-color: #4a7c59 !important;
            color: #ffffff !important;
        }

        /* Leaflet bottom controls positioning - ensure they stay at bottom */
        .leaflet-bottom {
            bottom: 0 !important;
            z-index: 400 !important;
        }

        .leaflet-control-attribution {
            background: rgba(10, 10, 10, 0.9) !important;
            color: #666 !important;
            font-size: 9px !important;
            padding: 2px 5px !important;
            margin: 0 !important;
            max-width: 100% !important;
            box-sizing: border-box !important;
        }

        .leaflet-control-attribution a {
            color: #5a8a6a !important;
        }

        /* Ensure Leaflet controls don't conflict with control panel */
        .leaflet-bottom.leaflet-right {
            right: 0 !important;
            bottom: 0 !important;
        }

        .leaflet-bottom.leaflet-left {
            left: 0 !important;
            bottom: 0 !important;
        }
        
        /* Scale Bar Control - Military/Operational Theme */
        .scale-bar-control {
            background: rgba(10, 10, 10, 0.95) !important;
            border: 2px solid #4a7c59 !important;
            border-radius: 4px !important;
            padding: 8px 12px !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(74, 124, 89, 0.3) !important;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            z-index: 2000 !important;
            position: relative !important;
        }
        
        /* Ensure scale bar container is visible */
        .leaflet-bottom.leaflet-left {
            z-index: 2000 !important;
        }
        
        .leaflet-bottom.leaflet-left .scale-bar-control {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            margin: 10px !important;
        }
        
        /* Ensure Leaflet control container doesn't hide our custom scale bar */
        .leaflet-control-container .leaflet-bottom.leaflet-left {
            pointer-events: none !important;
        }
        
        .leaflet-control-container .leaflet-bottom.leaflet-left .scale-bar-control {
            pointer-events: auto !important;
        }
        
        .scale-bar-content {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
        }
        
        .scale-bar-line {
            width: 120px;
            height: 3px;
            background: linear-gradient(to right, #4a7c59 0%, #4a7c59 50%, transparent 50%, transparent 100%);
            border-top: 1px solid #1a1a1a;
            border-bottom: 1px solid #1a1a1a;
            position: relative;
        }
        
        .scale-bar-line::before {
            content: '';
            position: absolute;
            left: 0;
            top: -2px;
            width: 2px;
            height: 7px;
            background: #4a7c59;
            border: 1px solid #1a1a1a;
        }
        
        .scale-bar-line::after {
            content: '';
            position: absolute;
            right: 0;
            top: -2px;
            width: 2px;
            height: 7px;
            background: #4a7c59;
            border: 1px solid #1a1a1a;
        }
        
        .scale-bar-text {
            color: #d4a574;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            font-weight: bold;
            letter-spacing: 1px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        /* North Arrow Control - No background box, just the image */
        .north-arrow-control {
            background: transparent !important;
            border: none !important;
            padding: 0 !important;
            box-shadow: none !important;
        }
        
        /* North arrow should always be at top-left of map, regardless of screen size */
        /* Leaflet positions it relative to the map container, so it's always at top-left of map */
        .leaflet-top.leaflet-left {
            top: 0 !important;
            left: 0 !important;
            margin: 0 !important;
        }
        
        /* Remove default Leaflet control margins for north arrow */
        .leaflet-top.leaflet-left .leaflet-control {
            margin: 0 !important;
            margin-top: 0 !important;
            margin-left: 0 !important;
        }
        
        /* Ensure north arrow control has no padding */
        .leaflet-top.leaflet-left .north-arrow-control {
            margin: 0 !important;
            padding: 0 !important;
        }
        
        /* Ensure north arrow stays at top-left on all screen sizes - don't move it */
        @media (max-width: 768px) {
            .leaflet-top.leaflet-left {
                top: 0 !important;
                left: 0 !important;
                margin: 0 !important;
            }
        }
        
        @media (max-width: 480px) {
            .leaflet-top.leaflet-left {
                top: 0 !important;
                left: 0 !important;
                margin: 0 !important;
            }
        }
        
        @media (max-width: 360px) {
            .leaflet-top.leaflet-left {
                top: 0 !important;
                left: 0 !important;
                margin: 0 !important;
            }
        }
        
        .north-arrow-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .north-arrow-image {
            width: 50px;
            height: 50px;
            object-fit: contain;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.8));
        }
        
        .north-arrow-label {
            position: absolute;
            top: 6px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(0, 0, 0, 0.6);
            z-index: 10;
            pointer-events: none;
        }

        /* Ensure Leaflet controls container stays at bottom edge */
        .leaflet-bottom {
            position: absolute !important;
            bottom: 0 !important;
            z-index: 400 !important;
            pointer-events: none !important;
        }

        .leaflet-control {
            pointer-events: auto !important;
        }

        /* Compact attribution on all screen sizes */
        .leaflet-control-attribution {
            white-space: nowrap !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
            max-width: 100% !important;
            box-sizing: border-box !important;
        }

        /* Layer Control Styling */
        .leaflet-control-layers {
            background: rgba(10, 10, 10, 0.9) !important;
            border: 1px solid #4a7c59 !important;
            color: #a0a0a0 !important;
        }
        

        .leaflet-control-layers-expanded {
            padding: 10px !important;
            color: #a0a0a0 !important;
        }

        .leaflet-control-layers label {
            color: #a0a0a0 !important;
            font-family: 'Courier New', monospace !important;
            font-size: 11px !important;
        }

        .leaflet-control-layers input[type="radio"] {
            accent-color: #4a7c59 !important;
        }

        .leaflet-control-layers-selector {
            accent-color: #4a7c59 !important;
        }

        /* Custom Marker Styles */
        .tactical-marker {
            filter: drop-shadow(0 0 3px rgba(90, 138, 106, 0.6));
        }

        /* Acoustic node pulsing ring animation - toned down */
        @keyframes acousticPulse {
            0% {
                transform: scale(1);
                opacity: 0.7;
                box-shadow: 0 0 0 0 rgba(74, 155, 157, 0.4);
            }
            50% {
                transform: scale(1.08);
                opacity: 0.6;
                box-shadow: 0 0 0 5px rgba(74, 155, 157, 0.2);
            }
            100% {
                transform: scale(1);
                opacity: 0.7;
                box-shadow: 0 0 0 0 rgba(74, 155, 157, 0);
            }
        }

        .acoustic-node-marker {
            width: 12px !important;
            height: 12px !important;
            background-color: #4A9B9D;
            border: 2px solid #3A7B7D;
            border-radius: 50%;
            position: relative;
            animation: acousticPulse 2s ease-in-out infinite;
        }

        /* Toggle controls */
        .toggle-control {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 2px 0;
        }
        
        .toggle-control span {
            flex: 1;
            text-align: left;
            font-size: 14px !important;
            color: #b0b0b0 !important;
            font-weight: 400 !important;
        }
        
        .toggle-control .toggle-switch {
            flex-shrink: 0;
            margin-left: auto;
        }

        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .radio-label {
            display: flex;
            align-items: center;
            font-size: 14px;
            color: #b0b0b0;
            font-weight: 400;
            cursor: pointer;
        }

        .radio-label input[type="radio"],
        .radio-label input[type="checkbox"] {
            margin-right: 8px;
            accent-color: #4a7c59;
            cursor: pointer;
        }

        .radio-label span {
            user-select: none;
        }

        .toggle-switch {
            position: relative;
            width: 40px;
            height: 20px;
            background-color: #333;
            border-radius: 20px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .toggle-switch.active {
            background-color: #4a7c59;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background-color: #fff;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(20px);
        }

        /* TDOA direction indicator - no border, fill only */
        .tdoa-direction-wedge {
            fill: rgba(74, 155, 157, 0.4);
            stroke: none;
            stroke-width: 0;
            cursor: pointer;
            transition: fill-opacity 0.3s ease;
        }
        
        /* Pulsing animation for directional wedges - radar ping effect (fill only) */
        @keyframes wedgePulse {
            0% {
                fill-opacity: var(--pulse-max-opacity, 0.7);
            }
            50% {
                fill-opacity: var(--pulse-min-opacity, 0.4);
            }
            100% {
                fill-opacity: var(--pulse-max-opacity, 0.7);
            }
        }
        
        .tdoa-direction-wedge.pulsing {
            animation: wedgePulse var(--pulse-duration, 1.5s) ease-in-out infinite;
        }

        /* Pulsing red animation for detection bubbles when drone is within range */
        /* Note: Leaflet circles use SVG, so we'll handle animation via JavaScript */

        /* Collapsible panel styling */
        .panel-header {
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 0;
            padding: 0;
        }

        .panel-header::after {
            content: '▼';
            font-size: 12px;
            color: #4a7c59;
            transition: transform 0.3s ease;
        }

        .panel-header.collapsed::after {
            transform: rotate(-90deg);
        }

        .panel-content {
            overflow-y: auto;
            overflow-x: hidden;
            transition: max-height 0.3s ease;
        }

        .panel-content.collapsed {
            max-height: 0 !important;
            overflow: hidden;
            padding-top: 0;
            padding-bottom: 0;
        }
        
        /* Control Panel content grows to fit content, scrolls if exceeds viewport */
        .flight-log-player .panel-content:not(.collapsed) {
            max-height: calc(100vh - 150px);
            overflow-y: auto;
        }
        
        /* Scrollbar styling for Control Panel - ensure it doesn't overlap content */
        .flight-log-player .panel-content {
            padding-right: 10px; /* Add padding to prevent content from being under scrollbar */
        }
        
        .flight-log-player .panel-content::-webkit-scrollbar {
            width: 6px;
        }

        .flight-log-player .panel-content::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .flight-log-player .panel-content::-webkit-scrollbar-thumb {
            background: #4a7c59;
            border-radius: 3px;
        }

        .flight-log-player .panel-content::-webkit-scrollbar-thumb:hover {
            background: #5a8a6a;
        }

        /* Scrollbar Styling */
        .info-panel::-webkit-scrollbar {
            width: 6px;
        }

        .info-panel::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .info-panel::-webkit-scrollbar-thumb {
            background: #4a7c59;
            border-radius: 3px;
        }

        .info-panel::-webkit-scrollbar-thumb:hover {
            background: #5a8a6a;
        }

        /* MQTT Control Panel (Bottom Left) */
        .mqtt-control-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 280px;
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid #4a7c59;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .mqtt-control-panel .panel-header {
            padding: 10px 15px;
            background: rgba(26, 26, 26, 0.8);
            border-bottom: 1px solid #4a7c59;
            cursor: pointer;
            user-select: none;
            font-size: 12px;
            font-weight: bold;
            color: #d4a574;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        .mqtt-control-panel .panel-header:hover {
            background: rgba(26, 26, 26, 0.95);
            color: #e4b584;
        }

        .mqtt-control-panel .panel-header.collapsed::after {
            content: ' ▼';
            float: right;
            font-size: 10px;
        }

        .mqtt-control-panel .panel-header:not(.collapsed)::after {
            content: ' ▲';
            float: right;
            font-size: 10px;
        }

        .mqtt-control-panel .panel-content {
            padding: 15px;
            max-height: calc(100vh - 150px);
            overflow-y: auto;
        }

        .mqtt-control-panel .panel-content.collapsed {
            display: none;
        }

        .mqtt-control-panel .panel-content:not(.collapsed) {
            max-height: calc(100vh - 150px);
            overflow-y: auto;
        }

        .mqtt-control-panel .panel-content::-webkit-scrollbar {
            width: 6px;
        }

        .mqtt-control-panel .panel-content::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .mqtt-control-panel .panel-content::-webkit-scrollbar-thumb {
            background: #4a7c59;
            border-radius: 3px;
        }

        .mqtt-control-panel .panel-content::-webkit-scrollbar-thumb:hover {
            background: #5a8a6a;
        }

        /* Flight Log Control */
        .flight-log-player {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 320px;
            min-width: 320px;
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid #4a7c59;
            border-radius: 4px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .flight-log-player .panel-header {
            padding: 10px 15px;
            background: rgba(26, 26, 26, 0.8);
            border-bottom: 1px solid #4a7c59;
            cursor: pointer;
            user-select: none;
            font-size: 12px;
            font-weight: bold;
            color: #d4a574;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
            margin: 0;
        }

        .flight-log-player .panel-header:hover {
            background: rgba(26, 26, 26, 0.95);
            color: #e4b584;
        }

        .flight-log-player .panel-header.collapsed::after {
            content: ' ▼';
            float: right;
            font-size: 10px;
        }

        .flight-log-player .panel-header:not(.collapsed)::after {
            content: ' ▲';
            float: right;
            font-size: 10px;
        }

        .file-upload {
            margin-bottom: 0 !important;
            margin-top: 10px !important;
            padding-top: 10px !important;
        }
        
        .flight-log-player .panel-content:not(.collapsed) .file-upload {
            margin-top: 10px !important;
            padding-top: 10px !important;
            margin-bottom: 0 !important;
        }
        
        #importFlightLogButtonContainer {
            gap: 8px !important;
            margin-bottom: 20px !important;
        }
        
        .file-upload.centered {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .file-upload input[type="file"] {
            display: none;
        }

        .file-upload-label {
            display: inline-block;
            padding: 8px 15px;
            background: #1a1a1a;
            border: 1px solid #4a7c59;
            color: #b0b0b0;
            cursor: pointer;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
            font-weight: 500;
        }

        .file-upload-label:hover {
            background: #4a7c59;
            color: #ffffff;
        }

        .player-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .play-button {
            background: #1a1a1a;
            border: 1px solid #4a7c59;
            color: #b0b0b0;
            padding: 8px 15px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
            min-width: 80px;
            font-weight: 500;
        }

        .play-button:hover {
            background: #4a7c59;
            color: #ffffff;
        }

        .play-button.playing {
            background: #4a7c59;
            color: #ffffff;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 15px;
        }

        .speed-control label {
            font-size: 14px;
            min-width: 60px;
            font-weight: 400;
        }

        .speed-control input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: #1a1a1a;
            border: 1px solid #4a7c59;
            outline: none;
        }

        .speed-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #5a8a6a;
            cursor: pointer;
            border: 1px solid #4a7c59;
        }

        .speed-control input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #5a8a6a;
            cursor: pointer;
            border: 1px solid #4a7c59;
        }

        .speed-value {
            font-size: 14px;
            color: #d4a574;
            min-width: 40px;
            text-align: right;
            font-weight: 400;
        }

        .timeline-container {
            margin-bottom: 10px;
            width: 100%;
            box-sizing: border-box;
            padding: 0 !important;
            margin-left: 0 !important;
            margin-right: 0 !important;
        }

        .timeline-label {
            font-size: 13px;
            color: #b0b0b0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            white-space: nowrap;
            gap: 10px;
            margin-bottom: 5px;
            width: 100%;
            box-sizing: border-box;
            padding: 0;
            font-weight: 400;
        }
        
        .timeline-label span:last-child {
            white-space: nowrap;
            flex-shrink: 0;
            font-weight: 400;
        }

        .timeline-slider {
            width: 100% !important;
            max-width: 100% !important;
            -webkit-appearance: none !important;
            appearance: none !important;
            height: 4px;
            background: #1a1a1a !important;
            border: 1px solid #4a7c59 !important;
            outline: none;
            box-sizing: border-box;
            margin: 0 !important;
            padding: 0 !important;
            display: block;
        }
        
        /* Override browser default blue fill for webkit sliders */
        .timeline-slider::-webkit-slider-runnable-track {
            height: 4px;
            -webkit-appearance: none !important;
            background: #1a1a1a !important;
            border: 1px solid #4a7c59 !important;
        }
        
        /* Ensure thumb is green */
        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none !important;
            background: #5a8a6a !important;
        }

        .timeline-slider::-moz-range-track {
            height: 4px;
            background: #1a1a1a;
            border: 1px solid #4a7c59;
        }

        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #5a8a6a;
            cursor: pointer;
            border: 1px solid #4a7c59;
            border-radius: 50%;
            margin-top: -5px;
        }

        .timeline-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #5a8a6a;
            cursor: pointer;
            border: 1px solid #4a7c59;
            border-radius: 50%;
        }

        /* Style the filled portion of the timeline slider to match speed slider green color scheme */
        
        /* Acoustic timeline slider - same green color scheme */
        #acousticTimelineSlider {
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: linear-gradient(to right, #4a7c59 0%, #4a7c59 var(--slider-progress, 0%), #1a1a1a var(--slider-progress, 0%));
            border: 1px solid #4a7c59;
            outline: none;
        }
        
        #acousticTimelineSlider::-webkit-slider-runnable-track {
            height: 4px;
            background: #1a1a1a;
            border: 1px solid #4a7c59;
        }
        
        #acousticTimelineSlider::-moz-range-track {
            height: 4px;
            background: #1a1a1a;
            border: 1px solid #4a7c59;
        }
        
        #acousticTimelineSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #5a8a6a;
            cursor: pointer;
            border: 1px solid #4a7c59;
            border-radius: 50%;
            margin-top: -5px;
        }
        
        #acousticTimelineSlider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #5a8a6a;
            cursor: pointer;
            border: 1px solid #4a7c59;
            border-radius: 50%;
        }
        
        /* Flight log timeline slider - same styling as acoustic timeline slider */
        #timelineSlider {
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: linear-gradient(to right, #4a7c59 0%, #4a7c59 var(--slider-progress, 0%), #1a1a1a var(--slider-progress, 0%));
            border: 1px solid #4a7c59;
            outline: none;
        }
        
        #timelineSlider::-webkit-slider-runnable-track {
            height: 4px;
            background: #1a1a1a;
            border: 1px solid #4a7c59;
        }
        
        #timelineSlider::-moz-range-track {
            height: 4px;
            background: #1a1a1a;
            border: 1px solid #4a7c59;
        }
        
        #timelineSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #5a8a6a;
            cursor: pointer;
            border: 1px solid #4a7c59;
            border-radius: 50%;
            margin-top: -5px;
        }
        
        #timelineSlider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #5a8a6a;
            cursor: pointer;
            border: 1px solid #4a7c59;
            border-radius: 50%;
        }

        .flight-stats {
            font-size: 14px;
            color: #b0b0b0;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #4a7c59;
            font-weight: 400;
        }

        .flight-stats div {
            margin: 4px 0;
            display: flex;
            justify-content: space-between;
        }

        .flight-stats .label {
            color: #b0b0b0;
            font-weight: 400;
        }

        .flight-stats .value {
            color: #d4a574;
            font-weight: 500;
        }

        /* Flight Log List Items */
        .flight-log-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            margin-bottom: 5px;
            background: rgba(26, 26, 26, 0.5);
            border: 1px solid #4a7c59;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .flight-log-item:hover {
            background: rgba(26, 26, 26, 0.8);
            border-color: #5a8a6a;
        }

        .flight-log-item .color-indicator {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            flex-shrink: 0;
        }

        .flight-log-item .flight-log-name {
            flex: 1;
            font-size: 12px;
            color: #b0b0b0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .flight-log-item .flight-log-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .flight-log-item .flight-log-info {
            background: rgba(74, 124, 89, 0.3);
            border: 1px solid #4a7c59;
            color: #4a7c59;
            padding: 2px 6px;
            font-size: 10px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
            font-weight: bold;
        }

        .flight-log-item .flight-log-info:hover {
            background: rgba(74, 124, 89, 0.5);
            color: #5a8a6a;
        }

        .flight-log-item .flight-log-remove {
            background: rgba(220, 20, 60, 0.3);
            border: 1px solid #dc143c;
            color: #dc143c;
            padding: 2px 6px;
            font-size: 10px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
        }

        .flight-log-item .flight-log-remove:hover {
            background: rgba(220, 20, 60, 0.5);
        }

        /* Flight Log Info Popup */
        .flight-log-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 10, 0.98);
            border: 2px solid #4a7c59;
            border-radius: 8px;
            padding: 20px;
            min-width: 500px;
            max-width: 80vw;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 2000;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
        }
        
        /* Mobile optimization for flight log popup */
        @media (max-width: 768px) {
            .flight-log-popup {
                min-width: 90vw;
                max-width: 95vw;
                max-height: 90vh;
                padding: 15px;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }
        }
        
        @media (max-width: 480px) {
            .flight-log-popup {
                min-width: 95vw;
                max-width: 95vw;
                max-height: 85vh;
                padding: 12px;
            }
        }

        /* Wider popup on desktop for analytics */
        @media (min-width: 1024px) {
            .flight-log-popup {
                max-width: 95vw;
                min-width: 800px;
            }
        }

        .flight-log-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #4a7c59;
        }

        .flight-log-popup-header h3 {
            margin: 0;
            color: #d4a574;
            font-size: 16px;
        }

        .flight-log-popup-close {
            background: rgba(220, 20, 60, 0.3);
            border: 1px solid #dc143c;
            color: #dc143c;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
        }

        .flight-log-popup-close:hover {
            background: rgba(220, 20, 60, 0.5);
        }

        .flight-log-popup-content {
            color: #b0b0b0;
            font-size: 12px;
        }

        .flight-log-popup-section {
            margin-bottom: 15px;
        }

        .flight-log-popup-section h4 {
            color: #d4a574;
            font-size: 14px;
            margin-bottom: 8px;
            border-bottom: 1px solid #4a7c59;
            padding-bottom: 5px;
        }

        .flight-log-popup-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }

        .flight-log-popup-table th,
        .flight-log-popup-table td {
            padding: 6px;
            text-align: left;
            border-bottom: 1px solid rgba(74, 124, 89, 0.3);
        }

        .flight-log-popup-table th {
            color: #d4a574;
            font-weight: 500;
        }

        .flight-log-popup-table td {
            color: #b0b0b0;
        }

        .flight-log-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1999;
        }

        /* Tabs */
        .flight-log-popup-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            border-bottom: 1px solid #4a7c59;
        }

        .flight-log-popup-tab {
            padding: 8px 15px;
            background: rgba(26, 26, 26, 0.5);
            border: 1px solid #4a7c59;
            border-bottom: none;
            color: #b0b0b0;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            border-radius: 4px 4px 0 0;
        }

        .flight-log-popup-tab:hover {
            background: rgba(26, 26, 26, 0.8);
            color: #d4a574;
        }

        .flight-log-popup-tab.active {
            background: rgba(10, 10, 10, 0.95);
            color: #d4a574;
            border-color: #5a8a6a;
        }

        .flight-log-popup-tab-content {
            display: none;
        }

        .flight-log-popup-tab-content.active {
            display: block;
        }

        /* Flight Panel Tabs (in View Flight Logs panel) */
        .flight-panel-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            border-bottom: 1px solid #4a7c59;
        }

        .flight-panel-tab {
            padding: 8px 15px;
            background: rgba(26, 26, 26, 0.5);
            border: 1px solid #4a7c59;
            border-bottom: none;
            color: #b0b0b0;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            border-radius: 4px 4px 0 0;
        }

        .flight-panel-tab:hover {
            background: rgba(26, 26, 26, 0.8);
            color: #d4a574;
        }

        .flight-panel-tab.active {
            background: rgba(10, 10, 10, 0.95);
            color: #d4a574;
            border-color: #5a8a6a;
        }

        .flight-panel-tab-content {
            display: none;
        }

        .flight-panel-tab-content.active {
            display: block;
        }

        /* Point Navigation */
        .point-navigation {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background: rgba(26, 26, 26, 0.5);
            border: 1px solid #4a7c59;
            border-radius: 4px;
        }

        .point-navigation button {
            background: rgba(74, 124, 89, 0.3);
            border: 1px solid #4a7c59;
            color: #4a7c59;
            padding: 5px 12px;
            font-size: 12px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
        }

        .point-navigation button:hover:not(:disabled) {
            background: rgba(74, 124, 89, 0.5);
            color: #5a8a6a;
        }

        .point-navigation button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .point-navigation .point-counter {
            color: #b0b0b0;
            font-size: 12px;
        }

        .point-navigation .point-input-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .point-navigation .point-input {
            background: rgba(10, 10, 10, 0.9);
            border: 1px solid #4a7c59;
            color: #b0b0b0;
            padding: 4px 8px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            width: 60px;
            text-align: center;
            border-radius: 3px;
            outline: none;
        }

        .point-navigation .point-input:focus {
            border-color: #5a8a6a;
            color: #d4a574;
            box-shadow: 0 0 5px rgba(74, 124, 89, 0.5);
        }

        .point-navigation .point-input-label {
            color: #888;
            font-size: 10px;
        }

        /* Messages List */
        .messages-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .message-item {
            padding: 8px;
            margin-bottom: 5px;
            background: rgba(26, 26, 26, 0.5);
            border-left: 3px solid #4a7c59;
            border-radius: 3px;
            font-size: 11px;
            color: #b0b0b0;
        }

        .message-item .message-time {
            color: #d4a574;
            font-weight: 500;
            margin-bottom: 3px;
        }

        .message-item .message-text {
            color: #b0b0b0;
        }

        /* Subtle flashing light effect */
        @keyframes pulseRing {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.8);
                opacity: 0.3;
            }
            100% {
                transform: translate(-50%, -50%) scale(2.2);
                opacity: 0;
            }
        }

        /* Flight marker container - matching MQTT branch implementation */
        .flight-marker-container {
            background: transparent !important;
            border: none !important;
            position: relative;
            width: 24px !important;
            height: 24px !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }
        
        .leaflet-div-icon.flight-marker-container {
            background: transparent !important;
            border: none !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        
        /* Ensure Leaflet's automatic positioning works correctly */
        /* Leaflet automatically applies margin-left: -12px and margin-top: -12px based on iconAnchor [12, 12] */
        /* Don't override Leaflet's automatic margins - they're calculated from iconAnchor */

        /* Pulsing ring of light - centered at exact center of 24x24 container */
        .pulsing-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            margin-top: -5px;
            margin-left: -5px;
            width: 10px;
            height: 10px;
            border: 2px solid rgba(220, 20, 60, 0.9);
            border-radius: 50%;
            animation: pulseRing 1s ease-out infinite;
            pointer-events: none;
            transform-origin: center center;
            margin: 0 !important;
        }

        /* Center dot - smaller, perfectly centered at exact center of 24x24 container */
        .marker-center {
            position: absolute;
            top: 50%;
            left: 50%;
            margin-top: -3px;
            margin-left: -3px;
            width: 6px;
            height: 6px;
            background-color: #DC143C;
            border-radius: 50%;
            box-shadow: 0 0 6px rgba(220, 20, 60, 1), 0 0 12px rgba(220, 20, 60, 0.6);
            z-index: 10;
            margin: 0 !important;
        }
        
        /* Drone label container with pointer line */
        .drone-label-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .drone-label-pointer {
            width: 0;
            height: 0;
            border-top: 2px solid transparent;
            border-bottom: 2px solid transparent;
            border-right: 8px solid rgba(220, 20, 60, 0.4);
        }
        
        /* Drone label styling - military operational style */
        .drone-label {
            font-family: 'Courier New', 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            font-weight: bold;
            color: #DC143C;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: rgba(10, 10, 10, 0.85);
            border: 1px solid rgba(220, 20, 60, 0.4);
            padding: 4px 8px;
            white-space: nowrap;
            pointer-events: none;
            text-shadow: 0 0 3px rgba(220, 20, 60, 0.8);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
        }
        
        /* Home Point Marker and Label Styles */
        .home-point-marker {
            background: transparent;
            border: none;
        }
        
        .home-point-circle {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #5a8a6a;
            border: 2px solid #5a8a6a;
            box-shadow: 0 0 5px rgba(90, 138, 106, 0.6);
        }
        
        .drone-location-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            margin-top: -4px;
            margin-left: -4px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff0000;
            border: 1px solid #ff0000;
            box-shadow: 0 0 3px rgba(255, 0, 0, 0.8);
            z-index: 10;
        }
        
        .drone-location-pulse {
            position: absolute;
            top: 50%;
            left: 50%;
            margin-top: -6px;
            margin-left: -6px;
            width: 12px;
            height: 12px;
            border: 2px solid rgba(255, 0, 0, 0.9);
            border-radius: 50%;
            animation: dronePulse 1.5s ease-out infinite;
            pointer-events: none;
            transform-origin: center center;
        }
        
        @keyframes dronePulse {
            0% {
                transform: scale(1);
                opacity: 0.9;
            }
            50% {
                transform: scale(2);
                opacity: 0.3;
            }
            100% {
                transform: scale(2.5);
                opacity: 0;
            }
        }
        
        .home-point-label-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .home-point-label-pointer {
            width: 0;
            height: 0;
            border-top: 2px solid transparent;
            border-bottom: 2px solid transparent;
            border-right: 8px solid rgba(90, 138, 106, 0.4);
        }
        
        .home-point-label {
            font-family: 'Courier New', 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            font-weight: bold;
            color: #5a8a6a;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: rgba(10, 10, 10, 0.85);
            border: 1px solid rgba(90, 138, 106, 0.4);
            padding: 4px 8px;
            white-space: nowrap;
            pointer-events: none;
            text-shadow: 0 0 3px rgba(90, 138, 106, 0.6);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
        }
        
        /* Node label container with pointer line - simple version matching drone label */
        .node-label-container-simple {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Node label container with proximity text - pixel-based positioning */
        .node-label-container-with-proximity {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        
        .node-label-wrapper {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        
        .node-label-row-simple {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Node label container with pointer line - for proximity text version */
        .node-label-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        
        .node-label-row {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }
        
        .node-label-pointer {
            width: 0;
            height: 0;
            border-top: 2px solid transparent;
            border-bottom: 2px solid transparent;
            border-right: 8px solid rgba(74, 155, 157, 0.4);
        }
        
        .node-label-distance {
            font-family: 'Courier New', 'Monaco', 'Menlo', monospace;
            font-size: 11px;
            font-weight: normal;
            color: #a0a0a0;
            text-transform: none;
            letter-spacing: 0.5px;
            padding: 2px 0 0 0;
            margin-left: 16px; /* Align with label text (8px pointer + 8px gap) */
            white-space: nowrap;
            pointer-events: none;
            flex-shrink: 0;
        }

        /* Proximity arrow styling */
        .proximity-arrow {
            display: inline-block;
            margin-left: 5px;
            font-size: 12px;
            color: #ffffff; /* White color for chevrons */
        }
        
        .node-proximity-container {
            display: flex;
            align-items: flex-start;
            padding-left: 16px; /* Align with label text (8px pointer + 8px gap) */
        }
        
        .node-label-pointer-left {
            width: 0;
            height: 0;
            border-top: 2px solid transparent;
            border-bottom: 2px solid transparent;
            border-left: 8px solid rgba(74, 155, 157, 0.4);
        }
        
        /* Node label styling - military operational style with cyan/teal colors */
        .node-label {
            font-family: 'Courier New', 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            font-weight: bold;
            color: #4A9B9D;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: rgba(10, 10, 10, 0.85);
            border: 1px solid rgba(74, 155, 157, 0.4);
            padding: 4px 8px;
            white-space: nowrap;
        }
        
        .node-label-text {
            white-space: nowrap;
        }
        
        .node-label-distance {
            font-family: 'Courier New', 'Monaco', 'Menlo', monospace;
            font-size: 11px;
            font-weight: normal;
            color: #a0a0a0;
            text-transform: none;
            letter-spacing: 0.5px;
            padding: 2px 0 0 0;
            margin-left: 16px; /* Align with label text (8px pointer + 8px gap) */
            white-space: nowrap;
            pointer-events: none;
            flex-shrink: 0;
        }

        /* Remove default Leaflet icon styling */
        .leaflet-div-icon {
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
        }

        /* Toast Notification */
        /* 3D Flight Profile Viewer Modal */
        .flight-profile-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .flight-profile-modal-content {
            background: rgba(10, 10, 10, 0.98);
            border: 2px solid #4a7c59;
            border-radius: 8px;
            padding: 20px;
            width: 95%;
            max-width: 95vw;
            max-height: 95vh;
            height: 95vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.8);
        }
        
        .flight-profile-content-wrapper {
            display: flex;
            flex-direction: row;
            flex: 1;
            gap: 20px;
            overflow: hidden;
        }
        
        .flight-profile-canvas {
            flex: 1;
            min-width: 0;
            position: relative;
            background: #0a0a0a;
            border: 1px solid #4a7c59;
            border-radius: 4px;
        }
        
        
        .flight-profile-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #4a7c59;
        }
        
        .flight-profile-modal-header h3 {
            color: #d4a574;
            font-size: 18px;
            margin: 0;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .flight-profile-modal-header > div {
            flex: 1;
            text-align: center;
            margin-top: 5px;
        }
        
        .flight-profile-ranges {
            display: flex;
            gap: 20px;
            align-items: center;
            font-size: 12px;
            color: #a0a0a0;
            font-family: 'Courier New', monospace;
            margin: 0 20px;
        }
        
        .flight-profile-ranges span {
            white-space: nowrap;
        }
        
        .flight-profile-instructions {
            font-size: 14px;
            color: #888;
            margin-left: auto;
            margin-right: 20px;
        }
        
        .flight-profile-close {
            background: transparent;
            border: 1px solid #4a7c59;
            color: #b0b0b0;
            font-size: 24px;
            width: 32px;
            height: 32px;
            cursor: pointer;
            border-radius: 4px;
        }
        
        /* Mobile optimization for 3D Flight Profile Viewer */
        @media (max-width: 768px) {
            .flight-profile-modal-content {
                width: 98%;
                max-width: 98vw;
                height: 98vh;
                max-height: 98vh;
                padding: 15px;
            }
            
            .flight-profile-content-wrapper {
                flex-direction: column;
                gap: 10px;
            }
            
            .flight-profile-canvas {
                min-height: 60vh;
                flex: 1;
            }
            
            .flight-profile-modal-header {
                flex-wrap: wrap;
                gap: 10px;
            }
            
            .flight-profile-modal-header h3 {
                font-size: 14px;
                letter-spacing: 1px;
            }
            
            .flight-profile-ranges {
                flex-wrap: wrap;
                gap: 10px;
                font-size: 10px;
                margin: 0;
            }
            
            .flight-profile-instructions {
                font-size: 11px;
                margin: 0;
                width: 100%;
                text-align: center;
            }
            
            .flight-profile-close {
                width: 28px;
                height: 28px;
                font-size: 20px;
            }
        }
        
        @media (max-width: 480px) {
            .flight-profile-modal-content {
                width: 100%;
                max-width: 100vw;
                height: 100vh;
                max-height: 100vh;
                padding: 10px;
                border-radius: 0;
            }
            
            .flight-profile-modal-header h3 {
                font-size: 12px;
            }
            
            .flight-profile-ranges {
                font-size: 9px;
                gap: 8px;
            }
            
            .flight-profile-instructions {
                font-size: 10px;
            }
            
            .flight-profile-canvas {
                min-height: 50vh;
            }
        }
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            line-height: 1;
            padding: 0;
        }
        
        .flight-profile-close:hover {
            background: rgba(26, 26, 26, 0.95);
            border-color: #5a8a6a;
            color: #d4a574;
        }
        
        .flight-profile-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
        }
        
        .flight-profile-arrow {
            background: rgba(10, 10, 10, 0.9);
            border: 1px solid #4a7c59;
            color: #b0b0b0;
            padding: 8px 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            min-width: 60px;
        }
        
        .flight-profile-arrow:hover {
            background: rgba(26, 26, 26, 0.95);
            border-color: #5a8a6a;
            color: #d4a574;
        }
        
        /* Duplicate .flight-profile-canvas rule removed - using the one in flight-profile-content-wrapper section */
        
        .toast-container {
            position: fixed;
            top: 70px;
            right: 20px;
            z-index: 10000;
            pointer-events: none;
        }

        .toast {
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid #4A9B9D;
            color: #a0a0a0;
            padding: 12px 18px;
            margin-bottom: 10px;
            border-radius: 4px;
            font-family: 'Courier New', 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transform: translateX(100%);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: auto;
            max-width: 300px;
            word-wrap: break-word;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }

        .toast.hide {
            opacity: 0;
            transform: translateX(100%);
        }
        
        /* Mobile Optimizations - Header rules removed to prevent buttons from dropping */
        @media screen and (max-width: 768px) {
            /* Control Panel - make it full width on mobile, positioned at bottom */
            .flight-log-player {
                position: fixed;
                bottom: 0;
                right: 0;
                left: 0;
                top: auto;
                min-width: 100%;
                max-width: 100%;
                max-height: 60vh;
                border-radius: 0;
                border-left: none;
                border-right: none;
                border-bottom: none;
                padding: 10px;
            }
            
            .flight-log-player h3 {
                font-size: 12px;
                margin-bottom: 10px;
            }
            
            /* Touch-friendly buttons */
            .tactical-button,
            .play-button {
                min-height: 44px;
                font-size: 12px;
                padding: 10px 15px;
                touch-action: manipulation;
            }
            
            /* File upload buttons */
            .file-upload button {
                min-height: 44px;
                font-size: 12px;
            }
            
            /* Toggle switches - larger touch targets */
            .toggle-switch {
                min-width: 50px;
                min-height: 28px;
            }
            
            .toggle-switch::after {
                width: 24px;
                height: 24px;
            }
            
            /* Toggle controls */
            .toggle-control {
                min-height: 44px;
                font-size: 12px;
            }
            
            /* Speed control */
            .speed-control {
                min-height: 44px;
            }
            
            .speed-control input[type="range"] {
                min-height: 44px;
                -webkit-appearance: none;
                appearance: none;
            }
            
            /* Timeline sliders */
            .timeline-container input[type="range"],
            #timelineSlider,
            #acousticTimelineSlider {
                min-height: 44px;
                -webkit-appearance: none;
                appearance: none;
            }
            
            /* Timeline labels */
            .timeline-label {
                font-size: 11px;
            }
            
            /* Info panel adjustments */
            .info-panel {
                bottom: 10px;
                left: 10px;
                right: 10px;
                min-width: auto;
                max-width: calc(100% - 20px);
                padding: 10px;
                font-size: 11px;
            }
            
            /* Legend panel */
            .legend-panel {
                bottom: 10px;
                left: 10px;
                right: 10px;
                min-width: auto;
                max-width: calc(100% - 20px);
                padding: 10px;
                font-size: 10px;
            }
            
            .legend-item {
                margin-bottom: 6px;
                font-size: 10px;
            }
            
            /* Radio group */
            .radio-group {
                flex-direction: column;
                gap: 10px;
            }
            
            .radio-label {
                min-height: 44px;
                font-size: 12px;
            }
            
            /* Flight stats */
            .flight-stats {
                font-size: 11px;
            }
            
            /* Node labels - smaller on mobile */
            .node-label {
                font-size: 10px;
                padding: 3px 6px;
            }
            
            .node-label-distance {
                font-size: 9px;
            }
            
            /* Prevent text selection on touch */
            .tactical-button,
            .play-button,
            .toggle-switch,
            button {
                -webkit-tap-highlight-color: transparent;
                -webkit-touch-callout: none;
                user-select: none;
            }
            
            /* Better scrolling */
            .flight-log-player .panel-content {
                -webkit-overflow-scrolling: touch;
                overflow-y: auto;
            }

            /* Leaflet controls positioning on mobile - account for control panel */
            .leaflet-bottom {
                bottom: 0 !important;
            }

            .leaflet-control-attribution {
                font-size: 8px !important;
                padding: 2px 4px !important;
                line-height: 1.2 !important;
            }

            /* When control panel is at bottom, ensure Leaflet controls don't overlap */
            .flight-log-player:not(.collapsed) ~ .leaflet-bottom,
            .flight-log-player:not(.collapsed) + .leaflet-bottom {
                bottom: 0 !important;
            }
        }

        /* Tablet sizes (iPad, iPad Pro) */
        @media screen and (min-width: 481px) and (max-width: 1366px) {
            /* Ensure Leaflet controls stay tight at bottom */
            .leaflet-bottom {
                bottom: 0 !important;
                z-index: 400 !important;
            }

            .leaflet-control-attribution {
                font-size: 9px !important;
                padding: 3px 6px !important;
                margin: 0 !important;
                max-width: 100% !important;
                white-space: nowrap !important;
                overflow: hidden !important;
                text-overflow: ellipsis !important;
            }

            /* When control panel is visible at bottom, ensure Leaflet controls stay below it */
            .flight-log-player {
                z-index: 1000 !important;
            }

            .leaflet-bottom {
                z-index: 400 !important;
            }

            /* Position Leaflet controls to not overlap with control panel */
            .flight-log-player:not(.collapsed) {
                position: fixed !important;
            }

            /* Ensure attribution text wraps or truncates properly */
            .leaflet-control-attribution {
                word-break: break-word !important;
                hyphens: auto !important;
            }
        }

        /* Large tablets and small desktops (iPad Pro landscape, etc.) */
        @media screen and (min-width: 1024px) and (max-width: 1366px) {
            .leaflet-control-attribution {
                font-size: 10px !important;
                padding: 4px 8px !important;
            }

            /* Ensure controls stay at bottom edge */
            .leaflet-bottom {
                bottom: 0 !important;
            }

            /* Position attribution on left side to avoid control panel on right */
            .leaflet-bottom.leaflet-right {
                right: 0 !important;
            }

            .leaflet-bottom.leaflet-left {
                left: 0 !important;
            }
        }

        /* Ensure Leaflet controls are always visible and properly positioned */
        .leaflet-container .leaflet-control-container {
            position: relative !important;
        }

        /* Fix for control panel overlapping Leaflet controls */
        .flight-log-player {
            position: absolute !important;
        }

        /* When control panel is at bottom, ensure Leaflet controls are still accessible */
        .leaflet-control-attribution {
            position: relative !important;
            display: block !important;
            width: auto !important;
            max-width: 100% !important;
        }

        /* Global fix: Ensure Leaflet bottom controls always stay at bottom edge */
        .leaflet-container .leaflet-bottom {
            bottom: 0 !important;
            margin-bottom: 0 !important;
        }

        /* Ensure attribution text doesn't overflow on any device */
        .leaflet-control-attribution {
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
            hyphens: auto !important;
            line-height: 1.3 !important;
        }

        /* On all screen sizes, keep controls compact and at bottom */
        @media screen and (min-width: 481px) {
            .leaflet-control-attribution {
                font-size: 9px !important;
                padding: 3px 6px !important;
            }
        }
        
        @media screen and (max-width: 480px) {
            /* Extra small screens - Header rules removed to prevent buttons from dropping */
            
            .flight-log-player {
                max-height: 70vh;
                padding: 8px;
            }
            
            .flight-log-player h3 {
                font-size: 11px;
            }
            
            .tactical-button,
            .play-button {
                font-size: 11px;
                padding: 8px 12px;
            }
            
            .toggle-control span {
                font-size: 11px;
            }
        }
        
        /* Prevent zoom on double tap for iOS */
        * {
            touch-action: manipulation;
        }
        
        /* Better touch targets for interactive elements */
        @media (hover: none) and (pointer: coarse) {
            button,
            .toggle-switch,
            input[type="range"],
            select {
                min-height: 44px;
            }
            
            a,
            .leaflet-control a {
                min-height: 44px;
                min-width: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }
        
        /* Mobile responsive styles - progressive hiding and reorganization */
        @media (max-width: 1200px) {
            /* Hide tagline first as window gets smaller */
            .header-center {
                display: none !important;
            }
        }
        
        @media (max-width: 900px) {
            /* Hide subtitle text next */
            .tactical-header h1 span {
                display: none !important;
            }
        }
        
        /* REMOVED: This conflicting media query was causing buttons to drop and north arrow to move */
    </style>
</head>
<body>
    <!-- Toast Notification Container -->
    <div class="toast-container" id="toastContainer"></div>
    
    <!-- Header -->
    <div class="tactical-header">
        <div class="header-left">
            <a href="https://www.eagleeyessearch.com/" class="logo-link" title="Eagle Eyes Search Home">
                <img src="images/eagle-eyes-beta-logo-new.png" alt="Eagle Eyes Logo">
            </a>
            <h1>EDS-B <span style="font-size: 0.6em; font-weight: normal; color: #888;">Eagle Dependent Surveillance-Broadcast</span></h1>
        </div>
        <div class="header-center">
            <span id="taglineText" class="tagline-text"></span>
        </div>
        <div class="map-control-container">
            <span class="download-text">Broadcast your drone's<br>live location for free:</span>
            <button id="downloadBtn" onclick="window.location.href='/download#step3&platform=mobile'">Download<br>Eagle Eyes</button>
            <button id="legendBtn" onclick="toggleLegend()">Legend</button>
            <div id="baseMapControl" style="position: relative; display: inline-block; z-index: 100002;">
                <button id="baseMapBtn" onclick="toggleBaseMapMenu()" title="Base Map Layers">☰</button>
                <div id="baseMapMenu" class="base-map-menu" style="display: none; position: absolute; top: calc(100% + 5px); right: 0; z-index: 999999;">
                    <div class="base-map-option" onclick="handleBaseMapChange('Google Hybrid'); toggleBaseMapMenu();">Google Hybrid</div>
                    <div class="base-map-option" onclick="handleBaseMapChange('Google Imagery'); toggleBaseMapMenu();">Google Imagery</div>
                    <div class="base-map-option" onclick="handleBaseMapChange('Esri Imagery'); toggleBaseMapMenu();">Esri Imagery</div>
                    <div class="base-map-option" onclick="handleBaseMapChange('Esri Topo'); toggleBaseMapMenu();">Esri Topo</div>
                    <div class="base-map-option" onclick="handleBaseMapChange('Dark Theme'); toggleBaseMapMenu();">Dark Theme</div>
                    <div class="base-map-option" onclick="handleBaseMapChange('Light Theme'); toggleBaseMapMenu();">Light Theme</div>
                </div>
            </div>
            <div class="status-indicator">
                <span class="status-text">EDS-B Network:</span>
                <div class="status-dot" id="mqttStatusDot"></div>
                <span class="status-text status-text-right" id="mqttStatusText">DISCONNECTED</span>
            </div>
        </div>
    </div>

    <!-- Map Container -->
    <div id="map"></div>
    
    <!-- Legend Panel -->
    <div class="legend-panel" id="legendPanel">
        <div class="legend-item" data-legend="acoustic-vector" style="display: none;">
            <div class="legend-symbol">
                <div class="legend-line" style="border-color: #0066ff;"></div>
            </div>
            <span>Acoustic estimate vector</span>
        </div>
        <div id="flightLogsLegendContainer" style="display: none;"></div>
        <div class="legend-item" data-legend="home-point-location" style="display: none;">
            <div class="legend-symbol">
                <div class="legend-dot" style="background-color: #5a8a6a; border: 2px solid #5a8a6a;"></div>
            </div>
            <span>Home point location</span>
        </div>
        <div class="legend-item" data-legend="drone-location" style="display: none;">
            <div class="legend-symbol">
                <div class="legend-dot" style="background-color: #ff6b6b; border: 2px solid #ff6b6b;"></div>
            </div>
            <span>Drone location</span>
        </div>
        <div class="legend-item" data-legend="mqtt-drones">
            <div class="legend-symbol">
                <div class="legend-dot legend-dot-pulse" style="background-color: #DC143C; border: 2px solid #DC143C;"></div>
            </div>
            <span>Drone</span>
        </div>
        <div class="legend-item" data-legend="edsb-locations" style="display: none;">
            <div class="legend-symbol">
                <div class="legend-dot" style="background-color: #4A9B9D; border: 2px solid #3A7B7D;"></div>
            </div>
            <span>EDSB locations</span>
        </div>
        <div class="legend-item" data-legend="detection-bubble" style="display: none;">
            <div class="legend-symbol">
                <div class="legend-circle" style="border-color: #4A9B9D; background-color: rgba(74, 155, 157, 0.1);"></div>
            </div>
            <span>Detection bubble</span>
        </div>
        <div class="legend-item" data-legend="mesh-network" style="display: none;">
            <div class="legend-symbol">
                <div class="legend-line" style="border-color: #4A9B9D; opacity: 0.4; border-style: dashed;"></div>
            </div>
            <span>Mesh Network</span>
        </div>
    </div>

    <!-- 3D Flight Profile Viewer Modal -->
    <div id="flightProfileModal" class="flight-profile-modal" style="display: none;">
        <div class="flight-profile-modal-content">
            <div class="flight-profile-modal-header">
                <h3>3D Flight Profile</h3>
                <div id="flightProfileRanges" class="flight-profile-ranges"></div>
                <div class="flight-profile-instructions">Click and drag to rotate view</div>
                <button class="flight-profile-close" onclick="closeFlightProfileViewer()">&times;</button>
            </div>
            <div class="flight-profile-content-wrapper">
                <div id="flightProfileCanvas" class="flight-profile-canvas"></div>
            </div>
        </div>
    </div>

    <!-- Data Source panel removed as requested -->

    <!-- Flight Log Control -->
    <div class="flight-log-player">
        <h3 class="panel-header collapsed" onclick="togglePanel('flightPanel')">View Flight Logs</h3>
        <div class="panel-content collapsed" id="flightPanel">
            <div class="file-upload">
                <input type="file" id="flightLogFile" accept=".txt,.csv,.kml" multiple style="display: none;" onchange="handleFileUpload(event)">
                <input type="file" id="acousticEstimateFile" accept=".json" style="display: none;" onchange="handleAcousticEstimateUpload(event)">
                <div id="importFlightLogButtonContainer" style="display: flex; flex-direction: column; gap: 8px; align-items: center; justify-content: center; margin-bottom: 20px; width: 100%;">
                    <button class="tactical-button" onclick="activateAcousticNode()" style="width: 100%; max-width: 100%;">IMPORT FLIGHT LOGS</button>
                    <button class="tactical-button" onclick="window.location.href='https://www.eagleeyessearch.com/account'" style="width: 100%; max-width: 100%;">Sign in to view flight records</button>
                </div>
            </div>
            <!-- Array Status hidden but kept for functionality -->
            <div class="info-item" style="display: none;">
                <span class="label">Array Status:</span>
                <span class="value" id="arrayStatus">STANDBY</span>
            </div>
            <div class="player-controls" id="flightLogControls" style="display: none;">
                <div style="margin-bottom: 10px;">
                    <label style="font-size: 13px; font-weight: 400; color: #b0b0b0; margin-bottom: 5px; display: block;">
                        <div>Flight Log:</div>
                        <div id="fileName" style="font-weight: 500; color: #a0a0a0; font-size: 11px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-top: 2px;"></div>
                    </label>
                    <button class="play-button" id="playButton" onclick="toggleFlightLogPlayback()" style="margin-right: 5px;">PLAY</button>
                    <button class="tactical-button" onclick="resetFlightLogPlayback()" style="font-size: 10px; padding: 5px 10px;">RESET</button>
                </div>
            </div>
            <div class="speed-control" id="flightLogSpeedControl" style="display: none;">
                <label>Speed:</label>
                <input type="range" id="speedSlider" min="0.1" max="5" step="0.1" value="1" oninput="updateSpeed(this.value)">
                <span class="speed-value" id="speedValue">1.0x</span>
            </div>
            <div class="timeline-container" id="flightLogTimeline" style="display: none;">
                <div class="timeline-label" style="flex-direction: column; align-items: flex-start; gap: 3px;">
                    <span>Flight Log Timeline</span>
                    <span id="timeDisplay" style="font-size: 11px;">0m 0s / 0m 0s</span>
                </div>
                <input type="range" id="timelineSlider" min="0" max="100" value="0" step="0.1" oninput="scrubTimeline(this.value); updateTimelineSliderProgress();" onchange="scrubTimeline(this.value)" style="width: 100%; max-width: 100%;">
            </div>
            <div style="margin-top: 15px; padding-top: 15px; display: none;" id="flightProfileViewerSection">
                <button class="tactical-button" onclick="openFlightProfileViewer()" style="width: 100%; max-width: 100%;">View 3D Flight Profile</button>
            </div>
            <div id="acousticTimelineSection" style="margin-top: 15px; display: none;">
                <div id="acousticPlaybackControls" style="margin-bottom: 10px;">
                    <label style="font-size: 13px; font-weight: 400; color: #b0b0b0; margin-bottom: 5px; display: block;">
                        <div>Acoustic Estimate:</div>
                        <div id="acousticEstimateFileName" style="font-weight: 500; color: #a0a0a0; font-size: 11px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-top: 2px;"></div>
                    </label>
                    <button class="play-button" id="acousticPlayButton" onclick="toggleAcousticPlayback()" style="margin-right: 5px;">PLAY</button>
                    <button class="tactical-button" onclick="resetAcousticPlayback()" style="font-size: 10px; padding: 5px 10px;">RESET</button>
                </div>
                <div class="speed-control" style="margin-bottom: 10px;">
                    <label>Speed:</label>
                    <input type="range" id="acousticSpeedSlider" min="0.1" max="5" step="0.1" value="1" oninput="updateAcousticSpeed(this.value)">
                    <span class="speed-value" id="acousticSpeedValue">1.0x</span>
                </div>
                <div class="timeline-container" id="acousticTimelineContainer">
                    <div class="timeline-label" style="flex-direction: column; align-items: flex-start; gap: 3px;">
                        <span>Acoustic Direction Estimate Timeline</span>
                        <span id="acousticTimeDisplay" style="font-size: 11px;">0m 0s / 0m 0s</span>
                    </div>
                    <input type="range" id="acousticTimelineSlider" min="0" max="100" value="0" step="0.1" oninput="scrubAcousticTimeline(this.value); updateAcousticTimelineSliderProgress();" onchange="scrubAcousticTimeline(this.value)" style="width: 100%; max-width: 100%;">
                </div>
            </div>
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #4a7c59; display: none;" id="dataSourceCheckboxes">
                <div class="radio-group">
                    <label class="radio-label" id="acousticEstimateCheckboxLabel" style="display: none;">
                        <input type="checkbox" id="acousticEstimateCheckbox">
                        <span>Acoustic direction estimate</span>
                    </label>
                </div>
            </div>
            <div class="flight-stats" id="flightLogStats" style="display: none;">
                <div>
                    <span class="label">Flight Log GPS Points:</span>
                    <span class="value" id="flightPoints">0</span>
                </div>
                <div>
                    <span class="label">Flight Log Total Distance:</span>
                    <span class="value" id="flightDistance">--</span>
                </div>
                <div>
                    <span class="label">Flight Log Total Time:</span>
                    <span class="value" id="flightTotalTime">--</span>
                </div>
            </div>
            <div id="flightLogsList" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #4a7c59; display: none;">
                <div style="font-size: 13px; font-weight: 500; color: #b0b0b0; margin-bottom: 5px;">Loaded Flight Logs:</div>
                <div id="flightLogsListContent" style="max-height: 200px; overflow-y: auto;">
                    <!-- Flight log items will be added here -->
                </div>
            </div>
            <div style="margin-top: 15px; padding-top: 15px;">
                <div class="toggle-control" id="toggleControlShowTrack" style="display: none;">
                    <span>Flight Log Track:</span>
                    <div class="toggle-switch active" id="toggleTrack" onclick="toggleTrackVisibility()"></div>
                </div>
                <div class="toggle-control" id="toggleControlShowDrone" style="display: none;">
                    <span>Drone Location:</span>
                    <div class="toggle-switch active" id="toggleDrone" onclick="toggleDroneVisibility()"></div>
                </div>
                <div class="toggle-control" id="toggleControlHomePoint" style="display: none;">
                    <span>Home Point Location:</span>
                    <div class="toggle-switch active" id="toggleHomePoint" onclick="toggleHomePointVisibility()"></div>
                </div>
                <div class="toggle-control" id="toggleControlMeshNetwork" style="display: none;">
                    <span>Mesh Network:</span>
                    <div class="toggle-switch active" id="toggleMesh" onclick="toggleMeshNetwork()"></div>
                </div>
                <div class="toggle-control" id="toggleControlDetectionBubble" style="display: none;">
                    <span>Detection Bubble:</span>
                    <div class="toggle-switch" id="toggleDetectionBubble" onclick="toggleDetectionBubbles()"></div>
                </div>
                <div class="toggle-control" id="toggleControlAcousticEstimateVector" style="padding-left: 10px; display: none;">
                    <span>Acoustic estimate vector:</span>
                    <div class="toggle-switch active" id="toggleAcousticTriangulation" onclick="toggleAcousticTriangulationLine()"></div>
                </div>
                <div class="toggle-control" id="toggleControlAcousticDirectional" style="padding-left: 10px; display: none;">
                    <span>Acoustic estimate directional indicator:</span>
                    <div class="toggle-switch active" id="toggleAcousticDirectional" onclick="toggleAcousticDirectionalIndicator()"></div>
                </div>
                <div class="toggle-control" id="toggleControlDroneLabel" style="display: none;">
                    <span>Drone Label:</span>
                    <div class="toggle-switch active" id="toggleDroneLabel" onclick="toggleDroneLabel()"></div>
                </div>
                <div class="toggle-control" id="toggleControlDroneAltitude" style="display: none;">
                    <span>Drone Altitude Label:</span>
                    <div class="toggle-switch active" id="toggleDroneAltitude" onclick="toggleDroneAltitude()"></div>
                </div>
                <div class="toggle-control" id="toggleControlHomePointLabel" style="display: none;">
                    <span>Home Point Label:</span>
                    <div class="toggle-switch active" id="toggleHomePointLabel" onclick="toggleHomePointLabel()"></div>
                </div>
                <div class="toggle-control" id="toggleControlDistanceFromHome" style="display: none;">
                    <span>Distance from Home Point:</span>
                    <div class="toggle-switch active" id="toggleDistanceFromHome" onclick="toggleDistanceFromHome()"></div>
                </div>
            </div>
        </div>
    </div>


    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Paho MQTT JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js"></script>

    <script>
        // Global map instance
        let map;
        let markers = {}; // Store markers by ID
        let updateInterval = null;
        let dataSourceUrl = '';
        
        // Constants for distance-based fading
        const FADE_START_DISTANCE = 100; // meters - start fading at 100m
        const FADE_END_DISTANCE = 300; // meters - completely hidden beyond 300m
        const MAX_DETECTION_DISTANCE = 300; // meters - max range for triangulation lines
        const DRONE_MARKER_DISTANCE_THRESHOLD = 300; // meters - drone turns gray beyond this distance from any node

        // Flight Log Control
        let flightLogData = []; // Keep for backward compatibility
        let flightLogs = []; // Array of flight log objects: {id, name, data, polyline, visible, color, headers, allData, fileName}
        let flightPath = null; // Keep for backward compatibility
        let flightMarker = null; // Drone location marker
        let homePointMarker = null;
        let homePointLabel = null;
        let showHomePoint = true;
        let showHomePointLabel = true;
        let showDroneAltitude = true;
        let droneLabel = null;
        let droneLabelVisible = true;
        let nodeLabelsVisible = true;
        let showDistanceFromHome = true; // Toggle state for distance from home point in labels
        let previousDistanceFromHome = null; // Track previous distance to determine direction
        let isPlaying = false;
        let currentIndex = 0;
        let playbackSpeed = 1.0;
        let playbackInterval = null;
        
        // Acoustic Estimate Playback Control
        let isAcousticPlaying = false;
        let currentAcousticIndex = 0;
        let acousticPlaybackInterval = null;
        let acousticPlaybackSpeed = 1.0;
        let legendVisible = false;

        // Drone Simulator Control
        let simulatorPollInterval = null;
        let simulatorStarted = false;

        // Node Control
        let detectionNodes = []; // Array to store detection node markers
        let placeNodeMode = false;
        let mapClickHandler = null;
        let flightStartTime = 0;
        let flightEndTime = 0;

        // TDOA Integration
        let edsbData = null;
        let simulationMode = false;
        let currentDirectionWedge = null;
        let nodeDirectionWedges = {}; // Store direction wedges for each node
        
        // Distance tracking for pulse frequency calculation
        let nodeDistanceRanges = {}; // Track min/max distances per node: {nodeId: {min: X, max: Y}}
        
        // Mesh Network
        let meshNetworkLines = []; // Store all mesh network connection lines
        let meshNetworkVisible = true; // Toggle state for mesh network visibility
        
        // Detection Bubbles
        let detectionBubbles = []; // Store all detection coverage bubbles with node references
        let detectionBubblesVisible = false; // Toggle state for detection coverage bubbles
        let bubblePulseAnimationId = null; // Animation frame ID for pulsing bubbles
        
        // Distance tracking for movement direction indicators
        let previousDistances = {}; // Store previous distances: {nodeId: distance}
        
        // MQTT Configuration
        // Note: Android uses ssl://mqtt-telemetry.eagleeyessearch.com (TCP)
        // Web browsers need WebSocket endpoint - try common WebSocket ports/paths
        const MQTT_BROKER_URL = "wss://mqtt-telemetry.eagleeyessearch.com:8084"; // WebSocket URL for MQTT
        const MQTT_TOPIC = "public"; // Topic to subscribe to
        const MQTT_LICENSE_KEY = "letmein"; // License key for authentication
        let mqttClient = null;
        let mqttConnected = false;
        let mqttReconnectTimeout = null;
        let mqttReconnectAttempts = 0;
        const MQTT_MAX_RECONNECT_DELAY = 30000; // Max 30 seconds between reconnect attempts
        let mqttDroneMarkers = {}; // Store MQTT drone markers by drone_id
        let mqttDronePaths = {}; // Store polylines for drone paths
        let mqttDroneData = {}; // Store latest telemetry data for each drone
        let mqttDroneLastUpdate = {}; // Store last update timestamp for each drone
        let mqttDroneTimeouts = {}; // Store timeout IDs for removing stale drones
        
        // Triangulation Lines
        let triangulationLines = []; // Store triangulation lines from nodes to drone
        let triangulationLinesVisible = true; // Toggle state for triangulation lines visibility
        let acousticTriangulationLineVisible = true; // Toggle state for acoustic estimate triangulation line

        // Directional Indicators
        let droneDirectionalIndicatorVisible = true; // Toggle state for actual drone directional indicators
        let acousticDirectionalIndicatorVisible = true; // Toggle state for acoustic estimate directional indicator

        // Acoustic Estimate Data
        let acousticEstimateData = []; // Store acoustic estimate JSON data
        let acousticEstimateDirectionWedge = null; // Direction indicator for acoustic estimate
        let acousticEstimateTriangulationLine = null; // Triangulation line for acoustic estimate

        // Base map layers
        let baseMaps = {};
        let currentBaseLayer = null;
        
        // TDOA Acoustic Array - calculated from drone launch position and relative offset
        // Drone launches at 49.6957757626157, -123.180829738116
        // Array is 4.6m behind (south of) the launch point with bearing 167°
        const DRONE_LAUNCH_LAT = 49.6957757626157;
        const DRONE_LAUNCH_LNG = -123.180829738116;
        const MIC_BEARING = 167.0; // degrees CW from North
        const ARRAY_OFFSET_M = 4.6; // meters behind launch point
        
        // Calculate array center coordinates
        const bearingRad = (MIC_BEARING - 180) * Math.PI / 180; // Opposite direction from bearing
        const latOffset = (ARRAY_OFFSET_M * Math.cos(bearingRad)) / 111000;
        const lngOffset = (ARRAY_OFFSET_M * Math.sin(bearingRad)) / (111000 * Math.cos(DRONE_LAUNCH_LAT * Math.PI / 180));
        
        // Adjust slightly east to better align with flight logs
        const eastAdjustment = 1.5 / (111000 * Math.cos(DRONE_LAUNCH_LAT * Math.PI / 180)); // 1.5 meters east
        
        const ACOUSTIC_ARRAY = {
            id: "acoustic_array_01",
            lat: DRONE_LAUNCH_LAT + latOffset,
            lng: DRONE_LAUNCH_LNG + lngOffset + eastAdjustment,
            name: "Acoustic Array",
            bearing: MIC_BEARING
        };
        
        let acousticNode = null;
        
        // Real TDOA directions from actual stability analysis  
        const TDOA_DIRECTIONS = [
            { "time": 1.0, "azimuth": 167.41573033707868, "elevation": 30.345401581356644, "correlation_peak": 0.05039461933615391, "estimated_snr_db": 5.359932869129219 },
            { "time": 3.0, "azimuth": 167.86516853932585, "elevation": 30.345401581356644, "correlation_peak": 0.05858012588336199, "estimated_snr_db": 4.047456536235982 },
            { "time": 5.0, "azimuth": 169.06367041198502, "elevation": 33.79941739492301, "correlation_peak": 0.05024544222862659, "estimated_snr_db": 6.244482316475322 },
            { "time": 7.0, "azimuth": 167.86516853932585, "elevation": 51.19434040782355, "correlation_peak": 0.041103867336102294, "estimated_snr_db": 6.80981250430876 },
            { "time": 9.0, "azimuth": 162.47191011235952, "elevation": 66.17561381606325, "correlation_peak": 0.04007779885924043, "estimated_snr_db": 5.392592072244752 },
            { "time": 11.0, "azimuth": 183.89513108614233, "elevation": 61.389929255097805, "correlation_peak": 0.035714221007209085, "estimated_snr_db": 2.6649915441530854 },
            { "time": 13.0, "azimuth": 206.21722846441946, "elevation": 76.19398972258459, "correlation_peak": 0.03044673169457993, "estimated_snr_db": 2.64594251115632 },
            { "time": 15.0, "azimuth": 227.49063670411982, "elevation": 47.57386600083229, "correlation_peak": 0.028878368828383544, "estimated_snr_db": 3.5366105680268634 },
            { "time": 17.0, "azimuth": 119.62546816479401, "elevation": 81.88163671814726, "correlation_peak": 0.03131136434184947, "estimated_snr_db": 3.0021830734488937 },
            { "time": 19.0, "azimuth": 226.74157303370785, "elevation": 81.51552132867621, "correlation_peak": 0.02137030904749693, "estimated_snr_db": 4.036456272277016 },
            { "time": 21.0, "azimuth": 13.707865168539325, "elevation": 74.30590039604053, "correlation_peak": 0.014238260206503383, "estimated_snr_db": 3.433397423246278 },
            { "time": 23.0, "azimuth": 87.86516853932584, "elevation": 83.07840854362759, "correlation_peak": 0.012059346284751044, "estimated_snr_db": 2.616599802198269 },
            { "time": 25.0, "azimuth": 80.52434456928839, "elevation": 83.02346785619102, "correlation_peak": 0.011043425476295398, "estimated_snr_db": 2.1257971069662 },
            { "time": 27.0, "azimuth": 75.1310861423221, "elevation": 83.1200231919838, "correlation_peak": 0.014263488858630956, "estimated_snr_db": 2.62281062695861 },
            { "time": 29.0, "azimuth": 8.314606741573034, "elevation": 71.5022888056596, "correlation_peak": 0.02316058709440856, "estimated_snr_db": 4.232619951698313 },
            { "time": 31.0, "azimuth": 76.32958801498128, "elevation": 84.03227239359042, "correlation_peak": 0.031270900753957144, "estimated_snr_db": 1.1240894433447166 },
            { "time": 33.0, "azimuth": 205.91760299625466, "elevation": 80.61215615312321, "correlation_peak": 0.02453670933667541, "estimated_snr_db": 3.6334407436777756 },
            { "time": 35.0, "azimuth": 217.00374531835203, "elevation": 66.8414481897628, "correlation_peak": 0.031693694501137806, "estimated_snr_db": 5.47514202794091 },
            { "time": 37.0, "azimuth": 218.80149812734084, "elevation": 58.06075738660008, "correlation_peak": 0.044664341487051375, "estimated_snr_db": 5.158171957037036 },
            { "time": 39.0, "azimuth": 220.59925093632955, "elevation": 50.3204327923429, "correlation_peak": 0.04260374086165545, "estimated_snr_db": 5.74771016967791 },
            { "time": 41.0, "azimuth": 221.34831460674155, "elevation": 46.32542655014566, "correlation_peak": 0.03916252880944112, "estimated_snr_db": 6.020858262356949 },
            { "time": 43.0, "azimuth": 108.23970037453184, "elevation": 41.581356637536416, "correlation_peak": 0.018810379019049014, "estimated_snr_db": 6.7553181539831355 },
            { "time": 45.0, "azimuth": 97.15355805243443, "elevation": 0.008322929671244816, "correlation_peak": 0.007014433268053709, "estimated_snr_db": 1.8930766766098537 },
            { "time": 47.0, "azimuth": 5.018726591760293, "elevation": 37.71119434040782, "correlation_peak": 0.02124897248231618, "estimated_snr_db": 6.3578630633102176 },
            { "time": 49.0, "azimuth": 352.434456928839, "elevation": 53.35830212234707, "correlation_peak": 0.02686923374263675, "estimated_snr_db": 7.439543704416406 },
            { "time": 51.0, "azimuth": 357.97752808988764, "elevation": 0.008322929671244816, "correlation_peak": 0.022121188688303192, "estimated_snr_db": 6.803186355704969 },
            { "time": 53.0, "azimuth": 97.45318352059924, "elevation": 0.008322929671244816, "correlation_peak": 0.009089930389980162, "estimated_snr_db": 3.2469353508209426 },
            { "time": 55.0, "azimuth": 97.45318352059924, "elevation": 0.008322929671244816, "correlation_peak": 0.006159651848004875, "estimated_snr_db": 3.8474661915163195 },
            { "time": 57.0, "azimuth": 98.95131086142321, "elevation": 0.008322929671244816, "correlation_peak": 0.006478370920318485, "estimated_snr_db": 4.856618303449415 },
            { "time": 59.0, "azimuth": 125.61797752808988, "elevation": 0.008322929671244816, "correlation_peak": 0.005433073690133769, "estimated_snr_db": 2.7309408588401203 },
            { "time": 61.0, "azimuth": 104.34456928838951, "elevation": 0.008322929671244816, "correlation_peak": 0.0062761851415331985, "estimated_snr_db": 4.391553891869646 },
            { "time": 63.0, "azimuth": 147.79026217228463, "elevation": 23.978360382854763, "correlation_peak": 0.006487401636477817, "estimated_snr_db": 2.7648786122980296 },
            { "time": 65.0, "azimuth": 155.5805243445693, "elevation": 42.87141073657927, "correlation_peak": 0.02195034432831741, "estimated_snr_db": 8.634618508548277 },
            { "time": 67.0, "azimuth": 188.08988764044943, "elevation": 58.435289221806066, "correlation_peak": 0.029259890938204282, "estimated_snr_db": 7.994831129024473 },
            { "time": 69.0, "azimuth": 248.31460674157304, "elevation": 55.23096129837703, "correlation_peak": 0.030868749202065643, "estimated_snr_db": 7.047838443271306 },
            { "time": 71.0, "azimuth": 261.7977528089887, "elevation": 54.606741573033716, "correlation_peak": 0.016598455594307712, "estimated_snr_db": 4.9269720951794795 },
            { "time": 73.0, "azimuth": 311.3857677902622, "elevation": 50.40366208905535, "correlation_peak": 0.01687169572286134, "estimated_snr_db": 4.110543789525442 },
            { "time": 75.0, "azimuth": 281.12359550561797, "elevation": 38.002496878901376, "correlation_peak": 0.01847091785474423, "estimated_snr_db": 6.791428014591894 },
            { "time": 77.0, "azimuth": 312.7340823970038, "elevation": 56.43778610070746, "correlation_peak": 0.022596353887320366, "estimated_snr_db": 6.1902179949993705 },
            { "time": 79.0, "azimuth": 329.51310861423224, "elevation": 18.235538909696213, "correlation_peak": 0.01362357660654083, "estimated_snr_db": 3.6763865503739264 },
            { "time": 81.0, "azimuth": 340.8988764044944, "elevation": 0.008322929671244816, "correlation_peak": 0.01825081184278754, "estimated_snr_db": 4.735838471413008 },
            { "time": 83.0, "azimuth": 359.4756554307116, "elevation": 46.824802330420304, "correlation_peak": 0.021236898508319065, "estimated_snr_db": 7.3577043908275455 },
            { "time": 85.0, "azimuth": 8.46441947565543, "elevation": 34.75655430711611, "correlation_peak": 0.01306164960910039, "estimated_snr_db": 5.383769082727427 },
            { "time": 87.0, "azimuth": 323.67041198501875, "elevation": 61.51477320016646, "correlation_peak": 0.00686484389891427, "estimated_snr_db": 1.2455731800017569 },
            { "time": 89.0, "azimuth": 350.33707865168543, "elevation": 49.9042863087807, "correlation_peak": 0.0309226308941834, "estimated_snr_db": 8.449690502668002 },
            { "time": 91.0, "azimuth": 348.2397003745319, "elevation": 0.008322929671244816, "correlation_peak": 0.015327281469449701, "estimated_snr_db": 5.3327397411576865 },
            { "time": 93.0, "azimuth": 328.46441947565546, "elevation": 0.008322929671244816, "correlation_peak": 0.015859771050684007, "estimated_snr_db": 5.966276793348657 },
            { "time": 95.0, "azimuth": 341.498127340824, "elevation": 62.596754057428214, "correlation_peak": 0.009098159796207596, "estimated_snr_db": 4.575302929553102 },
            { "time": 97.0, "azimuth": 318.57677902621725, "elevation": 28.014981273408246, "correlation_peak": 0.01463726302584588, "estimated_snr_db": 4.656393913167151 },
            { "time": 99.0, "azimuth": 349.58801498127343, "elevation": 0.008322929671244816, "correlation_peak": 0.010681187386492477, "estimated_snr_db": 4.116354596613668 }
        ];

        // Initialize map
        function initMap() {            
            // Create map centered on a default location (can be changed)
            map = L.map('map', {
                center: [49.3, -123.2], // Southern Vancouver Island and Lower Mainland
                zoom: 8,
                zoomControl: false, // Remove zoom controls
                attributionControl: true,
                maxZoom: 25 // Allow deeper zoom
            });

            // Google Hybrid Imagery (satellite + labels) - Default
            const googleHybrid = L.tileLayer('https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
                attribution: '&copy; Google',
                maxZoom: 25,
                maxNativeZoom: 20
            });

            // Google Imagery (satellite only, no labels)
            const googleImagery = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                attribution: '&copy; Google',
                maxZoom: 25,
                maxNativeZoom: 20
            });

            // CartoDB Dark Matter (dark theme)
            const cartoDark = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 25
            });

            // CartoDB Positron (light theme)
            const cartoLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 25
            });

            // Esri World Imagery (military/operational style)
            const esriImagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '&copy; Esri',
                maxZoom: 25,
                maxNativeZoom: 19
            });

            // Esri World Topo (military topo style)
            const esriTopo = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
                attribution: '&copy; Esri',
                maxZoom: 25,
                maxNativeZoom: 19
            });

            // Set up base maps object
            baseMaps = {
                "Dark Theme": cartoDark,
                "Google Hybrid": googleHybrid,
                "Google Imagery": googleImagery,
                "Esri Imagery": esriImagery,
                "Esri Topo": esriTopo,
                "Light Theme": cartoLight
            };

            // Add default layer (Dark Theme)
            cartoDark.addTo(map);
            currentBaseLayer = cartoDark;

            // Close base map menu when clicking outside
            document.addEventListener('click', function(event) {
                const baseMapBtn = document.getElementById('baseMapBtn');
                const baseMapMenu = document.getElementById('baseMapMenu');
                if (baseMapMenu && baseMapBtn && !baseMapBtn.contains(event.target) && !baseMapMenu.contains(event.target)) {
                    baseMapMenu.style.display = 'none';
                }
            });
            
            // Add Scale Bar (bottom left)
            const ScaleBarControl = L.Control.extend({
                onAdd: function(map) {
                    const container = L.DomUtil.create('div', 'scale-bar-control');
                    container.innerHTML = '<div class="scale-bar-content"><div class="scale-bar-line"></div><div class="scale-bar-text">0 km</div></div>';
                    L.DomEvent.disableClickPropagation(container);
                    // Store reference to this container for updates
                    this._container = container;
                    this.updateScale(map);
                    map.on('zoomend moveend', () => this.updateScale(map));
                    return container;
                },
                updateScale: function(map) {
                    const bounds = map.getBounds();
                    const center = bounds.getCenter();
                    const ne = bounds.getNorthEast();
                    const sw = bounds.getSouthWest();
                    const latDist = center.distanceTo([ne.lat, center.lng]);
                    const lngDist = center.distanceTo([center.lat, ne.lng]);
                    const maxDist = Math.max(latDist, lngDist);
                    
                    // Calculate appropriate scale
                    const containerWidth = 120; // pixels
                    const metersPerPixel = maxDist / (containerWidth / 2);
                    const scaleMeters = metersPerPixel * containerWidth;
                    
                    // Round to nice values
                    let displayValue, displayUnit;
                    if (scaleMeters >= 1000) {
                        displayValue = Math.round(scaleMeters / 1000);
                        displayUnit = 'km';
                    } else {
                        displayValue = Math.round(scaleMeters / 100) * 100;
                        displayUnit = 'm';
                    }
                    
                    // Use the stored container reference instead of querySelector
                    const scaleBar = this._container ? this._container.querySelector('.scale-bar-content') : null;
                    if (scaleBar) {
                        scaleBar.innerHTML = `<div class="scale-bar-line"></div><div class="scale-bar-text">${displayValue} ${displayUnit}</div>`;
                    }
                }
            });
            const scaleBarInstance = new ScaleBarControl({ position: 'bottomleft' });
            scaleBarInstance.addTo(map);
            console.log('Scale bar control added to map:', scaleBarInstance);
            
            // Add North Arrow (top left) - using image file with white N label
            const NorthArrowControl = L.Control.extend({
                onAdd: function(map) {
                    const container = L.DomUtil.create('div', 'north-arrow-control');
                    container.innerHTML = '<div class="north-arrow-content"><span class="north-arrow-label">N</span><img src="images/north-arrow-green.png" alt="North" class="north-arrow-image"></div>';
                    L.DomEvent.disableClickPropagation(container);
                    return container;
                }
            });
            new NorthArrowControl({ position: 'topleft' }).addTo(map);

            console.log('EDSB Map initialized');
            
            // Mobile: Close flight log panel when clicking on map
            function isMobileView() {
                return window.innerWidth <= 768;
            }
            
            // Add click handler to close flight log panel in mobile view
            map.on('click', function(e) {
                // Only in mobile view
                if (!isMobileView()) return;
                
                // Don't close if clicking on the flight log panel itself
                const flightLogPlayer = document.querySelector('.flight-log-player');
                const clickTarget = e.originalEvent ? e.originalEvent.target : (window.event ? window.event.target : null);
                if (flightLogPlayer && clickTarget && flightLogPlayer.contains(clickTarget)) {
                    return;
                }
                
                // Check if flight panel is open (not collapsed)
                const flightPanel = document.getElementById('flightPanel');
                const flightPanelHeader = document.querySelector('.flight-log-player .panel-header');
                
                if (flightPanel && flightPanelHeader && !flightPanel.classList.contains('collapsed')) {
                    // Close the panel
                    togglePanel('flightPanel');
                }
            });
            
            // Create permanent acoustic sensor node
            // createAcousticSensorNode(); // Disabled - EDSB Sensor 1 removed
            
            // Zoom to acoustic array location
            // map.setView([ACOUSTIC_ARRAY.lat, ACOUSTIC_ARRAY.lng], 16); // Don't zoom to sensor location if sensor is removed
            
            // Check for TDOA data from sessionStorage after map is initialized
            checkForTdoaData();
        }
        
        function createAcousticSensorNode() {
            // Create acoustic sensor icon with pulsing ring
            const icon = L.divIcon({
                className: 'acoustic-sensor-marker',
                html: `<div class="acoustic-node-marker"></div>`,
                iconSize: [12, 12],
                iconAnchor: [6, 6]
            });

            acousticNode = L.marker([ACOUSTIC_ARRAY.lat, ACOUSTIC_ARRAY.lng], { icon: icon })
                .addTo(map);
            
            // Initial popup will be set by updateNodePopupsWithDistance
            updateNodePopupsWithDistance();
            
            // Store label properties with acoustic node
            acousticNode.label = null;
            acousticNode.labelPointerLine = null;
            
            // Create label for acoustic array if labels are visible
            if (nodeLabelsVisible) {
                updateAcousticNodeLabel();
            }
            
            // Update mesh network when acoustic node is created
            updateMeshNetwork();
            
            // Update detection bubbles
            updateDetectionBubbles();
            
            // Update toggle visibility
            updateToggleVisibility();
        }
        
        function checkForTdoaData() {
            const storedData = sessionStorage.getItem('edsbData');
            console.log('Checking for TDOA data...');
            console.log('Session storage data exists:', !!storedData);
            
            if (storedData) {
                try {
                    edsbData = JSON.parse(storedData);
                    console.log('Successfully loaded TDOA data from session storage:', edsbData);
                    console.log('Flight data points:', edsbData.flightData ? edsbData.flightData.positions.length : 'No flight data');
                    console.log('TDOA data points:', edsbData.tdoaData ? edsbData.tdoaData.chunk_times.length : 'No TDOA data');
                    
                    // Load flight data from TDOA analysis
                    loadTdoaFlightData();
                    // Clear the session storage after loading
                    sessionStorage.removeItem('edsbData');
                } catch (error) {
                    console.error('Error parsing TDOA data:', error);
                }
            } else {
                console.log('No TDOA data found in session storage');
            }
        }

        function loadTdoaFlightData() {
            console.log('loadTdoaFlightData called');
            console.log('edsbData exists:', !!edsbData);
            console.log('edsbData.flightData exists:', !!(edsbData && edsbData.flightData));
            
            if (!edsbData || !edsbData.flightData) {
                console.log('No flight data available from TDOA');
                return;
            }

            const flight = edsbData.flightData;
            console.log('Flight data structure:', flight);
            console.log('Timestamps length:', flight.timestamps ? flight.timestamps.length : 'No timestamps');
            console.log('Positions length:', flight.positions ? flight.positions.length : 'No positions');
            console.log('First few positions:', flight.positions ? flight.positions.slice(0, 3) : 'No positions');
            
            flightLogData = [];

            // Convert TDOA flight data to our format
            // TDOA uses [x, y, z] format where x=East, y=North, z=Up
            // We need to convert to lat/lng
            for (let i = 0; i < flight.timestamps.length; i++) {
                const x = flight.positions[i][0]; // East (meters from array center)
                const y = flight.positions[i][1]; // North (meters from array center) 
                const z = flight.positions[i][2] || 0; // Up (meters)
                
                // Convert from local ENU coordinates to lat/lng
                // Array center is our reference point
                const lat = ACOUSTIC_ARRAY.lat + (y / 111000); // ~111km per degree latitude
                const lng = ACOUSTIC_ARRAY.lng + (x / (111000 * Math.cos(ACOUSTIC_ARRAY.lat * Math.PI / 180))); // Longitude varies by latitude
                
                const point = {
                    lat: lat,
                    lng: lng,
                    altitude: z,
                    time: flight.timestamps[i],
                    index: i
                };
                flightLogData.push(point);
            }
            
            console.log('Converted flight log data points:', flightLogData.length);
            console.log('First few converted points:', flightLogData.slice(0, 3));

            if (flightLogData.length > 0) {
                flightStartTime = flightLogData[0].time;
                flightEndTime = flightLogData[flightLogData.length - 1].time;
                const duration = flightEndTime - flightStartTime;

                // Update UI
                document.getElementById('flightPoints').textContent = flightLogData.length;
                
                // Calculate total distance
                let totalDistance = 0;
                for (let i = 1; i < flightLogData.length; i++) {
                    totalDistance += calculateDistance(
                        flightLogData[i-1].lat, flightLogData[i-1].lng,
                        flightLogData[i].lat, flightLogData[i].lng
                    );
                }
                document.getElementById('flightDistance').textContent = totalDistance.toFixed(2) + ' km';
                
                // Calculate and display total time in minutes:seconds format
                const totalTimeSeconds = duration / 1000; // Convert milliseconds to seconds
                const minutes = Math.floor(totalTimeSeconds / 60);
                const seconds = Math.floor(totalTimeSeconds % 60);
                document.getElementById('flightTotalTime').textContent = `${minutes}m ${seconds}s`;

                // Draw flight path
                drawFlightPath();

                // Initialize timeline
                document.getElementById('timelineSlider').max = flightLogData.length - 1;
                const timelineSlider = document.getElementById('timelineSlider');
                if (timelineSlider) {
                    timelineSlider.max = flightLogData.length - 1;
                    timelineSlider.value = 0;
                    // Small delay to ensure slider is rendered before updating style
                    setTimeout(() => updateTimelineSliderProgress(), 10);
                }

                // Zoom to acoustic array location (EDSB sensor) - zoom way in
                if (map) {
                    setTimeout(() => {
                        console.log('Zooming to EDSB sensor location:', ACOUSTIC_ARRAY.lat, ACOUSTIC_ARRAY.lng, 'at zoom level 20');
                        map.setView([ACOUSTIC_ARRAY.lat, ACOUSTIC_ARRAY.lng], 20, { animate: false });
                        // Force a second zoom to ensure it takes effect
                        setTimeout(() => {
                            map.setView([ACOUSTIC_ARRAY.lat, ACOUSTIC_ARRAY.lng], 20, { animate: false });
                        }, 50);
                    }, 200);
                }
                
                // Update toggle visibility based on loaded data
                updateToggleVisibility();
                
                // Update download button pulse
                updateDownloadButtonPulse();
                
                // Activate node
                const arrayStatusEl = document.getElementById('arrayStatus');
                if (arrayStatusEl) arrayStatusEl.textContent = 'ACTIVE';
                updateNodePopupsWithDistance();

                // Initialize marker at start position
                updateFlightPosition(0);

                console.log(`Loaded ${flightLogData.length} flight points from TDOA analysis`);
                document.getElementById('fileName').textContent = `${edsbData.testCaseName} - TDOA Data`;

                // Enable simulation mode
                simulationMode = true;
                
                // Update button to show "Activate Simulation"
                const uploadLabel = document.querySelector('.file-upload-label');
                if (uploadLabel) {
                    uploadLabel.textContent = 'ACTIVATE SIMULATION';
                    uploadLabel.style.background = '#FF6B35';
                    uploadLabel.style.borderColor = '#FF6B35';
                    uploadLabel.style.color = '#ffffff';
                }
                
                // Update file input to handle simulation activation and show toast
                const fileInput = document.getElementById('flightLogFile');
                const fileLabel = document.querySelector('label[for="flightLogFile"]');
                
                if (fileInput) {
                    fileInput.addEventListener('click', function(e) {
                        if (simulationMode && edsbData) {
                            e.preventDefault();
                            activateSimulation();
                        } else {
                            // Show toast when file input is clicked
                            showToast('Please select a flight log file to load');
                        }
                    });
                }
                
                if (fileLabel) {
                    fileLabel.addEventListener('click', function(e) {
                        // Show toast when label is clicked (before file dialog opens)
                        setTimeout(() => {
                            showToast('Please select a flight log file to load');
                        }, 100);
                    });
                }
            }
        }

        function activateAcousticNode() {
            console.log('Activating acoustic node...');
            const arrayStatusEl = document.getElementById('arrayStatus');
            if (arrayStatusEl) arrayStatusEl.textContent = 'ACTIVE';
            
            // Update popup with new status
            updateNodePopupsWithDistance();
            
            // Don't zoom here - wait for flight log to load, then zoom to drone location
            
            // Trigger file picker to load flight log
            const fileInput = document.getElementById('flightLogFile');
            if (fileInput) {
                fileInput.click();
            }
        }

        function loadAcousticEstimate() {
            console.log('Loading acoustic estimate...');
            showToast('Choose a JSON file with audio information');
            
            // Trigger file picker for JSON files
            const fileInput = document.getElementById('acousticEstimateFile');
            if (fileInput) {
                fileInput.click();
            }
        }

        function handleAcousticEstimateUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.name.toLowerCase().endsWith('.json')) {
                showToast('Please select a JSON file');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const jsonData = JSON.parse(e.target.result);
                    acousticEstimateData = jsonData;
                    
                    // Display file name
                    const fileNameEl = document.getElementById('acousticEstimateFileName');
                    if (fileNameEl) {
                        fileNameEl.textContent = file.name;
                    }
                    
                    // Set checkbox to acoustic estimate
                    const acousticCheckbox = document.getElementById('acousticEstimateCheckbox');
                    if (acousticCheckbox) {
                        acousticCheckbox.checked = true;
                    }
                    
                    // Process and display acoustic estimate data
                    processAcousticEstimateData();
                    
                    // Show acoustic timeline section (includes playback controls and timeline)
                    const acousticTimelineSection = document.getElementById('acousticTimelineSection');
                    if (acousticTimelineSection) {
                        acousticTimelineSection.style.display = 'block';
                    }
                    
                    // Initialize acoustic timeline slider
                    const acousticTimelineSlider = document.getElementById('acousticTimelineSlider');
                    if (acousticTimelineSlider && acousticEstimateData.length > 0) {
                        // Set max to the last index (not time value)
                        acousticTimelineSlider.max = acousticEstimateData.length - 1;
                        acousticTimelineSlider.min = 0;
                        acousticTimelineSlider.value = 0;
                        acousticTimelineSlider.step = 1;
                        updateAcousticTimelineSliderProgress();
                        console.log(`Acoustic timeline initialized: max=${acousticTimelineSlider.max}, dataLength=${acousticEstimateData.length}`);
                        updateAcousticTimeDisplay(0);
                        currentAcousticIndex = 0;
                    }
                    
                    showToast('Acoustic estimate data loaded successfully');
                    
                    // Update toggle visibility based on loaded data
                    updateToggleVisibility();
                    
            // Update download button pulse
            updateDownloadButtonPulse();
            
            // Update legend visibility if legend is open
            if (legendVisible) {
                updateLegendVisibility();
            }
        } catch (error) {
                    console.error('Error parsing JSON file:', error);
                    showToast('Error parsing JSON file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function processAcousticEstimateData() {
            if (!acousticEstimateData || acousticEstimateData.length === 0) {
                console.log('No acoustic estimate data to process');
                return;
            }

            // Clear existing acoustic estimate visuals
            if (acousticEstimateDirectionWedge) {
                map.removeLayer(acousticEstimateDirectionWedge);
                acousticEstimateDirectionWedge = null;
            }
            if (acousticEstimateTriangulationLine) {
                map.removeLayer(acousticEstimateTriangulationLine);
                acousticEstimateTriangulationLine = null;
            }

            // Update display with first data point if available
            if (acousticEstimateData.length > 0) {
                updateAcousticEstimateDisplay(0);
            }
        }

        function updateAcousticEstimateDisplay(index) {
            if (!acousticEstimateData || acousticEstimateData.length === 0) return;
            if (index < 0 || index >= acousticEstimateData.length) return;

            const timePoint = acousticEstimateData[index];
            if (!timePoint.detections || timePoint.detections.length === 0) return;
            
            // Use the first detection (can be extended to handle multiple detections)
            const detection = timePoint.detections[0];
            if (!detection.azimuth) return;
            
            const estimate = {
                azimuth: detection.azimuth,
                time: timePoint.time
            };

            // Convert azimuth to a point at fixed horizontal distance (100m) from acoustic array
            // Only use azimuth, ignore elevation - project horizontally
            // Azimuth convention: 0° = North, 90° = East, 180° = South, 270° = West (CW from True North)
            const fixedDistance = 100; // meters
            const azimuthRad = (estimate.azimuth * Math.PI) / 180;

            // Calculate lat/lng offset from acoustic array (horizontal projection only)
            // For geographic azimuth (CW from North): lat = cos(azimuth), lng = sin(azimuth)
            // This gives: 0° (North) → +lat, 90° (East) → +lng, 180° (South) → -lat, 270° (West) → -lng
            const latOffset = (fixedDistance * Math.cos(azimuthRad)) / 111000;
            const lngOffset = (fixedDistance * Math.sin(azimuthRad)) / (111000 * Math.cos(ACOUSTIC_ARRAY.lat * Math.PI / 180));

            const estimatedLat = ACOUSTIC_ARRAY.lat + latOffset;
            const estimatedLng = ACOUSTIC_ARRAY.lng + lngOffset;

            // Update direction indicator (only for main acoustic array, not additional nodes)
            if (acousticNode && acousticDirectionalIndicatorVisible) {
                // Remove previous direction wedge
                if (acousticEstimateDirectionWedge) {
                    map.removeLayer(acousticEstimateDirectionWedge);
                    acousticEstimateDirectionWedge = null;
                }

                // Create new direction wedge for acoustic estimate (blue color)
                const newWedge = createDirectionWedgeForAcousticEstimate(
                    ACOUSTIC_ARRAY.lat,
                    ACOUSTIC_ARRAY.lng,
                    { lat: estimatedLat, lng: estimatedLng }
                );
                if (newWedge) {
                    acousticEstimateDirectionWedge = newWedge;
                }
            } else if (!acousticDirectionalIndicatorVisible && acousticEstimateDirectionWedge) {
                // Hide if toggle is off
                map.removeLayer(acousticEstimateDirectionWedge);
                acousticEstimateDirectionWedge = null;
            }

            // Update triangulation line (only for main acoustic array)
            if (acousticEstimateTriangulationLine) {
                map.removeLayer(acousticEstimateTriangulationLine);
            }

            if (acousticTriangulationLineVisible) {
                const distance = calculateHorizontalDistance(ACOUSTIC_ARRAY.lat, ACOUSTIC_ARRAY.lng, estimatedLat, estimatedLng);
                if (distance <= MAX_DETECTION_DISTANCE) {
                    // Extend line past estimated point
                    const extensionFactor = 1.5;
                    const extendedDistance = distance * extensionFactor;
                    const bearingRad = Math.atan2(
                        (estimatedLng - ACOUSTIC_ARRAY.lng) * Math.cos(ACOUSTIC_ARRAY.lat * Math.PI / 180),
                        estimatedLat - ACOUSTIC_ARRAY.lat
                    );
                    const extendedDeltaLat = (extendedDistance * Math.cos(bearingRad)) / 111000;
                    const extendedDeltaLng = (extendedDistance * Math.sin(bearingRad)) / (111000 * Math.cos(ACOUSTIC_ARRAY.lat * Math.PI / 180));
                    const extendedLat = ACOUSTIC_ARRAY.lat + extendedDeltaLat;
                    const extendedLng = ACOUSTIC_ARRAY.lng + extendedDeltaLng;

                    acousticEstimateTriangulationLine = L.polyline(
                        [[ACOUSTIC_ARRAY.lat, ACOUSTIC_ARRAY.lng], [estimatedLat, estimatedLng], [extendedLat, extendedLng]],
                        {
                            color: '#0066ff', // Blue color for acoustic estimate
                            weight: 4,
                            opacity: 0.8,
                            dashArray: '8, 4',
                            className: 'acoustic-estimate-triangulation-line'
                        }
                    );
                    acousticEstimateTriangulationLine.addTo(map);
                }
            }
        }

        function createDirectionWedgeForAcousticEstimate(nodeLat, nodeLng, estimatedPosition) {
            const estimatedLat = estimatedPosition.lat;
            const estimatedLng = estimatedPosition.lng;
            
            // Calculate bearing from node to estimated position
            const deltaLat = estimatedLat - nodeLat;
            const deltaLng = estimatedLng - nodeLng;
            
            let bearingRad = Math.atan2(deltaLng * Math.cos(nodeLat * Math.PI / 180), deltaLat);
            let bearingDeg = bearingRad * 180 / Math.PI;
            bearingDeg = (bearingDeg + 360) % 360;
            
            const distance = calculateHorizontalDistance(nodeLat, nodeLng, estimatedLat, estimatedLng);
            
            // Apply distance-based fading
            let distanceFadeFactor = 1.0;
            if (distance > FADE_START_DISTANCE) {
                if (distance >= FADE_END_DISTANCE) {
                    return null;
                }
                distanceFadeFactor = 1.0 - ((distance - FADE_START_DISTANCE) / (FADE_END_DISTANCE - FADE_START_DISTANCE));
            }
            
            // Create wedge with blue color for acoustic estimate
            const wedgeAngle = 30; // degrees
            const wedgeLength = Math.min(50, distance * 0.3); // meters
            
            const halfAngle = wedgeAngle / 2;
            const startBearing = (bearingDeg - halfAngle + 360) % 360;
            const endBearing = (bearingDeg + halfAngle) % 360;
            
            const startBearingRad = startBearing * Math.PI / 180;
            const endBearingRad = endBearing * Math.PI / 180;
            
            const startLat = nodeLat + (wedgeLength * Math.cos(startBearingRad)) / 111000;
            const startLng = nodeLng + (wedgeLength * Math.sin(startBearingRad)) / (111000 * Math.cos(nodeLat * Math.PI / 180));
            
            const endLat = nodeLat + (wedgeLength * Math.cos(endBearingRad)) / 111000;
            const endLng = nodeLng + (wedgeLength * Math.sin(endBearingRad)) / (111000 * Math.cos(nodeLat * Math.PI / 180));
            
            const wedge = L.polygon([
                [nodeLat, nodeLng],
                [startLat, startLng],
                [endLat, endLng]
            ], {
                color: 'transparent', // No border
                weight: 0,
                fillColor: '#0066ff',
                fillOpacity: 0.3 * distanceFadeFactor,
                className: 'acoustic-estimate-direction-wedge'
            });
            
            wedge.addTo(map);
            return wedge;
        }
        
        function loadM350FlightData() {
            // Load the M350 mapping flight CSV
            const csvPath = '/Users/patrickrobinson/Downloads/m350_mapping_flight/Dec-9th-2025-09-00AM-Flight-Airdata.csv';
            
            fetch('file://' + csvPath)
                .then(response => response.text())
                .then(text => {
                    parseDJIFlightLog(text);
                    document.getElementById('fileName').textContent = 'Dec-9th-2025-09-00AM-Flight-Airdata.csv';
                })
                .catch(error => {
                    console.error('Error loading M350 flight data:', error);
                    // Try alternative approach using FileReader if direct file access fails
                    loadM350FlightDataAlternative();
                });
        }
        
        function loadM350FlightDataAlternative() {
            // Since we can't directly access local files from browser, simulate the data load
            // In a real implementation, this would be loaded from a server or user file selection
            console.log('Note: Direct file access blocked. Please use the file selector to load the M350 flight CSV.');
            
            // Show toast notification and open file selector
            showToast('Please select a flight log file to load');
            const fileInput = document.getElementById('flightLogFile');
            if (fileInput) {
                fileInput.click();
            }
        }
        
        function deactivateAcousticNode() {
            console.log('Deactivating acoustic node...');
            document.getElementById('arrayStatus').textContent = 'STANDBY';
            
            // Update popup with new status
            updateNodePopupsWithDistance();
            
            // Helper function to stop wedge animation
            function stopWedgeAnimation(wedge) {
                if (wedge && wedge._pulseAnimationId) {
                    cancelAnimationFrame(wedge._pulseAnimationId);
                    wedge._pulseAnimationId = null;
                }
            }
            
            // Clear main direction wedge
            if (currentDirectionWedge) {
                stopWedgeAnimation(currentDirectionWedge);
                map.removeLayer(currentDirectionWedge);
                currentDirectionWedge = null;
            }
            
            // Clear all detection node direction wedges
            detectionNodes.forEach(node => {
                if (node.directionWedge) {
                    stopWedgeAnimation(node.directionWedge);
                    map.removeLayer(node.directionWedge);
                    node.directionWedge = null;
                }
            });
            Object.keys(nodeDirectionWedges).forEach(nodeId => {
                if (nodeDirectionWedges[nodeId]) {
                    stopWedgeAnimation(nodeDirectionWedges[nodeId]);
                    map.removeLayer(nodeDirectionWedges[nodeId]);
                }
            });
            nodeDirectionWedges = {};
        }

        function createDirectionWedgeForNode(nodeLat, nodeLng, dronePosition, nodeId) {
            const droneLat = dronePosition.lat || dronePosition[0];
            const droneLng = dronePosition.lng || dronePosition[1];
            
            // Calculate bearing from node to drone
            const deltaLat = droneLat - nodeLat;
            const deltaLng = droneLng - nodeLng;
            
            // Correct bearing calculation
            let bearingRad = Math.atan2(deltaLng * Math.cos(nodeLat * Math.PI / 180), deltaLat);
            let bearingDeg = bearingRad * 180 / Math.PI;
            
            // Normalize to 0-360 degrees
            bearingDeg = (bearingDeg + 360) % 360;
            
            // Calculate distance to drone using Haversine formula for accuracy
            const distance = calculateHorizontalDistance(nodeLat, nodeLng, droneLat, droneLng);
            
            // Apply distance-based fading: fade out between 100m and 200m, disappear beyond 200m
            let distanceFadeFactor = 1.0;
            if (distance > FADE_START_DISTANCE) {
                if (distance >= FADE_END_DISTANCE) {
                    return null; // Hide completely beyond 200m
                }
                // Linear fade between FADE_START_DISTANCE and FADE_END_DISTANCE
                distanceFadeFactor = 1.0 - ((distance - FADE_START_DISTANCE) / (FADE_END_DISTANCE - FADE_START_DISTANCE));
            }
            
            // Update distance range tracking for this node
            if (!nodeDistanceRanges[nodeId]) {
                nodeDistanceRanges[nodeId] = { min: distance, max: distance };
            } else {
                nodeDistanceRanges[nodeId].min = Math.min(nodeDistanceRanges[nodeId].min, distance);
                nodeDistanceRanges[nodeId].max = Math.max(nodeDistanceRanges[nodeId].max, distance);
            }
            
            // Get the distance range for this node (use actual range or fallback to defaults)
            const range = nodeDistanceRanges[nodeId];
            const minDistance = Math.max(5, range.min * 0.9); // Slight buffer below min
            const maxDistance = range.max * 1.1; // Slight buffer above max
            
            // Calculate proximity ratio based on actual distance range
            const normalizedDistance = Math.max(minDistance, Math.min(distance, maxDistance));
            const proximityRatio = 1 - ((normalizedDistance - minDistance) / (maxDistance - minDistance)); // 1 = close, 0 = far
            
            // Fill opacity: darker overall, varies from 0.4 (far) to 0.85 (close), then faded by distanceFadeFactor
            const baseFillIntensity = 0.4 + (proximityRatio * 0.45);
            const fillIntensity = baseFillIntensity * distanceFadeFactor;
            
            // Pulse characteristics based on proximity (radar ping effect)
            // Pulse frequency: evenly distributed across the full distance range
            // Closer = faster pulse (shorter duration), further = slower pulse (longer duration)
            // Use a range from 0.5s (very close) to 3.0s (very far) for even distribution
            const minPulseDuration = 0.5; // seconds - fastest pulse when very close
            const maxPulseDuration = 3.0; // seconds - slowest pulse when very far
            const pulseDuration = maxPulseDuration - (proximityRatio * (maxPulseDuration - minPulseDuration));
            
            const pulseMaxOpacity = (0.7 + (proximityRatio * 0.2)) * distanceFadeFactor; // 0.7 (far) to 0.9 (close) - darker when close, faded by distance
            const pulseMinOpacity = (0.4 + (proximityRatio * 0.25)) * distanceFadeFactor; // 0.4 (far) to 0.65 (close) - darker minimum when close, faded by distance
            
            // Create radar-style wedge pointing toward drone
            // Base wedge length varies with proximity for visual emphasis
            const baseWedgeLength = Math.min(30, distance * 0.5); // meters - shorter max length
            const wedgeLength = baseWedgeLength * (1.0 + proximityRatio * 0.2); // Slightly longer when close
            const wedgeAngle = 15; // degrees - wedge spread angle
            
            // Convert bearing to radians
            bearingRad = bearingDeg * Math.PI / 180;
            const angleRad = wedgeAngle * Math.PI / 180;
            
            // Calculate wedge points - MUST originate exactly from node center
            const points = [];
            const nodeCenter = [nodeLat, nodeLng];
            
            // Start at exact node center
            points.push(nodeCenter);
            
            // Calculate left edge of wedge
            const leftBearing = bearingRad - angleRad;
            const leftDeltaLat = (wedgeLength * Math.cos(leftBearing)) / 111000;
            const leftDeltaLng = (wedgeLength * Math.sin(leftBearing)) / (111000 * Math.cos(nodeLat * Math.PI / 180));
            points.push([nodeCenter[0] + leftDeltaLat, nodeCenter[1] + leftDeltaLng]);
            
            // Calculate right edge of wedge
            const rightBearing = bearingRad + angleRad;
            const rightDeltaLat = (wedgeLength * Math.cos(rightBearing)) / 111000;
            const rightDeltaLng = (wedgeLength * Math.sin(rightBearing)) / (111000 * Math.cos(nodeLat * Math.PI / 180));
            points.push([nodeCenter[0] + rightDeltaLat, nodeCenter[1] + rightDeltaLng]);
            
            // Close the wedge back to exact center
            points.push(nodeCenter);
            
            // Create direction wedge with proximity-based intensity (no border, fill only)
            const wedge = L.polygon(points, {
                color: '#4A9B9D',
                weight: 0, // No border/stroke
                opacity: 0, // No stroke opacity
                fillColor: '#4A9B9D',
                fillOpacity: fillIntensity,
                className: 'tdoa-direction-wedge pulsing'
            }).addTo(map);
            
            // Store proximity data for updates
            wedge._proximityRatio = proximityRatio;
            wedge._distance = distance;
            wedge._pulseDuration = pulseDuration;
            wedge._pulseMaxOpacity = pulseMaxOpacity;
            wedge._pulseMinOpacity = pulseMinOpacity;
            wedge._pulseStartTime = Date.now();
            wedge._pulsePhase = 0; // 0 to 1, tracks animation phase
            
            // Start pulsing animation using JavaScript (works better with Leaflet SVG)
            if (!wedge._pulseAnimationId) {
                function animatePulse() {
                    if (!wedge || !map.hasLayer(wedge)) {
                        return;
                    }
                    
                    const elapsed = (Date.now() - wedge._pulseStartTime) / 1000;
                    const phase = (elapsed % wedge._pulseDuration) / wedge._pulseDuration;
                    
                    // Calculate opacity based on pulse phase (sine wave for smooth animation)
                    const pulseValue = Math.sin(phase * Math.PI * 2);
                    // Map from -1 to 1, to minOpacity to maxOpacity
                    const normalizedPulse = (pulseValue + 1) / 2; // 0 to 1
                    const currentOpacity = wedge._pulseMinOpacity + 
                        (normalizedPulse * (wedge._pulseMaxOpacity - wedge._pulseMinOpacity));
                    
                    // Update fill opacity
                    wedge.setStyle({ fillOpacity: currentOpacity });
                    
                    wedge._pulseAnimationId = requestAnimationFrame(animatePulse);
                }
                
                wedge._pulseAnimationId = requestAnimationFrame(animatePulse);
            }
            
            // Add popup with direction details
            wedge.bindPopup(`
                <div style="font-family: 'Courier New', monospace; font-size: 11px; color: #a0a0a0; background: #0a0a0a; padding: 5px;">
                    <strong style="color: #ff6b6b;">Drone Direction</strong><br>
                    <span>Bearing: ${bearingDeg.toFixed(1)}°</span><br>
                    <span>Distance: ${distance.toFixed(1)}m</span><br>
                    <span>Drone Lat: ${droneLat.toFixed(6)}</span><br>
                    <span>Drone Lng: ${droneLng.toFixed(6)}</span>
                </div>
            `);
            
            return wedge;
        }

        // Calculate horizontal distance between two lat/lng points using Haversine formula
        function calculateHorizontalDistance(lat1, lng1, lat2, lng2) {
            const R = 6371000; // Earth's radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c; // Distance in meters
        }

        // Update node popups with distance to drone
        function updateNodePopupsWithDistance() {
            let dronePos = null;
            // flightMarker removed - use current flight log position instead
            if (flightLogData && flightLogData.length > 0 && currentIndex < flightLogData.length) {
                const currentPoint = flightLogData[currentIndex];
                dronePos = { lat: currentPoint.lat, lng: currentPoint.lng };
            }

            // Update acoustic array popup
            if (acousticNode) {
                let distanceText = 'N/A';
                if (dronePos) {
                    const distance = calculateHorizontalDistance(ACOUSTIC_ARRAY.lat, ACOUSTIC_ARRAY.lng, dronePos.lat, dronePos.lng);
                    distanceText = `${distance.toFixed(1)} m`;
                }
                
                // Ensure popup is bound before setting content
                if (!acousticNode.getPopup()) {
                    acousticNode.bindPopup(''); // Bind an empty popup initially
                }
                acousticNode.setPopupContent(`
                    <div style="font-family: 'Courier New', monospace; font-size: 11px; color: #a0a0a0; background: #0a0a0a; padding: 5px;">
                        <strong style="color: #ff6b6b;">ACOUSTIC ARRAY</strong><br>
                        <span>STATUS: ${document.getElementById('arrayStatus').textContent}</span><br>
                        <span>LAT: ${ACOUSTIC_ARRAY.lat.toFixed(6)}</span><br>
                        <span>LNG: ${ACOUSTIC_ARRAY.lng.toFixed(6)}</span><br>
                        <span>MICS: 4-CHANNEL</span><br>
                        <span>BEARING: ${ACOUSTIC_ARRAY.bearing}°</span><br>
                        <span style="color: #d4a574;">DISTANCE: ${distanceText}</span>
                    </div>
                `);
            }
            
            // Update detection nodes
            detectionNodes.forEach(node => {
                let distanceText = 'N/A';
                if (dronePos) {
                    const distance = calculateHorizontalDistance(node.lat, node.lng, dronePos.lat, dronePos.lng);
                    distanceText = `${distance.toFixed(1)} m`;
                }

                // Ensure popup is bound before setting content
                if (!node.marker.getPopup()) {
                    node.marker.bindPopup(''); // Bind an empty popup initially
                }
                node.marker.setPopupContent(`
                    <div style="
                        font-family: 'Courier New', monospace;
                        font-size: 11px;
                        color: #a0a0a0;
                        background: #0a0a0a;
                        padding: 5px;
                    ">
                        <strong style="color: #d4a574;">Detection Node ${node.id + 1}</strong><br>
                        <span>LAT: ${node.lat.toFixed(6)}</span><br>
                        <span>LNG: ${node.lng.toFixed(6)}</span><br>
                        <span style="color: #d4a574;">DISTANCE: ${distanceText}</span><br>
                        <button onclick="removeNode(${node.id})" style="
                            background: #b85450;
                            border: 1px solid #b85450;
                            color: #fff;
                            padding: 3px 8px;
                            font-size: 9px;
                            cursor: pointer;
                            margin-top: 5px;
                        ">REMOVE</button>
                    </div>
                `);
            });
        }

        // Toast Notification Function
        function showToast(message, duration = 3000) {
            const container = document.getElementById('toastContainer');
            if (!container) return;
            
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            container.appendChild(toast);
            
            // Trigger show animation
            setTimeout(() => {
                toast.classList.add('show');
            }, 10);
            
            // Auto-hide after duration
            setTimeout(() => {
                toast.classList.remove('show');
                toast.classList.add('hide');
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, duration);
        }

        function updateDirectionIndicator(dronePosition) {
            if (!dronePosition) {
                console.log('No drone position available');
                return;
            }
            
            if (!droneDirectionalIndicatorVisible) {
                // Hide all directional indicators if toggle is off
                if (currentDirectionWedge) {
                    map.removeLayer(currentDirectionWedge);
                    currentDirectionWedge = null;
                }
                detectionNodes.forEach(node => {
                    if (node.directionWedge) {
                        map.removeLayer(node.directionWedge);
                        node.directionWedge = null;
                    }
                    if (nodeDirectionWedges[node.id]) {
                        map.removeLayer(nodeDirectionWedges[node.id]);
                        nodeDirectionWedges[node.id] = null;
                    }
                });
                return;
            }
            
            // Helper function to stop wedge animation
            function stopWedgeAnimation(wedge) {
                if (wedge && wedge._pulseAnimationId) {
                    cancelAnimationFrame(wedge._pulseAnimationId);
                    wedge._pulseAnimationId = null;
                }
            }
            
            // Update main acoustic node direction wedge
            if (acousticNode) {
                // Remove previous direction indicator
                if (currentDirectionWedge) {
                    stopWedgeAnimation(currentDirectionWedge);
                    map.removeLayer(currentDirectionWedge);
                    currentDirectionWedge = null;
                }
                
                // Create new direction wedge for main acoustic node
                const newWedge = createDirectionWedgeForNode(
                    ACOUSTIC_ARRAY.lat, 
                    ACOUSTIC_ARRAY.lng, 
                    dronePosition,
                    'main'
                );
                if (newWedge) {
                    currentDirectionWedge = newWedge;
                } else {
                    // Wedge is null (beyond 200m), ensure reference is cleared
                    currentDirectionWedge = null;
                }
            }
            
            // Update direction wedges for all detection nodes
            detectionNodes.forEach(node => {
                // Remove previous wedge if it exists
                if (node.directionWedge) {
                    stopWedgeAnimation(node.directionWedge);
                    map.removeLayer(node.directionWedge);
                }
                if (nodeDirectionWedges[node.id]) {
                    stopWedgeAnimation(nodeDirectionWedges[node.id]);
                    map.removeLayer(nodeDirectionWedges[node.id]);
                }
                
                // Create new direction wedge for this node
                const newWedge = createDirectionWedgeForNode(
                    node.lat,
                    node.lng,
                    dronePosition,
                    node.id
                );
                
                if (newWedge) {
                    node.directionWedge = newWedge;
                    nodeDirectionWedges[node.id] = newWedge;
                } else {
                    // Wedge is null (beyond 200m), ensure references are cleared
                    node.directionWedge = null;
                    nodeDirectionWedges[node.id] = null;
                }
            });
        }
        
        // Alias for compatibility
        function updateDirectionWedges(lat, lng) {
            updateDirectionIndicator({ lat, lng });
        }
        

        // Process JSON data and update map
        function processData(jsonData) {
            try {
                // Update status
                document.getElementById('dataStatus').textContent = 'ACTIVE';
                document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();

                // Expected JSON format:
                // {
                //   "nodes": [
                //     {
                //       "id": "node1",
                //       "lat": 37.7749,
                //       "lng": -122.4194,
                //       "name": "Node 1",
                //       "status": "active",
                //       "data": {...}
                //     }
                //   ],
                //   "features": [
                //     {
                //       "type": "polygon",
                //       "coordinates": [[lat, lng], ...],
                //       "properties": {...}
                //     }
                //   ]
                // }

                let nodeCount = 0;

                // Process nodes (moving points)
                if (jsonData.nodes && Array.isArray(jsonData.nodes)) {
                    nodeCount = jsonData.nodes.length;
                    
                    jsonData.nodes.forEach(node => {
                        if (node.id && node.lat !== undefined && node.lng !== undefined) {
                            updateOrCreateMarker(node);
                        }
                    });
                }

                // Process features (polygons, lines, etc.)
                if (jsonData.features && Array.isArray(jsonData.features)) {
                    jsonData.features.forEach(feature => {
                        updateOrCreateFeature(feature);
                    });
                }

                // Update node count
                document.getElementById('nodeCount').textContent = nodeCount;

                // Update current map center coordinates
                const center = map.getCenter();
                document.getElementById('currentLat').textContent = center.lat.toFixed(6);
                document.getElementById('currentLng').textContent = center.lng.toFixed(6);

            } catch (error) {
                console.error('Error processing data:', error);
                document.getElementById('dataStatus').textContent = 'ERROR';
            }
        }

        // Update or create marker for a node
        function updateOrCreateMarker(node) {
            const markerId = node.id;

            if (markers[markerId]) {
                // Update existing marker position
                const marker = markers[markerId];
                marker.setLatLng([node.lat, node.lng]);
                
                // Update popup if name changed
                if (node.name && marker.getPopup()) {
                    marker.setPopupContent(createMarkerPopup(node));
                }
            } else {
                // Create new marker
                const icon = L.divIcon({
                    className: 'tactical-marker',
                    html: `<div style="
                        width: 12px;
                        height: 12px;
                        background-color: #4A9B9D;
                        border: 2px solid #3A7B7D;
                        border-radius: 50%;
                        box-shadow: 0 0 5px rgba(74, 155, 157, 0.6);
                    "></div>`,
                    iconSize: [12, 12],
                    iconAnchor: [6, 6]
                });

                const marker = L.marker([node.lat, node.lng], { icon: icon })
                    .addTo(map)
                    .bindPopup(createMarkerPopup(node));

                markers[markerId] = marker;
            }
        }

        // Create popup content for marker
        function createMarkerPopup(node) {
            const name = node.name || node.id;
            const status = node.status || 'UNKNOWN';
            const statusColor = status === 'active' ? '#5a8a6a' : '#b85450';
            
            return `
                <div style="
                    font-family: 'Courier New', monospace;
                    font-size: 11px;
                    color: #a0a0a0;
                    background: #0a0a0a;
                    padding: 5px;
                ">
                    <strong style="color: #d4a574;">${name}</strong><br>
                    <span style="color: ${statusColor};">STATUS: ${status.toUpperCase()}</span><br>
                    <span>LAT: ${node.lat.toFixed(6)}</span><br>
                    <span>LNG: ${node.lng.toFixed(6)}</span>
                </div>
            `;
        }

        // Update or create feature (polygons, lines, etc.)
        function updateOrCreateFeature(feature) {
            // This will be implemented based on your feature format
            // For now, placeholder for polygon/line features
            console.log('Feature received:', feature);
        }

        // Fetch and process data from URL
        async function fetchData() {
            if (!dataSourceUrl) {
                return;
            }

            try {
                const response = await fetch(dataSourceUrl);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const jsonData = await response.json();
                processData(jsonData);
            } catch (error) {
                console.error('Error fetching data:', error);
                document.getElementById('dataStatus').textContent = 'ERROR';
            }
        }

        // Start data feed
        function startDataFeed() {
            const url = document.getElementById('dataSourceUrl').value;
            const interval = parseInt(document.getElementById('updateInterval').value) || 1000;

            if (!url) {
                alert('Please enter a data source URL');
                return;
            }

            dataSourceUrl = url;
            
            // Stop existing feed if running
            stopDataFeed();

            // Fetch immediately
            fetchData();

            // Set up interval
            updateInterval = setInterval(fetchData, interval);
            
            document.getElementById('dataStatus').textContent = 'ACTIVE';
        }

        // Stop data feed
        function stopDataFeed() {
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }
            document.getElementById('dataStatus').textContent = 'IDLE';
        }

        // Manual data injection function (for testing)
        window.injectData = function(jsonData) {
            processData(jsonData);
        };

        // Helper function to detect binary files
        function isBinaryFile(content) {
            // Check for null bytes or high percentage of non-printable characters
            if (typeof content === 'string') {
                // Check first 512 bytes for binary indicators
                const sample = content.substring(0, 512);
                let nonPrintable = 0;
                for (let i = 0; i < sample.length; i++) {
                    const charCode = sample.charCodeAt(i);
                    // Check for null bytes or control characters (except common whitespace)
                    if (charCode === 0 || (charCode < 32 && charCode !== 9 && charCode !== 10 && charCode !== 13)) {
                        nonPrintable++;
                    }
                }
                // If more than 5% are non-printable, likely binary
                return nonPrintable > (sample.length * 0.05);
            }
            return false;
        }
        
        // Flight Log Functions
        function handleFileUpload(event) {
            const files = event.target.files;
            if (!files || files.length === 0) {
                // Check if this is simulation mode and we're clicking "Activate Simulation"
                if (simulationMode && edsbData) {
                    activateSimulation();
                    return;
                }
                return;
            }

            // Process each file
            Array.from(files).forEach((file, index) => {
            const reader = new FileReader();
            reader.onload = function(e) {
                const fileName = file.name.toLowerCase();
                    let flightLogObj = null;
                    
                // Check if file is binary (DJI flight record binary format)
                const isBinary = isBinaryFile(e.target.result);
                
                if (isBinary && fileName.includes('djiflightrecord') || fileName.includes('flightrecord')) {
                    // Try to handle binary DJI flight record
                    showToast('Binary DJI flight record files are not directly supported. Please export as CSV/TXT from DJI software.');
                    console.warn('Binary DJI flight record file detected:', file.name);
                    return;
                }
                    
                if (fileName.endsWith('.kml')) {
                        flightLogObj = parseKMLFlightLogToObject(e.target.result, file.name);
                } else {
                        flightLogObj = parseDJIFlightLogToObject(e.target.result, file.name);
                    }
                    
                    if (flightLogObj) {
                        addFlightLog(flightLogObj);
                    }
                };
                
                // Try to read as text first, fallback to array buffer for binary detection
                reader.onerror = function() {
                    showToast('Error reading file: ' + file.name);
                };
                
                reader.readAsText(file);
            });
            
            // Reset file input to allow selecting the same files again
            event.target.value = '';
        }

        // Generate a unique color for each flight log
        function generateFlightLogColor(index) {
            const colors = [
                '#5a8a6a', '#8a5a6a', '#6a8a5a', '#8a6a5a', 
                '#5a6a8a', '#6a5a8a', '#8a8a5a', '#5a8a8a',
                '#8a5a8a', '#6a8a8a', '#8a6a8a', '#5a5a8a'
            ];
            return colors[index % colors.length];
        }

        // Add a flight log to the collection
        function addFlightLog(flightLogObj) {
            const id = 'flight_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const color = generateFlightLogColor(flightLogs.length);
            
            const flightLog = {
                id: id,
                name: flightLogObj.name || 'Flight Log',
                fileName: flightLogObj.fileName,
                data: flightLogObj.data,
                headers: flightLogObj.headers || [],
                allData: flightLogObj.allData || [],
                messages: flightLogObj.messages || [],
                aircraftName: flightLogObj.aircraftName || null,
                visible: true,
                selected: false, // Will be set if this is the first log
                color: color,
                polyline: null,
                stats: flightLogObj.stats || {}
            };
            
            // Add new flight log to the beginning of the array (most recent first)
            flightLogs.unshift(flightLog);
            
            // Deselect all other flight logs and select the newly imported one
            flightLogs.forEach(fl => {
                fl.selected = (fl.id === id);
            });
            
            renderFlightLogPolyline(flightLog);
            
            // Update polylines with correct colors for all flight logs
            flightLogs.forEach(fl => {
                if (fl.polyline) {
                    const newColor = fl.selected ? '#5a8a6a' : '#dd9999';
                    fl.polyline.setStyle({ color: newColor });
                }
            });
            
            updateFlightLogsList();
            updateImportButtonCentering();
            
            // Update markers/labels for selected flight log
            updateSelectedFlightLogMarkers();
            
            // Show the flight logs list
            const listContainer = document.getElementById('flightLogsList');
            if (listContainer) {
                listContainer.style.display = 'block';
            }
            
                // Use selected flight log for playback (backward compatibility)
                const selectedLog = flightLogs.find(fl => fl.selected);
                if (selectedLog && selectedLog.data && selectedLog.data.length > 0) {
                    flightLogData = selectedLog.data;
                    flightStartTime = selectedLog.stats.startTime || 0;
                    flightEndTime = selectedLog.stats.endTime || selectedLog.data.length - 1;
                    
                    // Reset previous distance from home for new flight log
                    previousDistanceFromHome = null;
                
                // Update UI elements
                const flightPointsEl = document.getElementById('flightPoints');
                const flightDistanceEl = document.getElementById('flightDistance');
                const flightTotalTimeEl = document.getElementById('flightTotalTime');
                const timelineSliderEl = document.getElementById('timelineSlider');
                const fileNameEl = document.getElementById('fileName');
                
                if (flightPointsEl) flightPointsEl.textContent = selectedLog.data.length;
                if (flightDistanceEl && selectedLog.stats.distance) {
                    flightDistanceEl.textContent = selectedLog.stats.distance.toFixed(2) + ' km';
                }
                if (flightTotalTimeEl && selectedLog.stats.duration) {
                    flightTotalTimeEl.textContent = selectedLog.stats.duration;
                }
                if (timelineSliderEl) {
                    timelineSliderEl.max = selectedLog.data.length - 1;
                    timelineSliderEl.value = 0;
                }
                if (fileNameEl) fileNameEl.textContent = selectedLog.fileName;
                
                // Remove old backward compatibility flightPath when using new flight log system
                if (flightPath && map.hasLayer(flightPath)) {
                    map.removeLayer(flightPath);
                    flightPath = null;
                }
            }
            
            // Close any open popups before zooming
            if (map) {
                map.closePopup();
                // Also close any marker popups
                if (flightMarker && flightMarker.isPopupOpen && flightMarker.isPopupOpen()) {
                    flightMarker.closePopup();
                }
                // Close MQTT drone popups
                Object.values(mqttDroneMarkers).forEach(marker => {
                    if (marker.isPopupOpen && marker.isPopupOpen()) {
                        marker.closePopup();
                    }
                });
            }
            
            // Zoom to flight log bounds when loaded
            if (flightLog.data && flightLog.data.length > 0) {
                const bounds = flightLog.data.map(point => [point.lat, point.lng]);
                map.fitBounds(bounds, { padding: [50, 50] });
            }
            
            // Update toggle visibility (this will show play button and stats if flight log exists)
            updateToggleVisibility();
            
            // Update download button pulse
            updateDownloadButtonPulse();
            
            // Update legend if open
            if (legendVisible) {
                updateLegendVisibility();
            }
            
            showToast(`Loaded flight log: ${flightLog.name}`);
        }

        // Render a polyline for a flight log
        function renderFlightLogPolyline(flightLog) {
            if (!flightLog.data || flightLog.data.length === 0) return;
            
            // Remove existing polyline if it exists
            if (flightLog.polyline) {
                map.removeLayer(flightLog.polyline);
            }
            
            // Create polyline from flight data
            const coordinates = flightLog.data.map(point => [point.lat, point.lng]);
            // Use green for selected, red for unselected
            const lineColor = flightLog.selected ? '#5a8a6a' : '#dd9999';
            const polyline = L.polyline(coordinates, {
                color: lineColor,
                weight: 2,
                opacity: 0.7
            });
            
            // Add click handler
            polyline.on('click', function(e) {
                showFlightLogPopup(flightLog);
            });
            
            flightLog.polyline = polyline;
            
            // Add to map if visible and track toggle is on
            const trackToggle = document.getElementById('toggleTrack');
            const isTrackVisible = trackToggle && trackToggle.classList.contains('active');
            if (flightLog.visible && isTrackVisible) {
                polyline.addTo(map);
            }
        }

        // Update the flight logs list UI
        function updateFlightLogsList() {
            const listContent = document.getElementById('flightLogsListContent');
            if (!listContent) return;
            
            listContent.innerHTML = '';
            
            // Display in order (newest first, which is how they're stored)
            flightLogs.forEach((flightLog, index) => {
                const item = document.createElement('div');
                item.className = 'flight-log-item';
                // Add border style based on selection
                const borderColor = flightLog.selected ? '#5a8a6a' : '#dd9999';
                item.style.border = `2px solid ${borderColor}`;
                item.style.borderRadius = '4px';
                item.style.padding = '4px';
                item.style.marginBottom = '4px';
                item.style.cursor = 'pointer';
                item.onclick = function(e) {
                    // Don't trigger if clicking on checkbox, button, or info button
                    if (e.target.type === 'checkbox' || e.target.classList.contains('flight-log-remove') || e.target.classList.contains('flight-log-info')) {
                        return;
                    }
                    selectFlightLog(flightLog.id);
                };
                // Color indicator matches border color (green for selected, red for unselected)
                const indicatorColor = flightLog.selected ? '#5a8a6a' : '#dd9999';
                item.innerHTML = `
                    <div class="color-indicator" style="background-color: ${indicatorColor};"></div>
                    <div class="flight-log-name" title="${flightLog.fileName}">${flightLog.name}</div>
                    <input type="checkbox" class="flight-log-checkbox" ${flightLog.visible ? 'checked' : ''} 
                           title="Toggle visibility"
                           onclick="event.stopPropagation();"
                           onchange="toggleFlightLogVisibility('${flightLog.id}', this.checked)">
                    <button class="flight-log-info" onclick="event.stopPropagation(); showFlightLogPopup('${flightLog.id}')" title="Show flight log details">i</button>
                    <button class="flight-log-remove" onclick="event.stopPropagation(); removeFlightLog('${flightLog.id}')">×</button>
                `;
                listContent.appendChild(item);
            });
        }
        
        // Select a flight log (single-select) - only works if flight log is checked
        function selectFlightLog(id) {
            const flightLog = flightLogs.find(fl => fl.id === id);
            if (!flightLog || !flightLog.visible) {
                return; // Can't select an unchecked flight log
            }
            
            // Deselect all flight logs
            flightLogs.forEach(fl => {
                fl.selected = (fl.id === id);
            });
            
            // Update polylines with correct colors
            flightLogs.forEach(fl => {
                if (fl.polyline) {
                    const newColor = fl.selected ? '#5a8a6a' : '#dd9999';
                    fl.polyline.setStyle({ color: newColor });
                }
            });
            
            // Update UI
            updateFlightLogsList();
            updateImportButtonCentering();
            
            // Update markers/labels for selected flight log
            updateSelectedFlightLogMarkers();
            
            // Update legend if open
            if (legendVisible) {
                updateLegendVisibility();
            }
            
            // Update playback data if this is the selected log
            const selectedLog = flightLogs.find(fl => fl.selected);
            if (selectedLog && selectedLog.data && selectedLog.data.length > 0) {
                flightLogData = selectedLog.data;
                flightStartTime = selectedLog.stats.startTime || 0;
                flightEndTime = selectedLog.stats.endTime || selectedLog.data.length - 1;
                
                // Update UI elements
                const flightPointsEl = document.getElementById('flightPoints');
                const flightDistanceEl = document.getElementById('flightDistance');
                const flightTotalTimeEl = document.getElementById('flightTotalTime');
                const timelineSliderEl = document.getElementById('timelineSlider');
                const fileNameEl = document.getElementById('fileName');
                
                if (flightPointsEl) flightPointsEl.textContent = selectedLog.data.length;
                if (flightDistanceEl && selectedLog.stats.distance) {
                    flightDistanceEl.textContent = selectedLog.stats.distance.toFixed(2) + ' km';
                }
                if (flightTotalTimeEl && selectedLog.stats.duration) {
                    flightTotalTimeEl.textContent = selectedLog.stats.duration;
                }
                if (timelineSliderEl) {
                    timelineSliderEl.max = selectedLog.data.length - 1;
                    timelineSliderEl.value = 0;
                }
                if (fileNameEl) fileNameEl.textContent = selectedLog.fileName;
            }
        }
        window.selectFlightLog = selectFlightLog;
        
        // Update markers and labels for the selected flight log
        function updateSelectedFlightLogMarkers() {
            const selectedLog = flightLogs.find(fl => fl.selected && fl.visible);
            
            // Remove all existing markers and labels first
            if (homePointMarker && map.hasLayer(homePointMarker)) {
                map.removeLayer(homePointMarker);
                homePointMarker = null;
            }
            if (homePointLabel) {
                if (map.hasLayer(homePointLabel)) {
                    map.removeLayer(homePointLabel);
                }
                if (homePointLabel._pointerLine && map.hasLayer(homePointLabel._pointerLine)) {
                    map.removeLayer(homePointLabel._pointerLine);
                }
                homePointLabel = null;
            }
            // flightMarker removed - no longer needed
            if (droneLabel) {
                try {
                    if (map.hasLayer(droneLabel)) {
                        map.removeLayer(droneLabel);
                    }
                    if (droneLabel._pointerLine && map.hasLayer(droneLabel._pointerLine)) {
                        map.removeLayer(droneLabel._pointerLine);
                    }
                } catch (e) {
                    // Ignore errors
                }
                droneLabel = null;
            }
            
            // Only show markers/labels for the selected and visible flight log
            if (selectedLog && selectedLog.data && selectedLog.data.length > 0) {
                const homePoint = selectedLog.data[0];
                
                // Create home point marker
                if (homePoint) {
                    createHomePointMarker(homePoint);
                }
                
                // Show drone marker if drone toggle is on
                // CRITICAL: Use the EXACT same homePoint object to ensure identical coordinates
                const droneToggle = document.getElementById('toggleDrone');
                if (droneToggle && droneToggle.classList.contains('active') && homePoint) {
                    // Ensure we use the exact same coordinates - no rounding or conversion
                    // Create drone marker at home point position - use EXACT same coordinates
                    if (homePoint) {
                        console.log('Creating drone marker at home point:', homePoint.lat, homePoint.lng);
                        // Use the exact same object to ensure no coordinate conversion issues
                        createFlightMarker({
                            lat: homePoint.lat,
                            lng: homePoint.lng,
                            altitude: homePoint.altitude,
                            time: homePoint.time
                        });
                        
                        // Verify both markers are at the same location
                        if (homePointMarker && flightMarker) {
                            const homePos = homePointMarker.getLatLng();
                            const dronePos = flightMarker.getLatLng();
                            console.log('Marker alignment check:', {
                                homePoint: { lat: homePos.lat, lng: homePos.lng },
                                droneMarker: { lat: dronePos.lat, lng: dronePos.lng },
                                match: homePos.lat === dronePos.lat && homePos.lng === dronePos.lng
                            });
                        }
                    }
                    
                    // Show drone label if label toggle is on
                    const droneLabelToggle = document.getElementById('toggleDroneLabel');
                    if (droneLabelToggle && droneLabelToggle.classList.contains('active') && homePoint) {
                        updateDroneLabel(homePoint.lat, homePoint.lng);
                    }
                }
            }
        }


        // Toggle flight log visibility
        function toggleFlightLogVisibility(id, visible) {
            const flightLog = flightLogs.find(fl => fl.id === id);
            if (!flightLog) return;
            
            const wasSelected = flightLog.selected;
            flightLog.visible = visible;
            
            // If unchecking the selected flight log, find next checked one to select
            if (!visible && wasSelected) {
                const nextChecked = flightLogs.find(fl => fl.id !== id && fl.visible);
                if (nextChecked) {
                    // Select the next checked flight log
                    selectFlightLog(nextChecked.id);
                } else {
                    // No checked flight logs, deselect all
                    flightLogs.forEach(fl => fl.selected = false);
                    updateFlightLogsList();
            updateImportButtonCentering();
                    updateSelectedFlightLogMarkers();
                }
            } else if (visible && !wasSelected) {
                // If checking a flight log and none are selected, select this one
                const anySelected = flightLogs.some(fl => fl.selected);
                if (!anySelected) {
                    selectFlightLog(id);
                }
            }
            
            // Check track toggle state
            const trackToggle = document.getElementById('toggleTrack');
            const isTrackVisible = trackToggle && trackToggle.classList.contains('active');
            
            if (flightLog.polyline) {
                // Completely remove from map if not visible
                if (!visible || !isTrackVisible) {
                    try {
                        if (map.hasLayer(flightLog.polyline)) {
                            map.removeLayer(flightLog.polyline);
                        }
                    } catch (e) {
                        // Ignore errors if layer isn't on map
                    }
                } else {
                    // Add to map if both visible and track toggle is on
                    if (!map.hasLayer(flightLog.polyline)) {
                        flightLog.polyline.addTo(map);
                    }
                }
                
                // Update color based on selection state
                const newColor = flightLog.selected ? '#5a8a6a' : '#ff6b6b';
                flightLog.polyline.setStyle({ color: newColor });
            }
            
            // Update markers/labels - only show for selected and visible flight log
            updateSelectedFlightLogMarkers();
            
            // Update legend if open
            if (legendVisible) {
                updateLegendVisibility();
            }
        }
        window.toggleFlightLogVisibility = toggleFlightLogVisibility;

        // Remove a flight log - completely remove all associated map objects
        function removeFlightLog(id) {
            const index = flightLogs.findIndex(fl => fl.id === id);
            if (index === -1) return;
            
            const flightLog = flightLogs[index];
            
            // Remove polyline from map
            if (flightLog.polyline && map.hasLayer(flightLog.polyline)) {
                map.removeLayer(flightLog.polyline);
                flightLog.polyline = null;
            }
            
            // Check if this was the selected flight log
            const wasSelected = flightLog.selected;
            
            // Remove from array first
            flightLogs.splice(index, 1);
            
            // If the selected flight log was removed, select the first checked one
            if (wasSelected && flightLogs.length > 0) {
                const firstChecked = flightLogs.find(fl => fl.visible);
                if (firstChecked) {
                    selectFlightLog(firstChecked.id);
                } else {
                    // No checked flight logs, deselect all
                    flightLogs.forEach(fl => fl.selected = false);
                    // Update polylines with correct colors
                    flightLogs.forEach(fl => {
                        if (fl.polyline) {
                            fl.polyline.setStyle({ color: '#dd9999' });
                        }
                    });
                    updateFlightLogsList();
            updateImportButtonCentering();
                    updateSelectedFlightLogMarkers();
                }
            }
            
            // If this was the first flight log (used for playback), update to use the next one
            if (wasSelected && flightLogs.length > 0) {
                const nextFlightLog = flightLogs[0];
                if (nextFlightLog.data && nextFlightLog.data.length > 0) {
                    flightLogData = nextFlightLog.data;
                    flightStartTime = nextFlightLog.stats.startTime || 0;
                    flightEndTime = nextFlightLog.stats.endTime || nextFlightLog.data.length - 1;
                    
                    // Update old backward compatibility flight path
                    drawFlightPath();
                    
                    // Update UI elements
                    const flightPointsEl = document.getElementById('flightPoints');
                    const flightDistanceEl = document.getElementById('flightDistance');
                    const flightTotalTimeEl = document.getElementById('flightTotalTime');
                    const timelineSliderEl = document.getElementById('timelineSlider');
                    const fileNameEl = document.getElementById('fileName');
                    
                    if (flightPointsEl) flightPointsEl.textContent = nextFlightLog.data.length;
                    if (flightDistanceEl && nextFlightLog.stats.distance) {
                        flightDistanceEl.textContent = nextFlightLog.stats.distance.toFixed(2) + ' km';
                    }
                    if (flightTotalTimeEl && nextFlightLog.stats.duration) {
                        flightTotalTimeEl.textContent = nextFlightLog.stats.duration;
                    }
                    if (timelineSliderEl) {
                        timelineSliderEl.max = nextFlightLog.data.length - 1;
                        timelineSliderEl.value = 0;
                    }
                    if (fileNameEl) fileNameEl.textContent = nextFlightLog.fileName;
                    
                    // Remove old backward compatibility flightPath when using new flight log system
                    if (flightPath && map.hasLayer(flightPath)) {
                        map.removeLayer(flightPath);
                        flightPath = null;
                    }
                }
            } else if (flightLogs.length === 0) {
                // No flight logs left, clean up everything
                flightLogData = [];
                flightStartTime = 0;
                flightEndTime = 0;
                currentIndex = 0;
                
                // Remove old backward compatibility flight path
                if (flightPath) {
                    if (map.hasLayer(flightPath)) {
                        map.removeLayer(flightPath);
                    }
                    flightPath = null;
                }
                
                // Remove flight marker if it exists
                // flightMarker removed - no longer needed
                
                // Remove drone label if it exists
                if (droneLabel) {
                    if (map.hasLayer(droneLabel)) {
                        map.removeLayer(droneLabel);
                    }
                    if (droneLabel._pointerLine && map.hasLayer(droneLabel._pointerLine)) {
                        map.removeLayer(droneLabel._pointerLine);
                    }
                    droneLabel = null;
                }
                
                // Remove home point marker if it exists
                if (homePointMarker && map.hasLayer(homePointMarker)) {
                    map.removeLayer(homePointMarker);
                    homePointMarker = null;
                }
                
                // Remove home point label if it exists
                if (homePointLabel && map.hasLayer(homePointLabel)) {
                    map.removeLayer(homePointLabel);
                    homePointLabel = null;
                }
                
                // Reset playback if playing
                if (isPlaying) {
                    stopFlightLogPlayback();
                    isPlaying = false;
                    const button = document.getElementById('playButton');
                    if (button) {
                        button.textContent = 'PLAY';
                        button.classList.remove('playing');
                    }
                }
                
                // Update UI elements
                const flightPointsEl = document.getElementById('flightPoints');
                const flightDistanceEl = document.getElementById('flightDistance');
                const flightTotalTimeEl = document.getElementById('flightTotalTime');
                const timelineSliderEl = document.getElementById('timelineSlider');
                
                if (flightPointsEl) flightPointsEl.textContent = '0';
                if (flightDistanceEl) flightDistanceEl.textContent = '0.00 km';
                if (flightTotalTimeEl) flightTotalTimeEl.textContent = '00:00:00';
                if (timelineSliderEl) {
                    timelineSliderEl.max = 0;
                    timelineSliderEl.value = 0;
                }
            }
            
            // Update UI
            updateFlightLogsList();
            updateImportButtonCentering();
            
            // Update toggle visibility
            updateToggleVisibility();
            
            // Hide list if empty
            if (flightLogs.length === 0) {
                const listContainer = document.getElementById('flightLogsList');
                if (listContainer) {
                    listContainer.style.display = 'none';
                }
            }
            
            // Update legend if open
            if (legendVisible) {
                updateLegendVisibility();
            }
        }
        window.removeFlightLog = removeFlightLog;

        // Show flight log info popup
        function showFlightLogPopup(flightLogOrId) {
            // Handle ID string or flightLog object
            let flightLog;
            if (typeof flightLogOrId === 'string') {
                flightLog = flightLogs.find(fl => fl.id === flightLogOrId);
                if (!flightLog) {
                    console.error('Flight log not found:', flightLogOrId);
                    return;
                }
            } else {
                flightLog = flightLogOrId;
            }
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'flight-log-popup-overlay';
            
            // Create popup
            const popup = document.createElement('div');
            popup.className = 'flight-log-popup';
            
            // Close function
            const closePopup = function() {
                if (overlay.parentNode) {
                    overlay.parentNode.removeChild(overlay);
                }
                if (popup.parentNode) {
                    popup.parentNode.removeChild(popup);
                }
            };
            
            overlay.onclick = function(e) {
                if (e.target === overlay) {
                    closePopup();
                }
            };
            
            // Prevent popup clicks from closing
            popup.onclick = function(e) {
                e.stopPropagation();
            };
            
            // Current point index for navigation
            let currentPointIndex = 0;
            
            // Function to render point data
            const renderPointData = function(pointIndex) {
                if (!flightLog.data || pointIndex < 0 || pointIndex >= flightLog.data.length) {
                    return '';
                }
                
                const point = flightLog.data[pointIndex];
                const allDataRow = flightLog.allData && flightLog.allData[pointIndex] ? flightLog.allData[pointIndex] : null;
                
                let pointContent = `
                    <div class="flight-log-popup-section">
                        <h4>Point ${pointIndex + 1} of ${flightLog.data.length}</h4>
                        <table class="flight-log-popup-table">
                            <thead>
                                <tr>
                                    <th>Field</th>
                                    <th>Value</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Index</td>
                                    <td>${point.index !== undefined ? point.index : pointIndex}</td>
                                </tr>
                                <tr>
                                    <td>Latitude</td>
                                    <td>${point.lat.toFixed(6)}</td>
                                </tr>
                                <tr>
                                    <td>Longitude</td>
                                    <td>${point.lng.toFixed(6)}</td>
                                </tr>
                                <tr>
                                    <td>Altitude</td>
                                    <td>${point.altitude !== undefined ? point.altitude.toFixed(1) + 'm' : 'N/A'}</td>
                                </tr>
                                <tr>
                                    <td>Time</td>
                                    <td>${point.time !== undefined ? point.time : 'N/A'}</td>
                                </tr>
                `;
                
                // Add all other columns if available
                if (allDataRow && flightLog.headers.length > 0) {
                    flightLog.headers.forEach((header, idx) => {
                        // Skip already shown fields
                        const latIndex = findColumnIndex(flightLog.headers, ['OSD.latitude', 'latitude', 'lat', 'GPS.latitude']);
                        const lngIndex = findColumnIndex(flightLog.headers, ['OSD.longitude', 'longitude', 'lng', 'lon', 'GPS.longitude']);
                        const timeIndex = findColumnIndex(flightLog.headers, ['OSD.flyTime', 'flyTime', 'time', 'timestamp', 'OSD.time']);
                        const altIndex = findColumnIndex(flightLog.headers, ['OSD.height', 'height', 'altitude', 'alt', 'OSD.altitude']);
                        
                        if (idx !== latIndex && idx !== lngIndex && idx !== timeIndex && idx !== altIndex) {
                            const value = allDataRow[idx] !== undefined ? allDataRow[idx] : 'N/A';
                            pointContent += `
                                <tr>
                                    <td>${header}</td>
                                    <td>${value}</td>
                                </tr>
                            `;
                        }
                    });
                }
                
                pointContent += `
                            </tbody>
                        </table>
                    </div>
                `;
                
                return pointContent;
            };
            
            // Function to update point display
            const updatePointDisplay = function() {
                const pointContentDiv = popup.querySelector('#pointContent');
                if (pointContentDiv) {
                    pointContentDiv.innerHTML = renderPointData(currentPointIndex);
                }
                
                // Update navigation buttons
                const prevBtn = popup.querySelector('#prevPointBtn');
                const nextBtn = popup.querySelector('#nextPointBtn');
                const pointCounter = popup.querySelector('#pointCounter');
                
                if (prevBtn) prevBtn.disabled = currentPointIndex === 0;
                if (nextBtn) nextBtn.disabled = currentPointIndex >= flightLog.data.length - 1;
                if (pointCounter) pointCounter.textContent = `Point ${currentPointIndex + 1} of ${flightLog.data.length}`;
            };
            
            // Build content with tabs
            let content = `
                <div class="flight-log-popup-header">
                    <h3>${flightLog.name}</h3>
                    <button class="flight-log-popup-close">Close</button>
                </div>
                <div class="flight-log-popup-content">
                    <div class="flight-log-popup-tabs">
                        <div class="flight-log-popup-tab active" data-tab="info">Info</div>
                        <div class="flight-log-popup-tab" data-tab="analytics">Analytics</div>
                        <div class="flight-log-popup-tab" data-tab="messages">Messages</div>
                    </div>
                    
                    <div class="flight-log-popup-tab-content active" id="infoTab">
                        <div class="flight-log-popup-section">
                            <h4>File Information</h4>
                            <div style="margin-bottom: 5px;"><strong>File:</strong> ${flightLog.fileName}</div>
                            ${flightLog.aircraftName ? `<div style="margin-bottom: 5px;"><strong>Aircraft:</strong> ${flightLog.aircraftName}</div>` : ''}
                            ${flightLog.stats.distance ? `<div style="margin-bottom: 5px;"><strong>Total Distance:</strong> ${flightLog.stats.distance.toFixed(2)} km</div>` : ''}
                            ${flightLog.stats.duration ? `<div style="margin-bottom: 5px;"><strong>Duration:</strong> ${flightLog.stats.duration}</div>` : ''}
                            ${flightLog.data && flightLog.data.length > 0 ? `<div style="margin-bottom: 5px;"><strong>Total Points:</strong> ${flightLog.data.length}</div>` : ''}
                            ${flightLog.headers && flightLog.headers.length > 0 ? `<div style="margin-bottom: 5px;"><strong>Available Fields:</strong> ${flightLog.headers.length}</div>` : ''}
                        </div>
                        ${flightLog.headers && flightLog.headers.length > 0 ? `
                        <div class="flight-log-popup-section">
                            <h4>All Available Fields</h4>
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 5px; font-size: 11px; color: #a0a0a0;">
                                ${flightLog.headers.map(header => `<div>• ${header}</div>`).join('')}
                            </div>
                        </div>
                        ` : ''}
                        <div class="point-navigation">
                            <button id="prevPointBtn">←</button>
                            <div class="point-input-container">
                                <span class="point-input-label">Point:</span>
                                <input type="number" class="point-input" id="pointInput" min="1" max="${flightLog.data.length}" value="1" 
                                       onchange="window.jumpToPoint && window.jumpToPoint(this.value)"
                                       onkeypress="if(event.key==='Enter') { window.jumpToPoint && window.jumpToPoint(this.value); this.blur(); }">
                                <span class="point-input-label">of ${flightLog.data.length}</span>
                            </div>
                            <button id="nextPointBtn">→</button>
                        </div>
                        <div id="pointContent">${renderPointData(0)}</div>
                    </div>
                    
                    <div class="flight-log-popup-tab-content" id="messagesTab">
                        <div class="flight-log-popup-section">
                            <h4>Messages</h4>
                            ${flightLog.messages && flightLog.messages.length > 0 ? `
                                <div class="messages-list">
                                    ${flightLog.messages.map(msg => {
                                        // Calculate relative time based on position in flight and total duration
                                        let relativeTime = 0;
                                        
                                        if (flightLog.data && flightLog.data.length > 0 && flightLog.stats) {
                                            // Get the total flight duration in seconds
                                            const totalDuration = flightLog.stats.duration ? 
                                                (() => {
                                                    // Parse duration string like "14m 15s" to seconds
                                                    const durationStr = flightLog.stats.duration;
                                                    const match = durationStr.match(/(\d+)m\s*(\d+)s/);
                                                    if (match) {
                                                        return parseInt(match[1]) * 60 + parseInt(match[2]);
                                                    }
                                                    // If format is different, try to calculate from start/end times
                                                    if (flightLog.stats.startTime !== undefined && flightLog.stats.endTime !== undefined) {
                                                        let duration = flightLog.stats.endTime - flightLog.stats.startTime;
                                                        // Convert to seconds if in milliseconds
                                                        if (duration > 100000) {
                                                            duration = duration / 1000;
                                                        }
                                                        return duration;
                                                    }
                                                    return 0;
                                                })() : 0;
                                            
                                            // Calculate time based on message's position in the data array
                                            // Use dataIndex if available, otherwise use index
                                            const messagePosition = msg.dataIndex !== undefined ? msg.dataIndex : (msg.index !== undefined ? msg.index : 0);
                                            const totalPoints = flightLog.data.length;
                                            
                                            if (totalPoints > 0 && totalDuration > 0) {
                                                // Calculate time proportionally: (position / totalPoints) * totalDuration
                                                relativeTime = (messagePosition / totalPoints) * totalDuration;
                                            } else if (msg.time !== undefined && flightLog.stats.startTime !== undefined) {
                                                // Fallback: use timestamp difference
                                                let timeDiff = msg.time - flightLog.stats.startTime;
                                                if (Math.abs(timeDiff) > 100000) {
                                                    timeDiff = timeDiff / 1000;
                                                }
                                                relativeTime = Math.max(0, timeDiff);
                                            }
                                        }
                                        
                                        return `
                                        <div class="message-item">
                                            <div class="message-time">Time: ${relativeTime > 0 ? formatTimeHMS(relativeTime) : 'N/A'}</div>
                                            <div class="message-text">${msg.text || 'N/A'}</div>
                                        </div>
                                    `;
                                    }).join('')}
                                </div>
                            ` : '<div style="color: #888; font-size: 11px;">No messages found in this flight log.</div>'}
                        </div>
                    </div>
                    
                    <div class="flight-log-popup-tab-content" id="analyticsTab">
                        <div class="flight-log-popup-section">
                            <h4>Flight Analytics</h4>
                            <div style="margin-bottom: 25px;">
                                <canvas id="altitudeChart" style="max-height: 300px; height: 300px;"></canvas>
                            </div>
                            <div style="margin-bottom: 25px;">
                                <canvas id="distanceChart" style="max-height: 300px; height: 300px;"></canvas>
                            </div>
                            <div style="margin-bottom: 25px;">
                                <canvas id="speedChart" style="max-height: 300px; height: 300px;"></canvas>
                            </div>
                            <div style="margin-bottom: 25px;">
                                <canvas id="batteryChart" style="max-height: 300px; height: 300px;"></canvas>
                            </div>
                            <div style="margin-bottom: 25px;">
                                <canvas id="batteryTempChart" style="max-height: 300px; height: 300px;"></canvas>
                            </div>
                            <div style="margin-bottom: 25px;">
                                <canvas id="gimbalChart" style="max-height: 300px; height: 300px;"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            popup.innerHTML = content;
            
            // Initialize charts after popup is added to DOM
            setTimeout(() => {
                initializeAnalyticsCharts(flightLog);
            }, 100);
            
            // Store references for navigation
            window.currentPointIndex = 0;
            window.updatePointDisplay = function() {
                const pointContentDiv = popup.querySelector('#pointContent');
                if (pointContentDiv) {
                    pointContentDiv.innerHTML = renderPointData(window.currentPointIndex);
                }
                
                const prevBtn = popup.querySelector('#prevPointBtn');
                const nextBtn = popup.querySelector('#nextPointBtn');
                const pointInput = popup.querySelector('#pointInput');
                
                if (prevBtn) prevBtn.disabled = window.currentPointIndex === 0;
                if (nextBtn) nextBtn.disabled = window.currentPointIndex >= flightLog.data.length - 1;
                if (pointInput) {
                    pointInput.value = window.currentPointIndex + 1;
                    pointInput.max = flightLog.data.length;
                }
            };
            
            // Function to jump to a specific point
            window.jumpToPoint = function(pointNumber) {
                const pointNum = parseInt(pointNumber);
                if (isNaN(pointNum) || pointNum < 1 || pointNum > flightLog.data.length) {
                    // Invalid input, reset to current
                    const pointInput = popup.querySelector('#pointInput');
                    if (pointInput) {
                        pointInput.value = window.currentPointIndex + 1;
                    }
                    return;
                }
                
                // Convert from 1-based (user input) to 0-based (array index)
                window.currentPointIndex = pointNum - 1;
                window.updatePointDisplay();
            };
            
            // Add navigation button handlers
            const prevBtn = popup.querySelector('#prevPointBtn');
            const nextBtn = popup.querySelector('#nextPointBtn');
            
            if (prevBtn) {
                prevBtn.onclick = function() {
                    if (window.currentPointIndex > 0) {
                        window.currentPointIndex--;
                        window.updatePointDisplay();
                    }
                };
            }
            
            if (nextBtn) {
                nextBtn.onclick = function() {
                    if (window.currentPointIndex < flightLog.data.length - 1) {
                        window.currentPointIndex++;
                        window.updatePointDisplay();
                    }
                };
            }
            
            // Add tab switching
            const tabs = popup.querySelectorAll('.flight-log-popup-tab');
            tabs.forEach(tab => {
                tab.onclick = function() {
                    const tabName = this.getAttribute('data-tab');
                    
                    // Update tab active state
                    tabs.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Update tab content visibility
                    const infoTab = popup.querySelector('#infoTab');
                    const messagesTab = popup.querySelector('#messagesTab');
                    const analyticsTab = popup.querySelector('#analyticsTab');
                    
                    if (tabName === 'info') {
                        if (infoTab) infoTab.classList.add('active');
                        if (messagesTab) messagesTab.classList.remove('active');
                        if (analyticsTab) analyticsTab.classList.remove('active');
                    } else if (tabName === 'messages') {
                        if (infoTab) infoTab.classList.remove('active');
                        if (messagesTab) messagesTab.classList.add('active');
                        if (analyticsTab) analyticsTab.classList.remove('active');
                    } else if (tabName === 'analytics') {
                        if (infoTab) infoTab.classList.remove('active');
                        if (messagesTab) messagesTab.classList.remove('active');
                        if (analyticsTab) analyticsTab.classList.add('active');
                    }
                };
            });
            
            // Add close button handler
            const closeBtn = popup.querySelector('.flight-log-popup-close');
            if (closeBtn) {
                closeBtn.onclick = closePopup;
            }
            
            // Add to page
            document.body.appendChild(overlay);
            document.body.appendChild(popup);
        }
        window.showFlightLogPopup = showFlightLogPopup;
        
        // Helper function to calculate smart Y-axis min/max
        function calculateSmartYAxis(dataArray) {
            if (!dataArray || dataArray.length === 0) {
                return { min: 0, max: 100 };
            }
            
            // Filter out invalid values
            const validData = dataArray.filter(v => v !== null && v !== undefined && !isNaN(v));
            if (validData.length === 0) {
                return { min: 0, max: 100 };
            }
            
            const min = Math.min(...validData);
            const max = Math.max(...validData);
            
            // If all values are the same, add some padding
            if (min === max) {
                const padding = Math.abs(min) * 0.1 || 1;
                return { min: min - padding, max: max + padding };
            }
            
            // Add 10% padding above and below
            const range = max - min;
            const padding = range * 0.1;
            
            return {
                min: Math.max(0, min - padding), // Don't go below 0 for most metrics
                max: max + padding
            };
        }
        
        // Initialize analytics charts
        function initializeAnalyticsCharts(flightLog) {
            if (!flightLog || !flightLog.data || flightLog.data.length === 0) return;
            
            // Zoom plugin removed - charts are no longer zoomable
            
            const data = flightLog.data;
            const homePoint = data[0];
            
            // Prepare time data (x-axis)
            const timeLabels = data.map((point, index) => {
                if (flightLog.stats && flightLog.stats.duration) {
                    const durationStr = flightLog.stats.duration;
                    const match = durationStr.match(/(\d+)m\s*(\d+)s/);
                    if (match) {
                        const totalSeconds = parseInt(match[1]) * 60 + parseInt(match[2]);
                        const timeAtPoint = (index / data.length) * totalSeconds;
                        const minutes = Math.floor(timeAtPoint / 60);
                        const seconds = Math.floor(timeAtPoint % 60);
                        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                }
                return index.toString();
            });
            
            // Altitude chart
            const altitudeCtx = document.getElementById('altitudeChart');
            if (altitudeCtx) {
                const altitudeData = data.map(p => p.altitude || 0);
                const yAxis = calculateSmartYAxis(altitudeData);
                new Chart(altitudeCtx, {
                    type: 'line',
                    data: {
                        labels: timeLabels,
                        datasets: [{
                            label: 'Altitude (m)',
                            data: altitudeData,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            borderWidth: 1,
                            pointRadius: 0,
                            pointHoverRadius: 3,
                            tension: 0.1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: { 
                                min: yAxis.min,
                                max: yAxis.max
                            }
                        }
                    }
                });
            }
            
            // Speed chart
            const speedCtx = document.getElementById('speedChart');
            if (speedCtx) {
                const speedData = data.map(p => p.speed || 0);
                const yAxis = calculateSmartYAxis(speedData);
                new Chart(speedCtx, {
                    type: 'line',
                    data: {
                        labels: timeLabels,
                        datasets: [{
                            label: 'Speed (m/s)',
                            data: speedData,
                            borderColor: 'rgb(255, 99, 132)',
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            borderWidth: 1,
                            pointRadius: 0,
                            pointHoverRadius: 3,
                            tension: 0.1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: { 
                                min: yAxis.min,
                                max: yAxis.max
                            }
                        }
                    }
                });
            }
            
            // Distance from home chart
            const distanceCtx = document.getElementById('distanceChart');
            if (distanceCtx) {
                const distanceData = data.map(p => {
                    if (homePoint) {
                        return calculateHorizontalDistance(homePoint.lat, homePoint.lng, p.lat, p.lng);
                    }
                    return 0;
                });
                const yAxis = calculateSmartYAxis(distanceData);
                new Chart(distanceCtx, {
                    type: 'line',
                    data: {
                        labels: timeLabels,
                        datasets: [{
                            label: 'Distance from Home (m)',
                            data: distanceData,
                            borderColor: 'rgb(54, 162, 235)',
                            backgroundColor: 'rgba(54, 162, 235, 0.2)',
                            borderWidth: 1,
                            pointRadius: 0,
                            pointHoverRadius: 3,
                            tension: 0.1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: { 
                                min: yAxis.min,
                                max: yAxis.max
                            }
                        }
                    }
                });
            }
            
            // Gimbal direction chart
            const gimbalCtx = document.getElementById('gimbalChart');
            if (gimbalCtx) {
                // Find gimbal columns - try multiple common column name patterns
                const gimbalYawIndex = flightLog.headers ? flightLog.headers.findIndex(h => {
                    const header = h.toLowerCase().trim();
                    return /gimbal.*yaw|yaw.*gimbal|gimbalyaw|osd\.gimbalyaw|gimbal\.yaw/i.test(header);
                }) : -1;
                const gimbalPitchIndex = flightLog.headers ? flightLog.headers.findIndex(h => {
                    const header = h.toLowerCase().trim();
                    return /gimbal.*pitch|pitch.*gimbal|gimbalpitch|osd\.gimbalpitch|gimbal\.pitch/i.test(header);
                }) : -1;
                
                // Debug: log what we found
                if (gimbalPitchIndex >= 0) {
                    console.log('Found gimbal pitch column:', flightLog.headers[gimbalPitchIndex], 'at index:', gimbalPitchIndex);
                }
                if (gimbalYawIndex >= 0) {
                    console.log('Found gimbal yaw column:', flightLog.headers[gimbalYawIndex], 'at index:', gimbalYawIndex);
                }
                
                if (gimbalYawIndex >= 0 || gimbalPitchIndex >= 0) {
                    // Extract gimbal pitch data
                    let gimbalPitchData = [];
                    if (gimbalPitchIndex >= 0) {
                        gimbalPitchData = data.map((p, index) => {
                            const row = flightLog.allData[index];
                            if (!row || !row[gimbalPitchIndex]) return null;
                            const value = parseFloat(row[gimbalPitchIndex]);
                            return isNaN(value) ? null : value;
                        }).filter(v => v !== null);
                        
                        // If all values are null/NaN, try without filter to see raw data
                        if (gimbalPitchData.length === 0 && data.length > 0) {
                            const rawData = data.map((p, index) => {
                                const row = flightLog.allData[index];
                                return row ? row[gimbalPitchIndex] : null;
                            });
                            console.log('Gimbal pitch raw data sample (first 10):', rawData.slice(0, 10));
                        } else {
                            console.log('Gimbal pitch data range:', Math.min(...gimbalPitchData), 'to', Math.max(...gimbalPitchData));
                        }
                    }
                    
                    // Extract gimbal yaw data
                    let gimbalYawData = [];
                    if (gimbalYawIndex >= 0) {
                        gimbalYawData = data.map((p, index) => {
                            const row = flightLog.allData[index];
                            if (!row || !row[gimbalYawIndex]) return null;
                            const value = parseFloat(row[gimbalYawIndex]);
                            return isNaN(value) ? null : value;
                        }).filter(v => v !== null);
                    }
                    
                    const gimbalDatasets = [
                        gimbalYawIndex >= 0 ? {
                            label: 'Gimbal Yaw (°)',
                            data: data.map((p, index) => {
                                const row = flightLog.allData[index];
                                if (!row || !row[gimbalYawIndex]) return null;
                                const value = parseFloat(row[gimbalYawIndex]);
                                return isNaN(value) ? null : value;
                            }),
                            borderColor: 'rgb(255, 206, 86)',
                            backgroundColor: 'rgba(255, 206, 86, 0.2)',
                            borderWidth: 1,
                            pointRadius: 0,
                            pointHoverRadius: 3,
                            tension: 0.1,
                            spanGaps: true
                        } : null,
                        gimbalPitchIndex >= 0 ? {
                            label: 'Gimbal Pitch (°)',
                            data: data.map((p, index) => {
                                const row = flightLog.allData[index];
                                if (!row || !row[gimbalPitchIndex]) return null;
                                const value = parseFloat(row[gimbalPitchIndex]);
                                return isNaN(value) ? null : value;
                            }),
                            borderColor: 'rgb(153, 102, 255)',
                            backgroundColor: 'rgba(153, 102, 255, 0.2)',
                            borderWidth: 1,
                            pointRadius: 0,
                            pointHoverRadius: 3,
                            tension: 0.1,
                            spanGaps: true
                        } : null
                    ].filter(d => d !== null);
                    
                    // Calculate Y-axis from all valid data points
                    const allGimbalData = [];
                    gimbalDatasets.forEach(dataset => {
                        dataset.data.forEach(val => {
                            if (val !== null && !isNaN(val)) {
                                allGimbalData.push(val);
                            }
                        });
                    });
                    
                    let yAxis;
                    if (allGimbalData.length === 0) {
                        // No valid data found
                        yAxis = { min: -90, max: 90 }; // Default range for gimbal angles
                        gimbalCtx.parentElement.innerHTML = '<div style="color: #888; padding: 20px;">Gimbal data column found but contains no valid numeric values</div>';
                        return;
                    } else {
                        // Calculate Y-axis allowing negative values for gimbal angles
                        const min = Math.min(...allGimbalData);
                        const max = Math.max(...allGimbalData);
                        const range = max - min;
                        const padding = range === 0 ? 5 : range * 0.1; // 10% padding, or 5 degrees if all same
                        
                        yAxis = {
                            min: Math.max(-90, min - padding), // Allow negative, but clamp to -90
                            max: Math.min(90, max + padding)   // Clamp to 90 degrees max
                        };
                        
                        // If range is still too small after padding, ensure minimum range
                        if (yAxis.max - yAxis.min < 5) {
                            const mean = (min + max) / 2;
                            yAxis.min = Math.max(-90, mean - 10);
                            yAxis.max = Math.min(90, mean + 10);
                        }
                    }
                    
                    new Chart(gimbalCtx, {
                        type: 'line',
                        data: {
                            labels: timeLabels,
                            datasets: gimbalDatasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    display: true,
                                    title: {
                                        display: true,
                                        text: 'Time'
                                    }
                                },
                                y: { 
                                    min: yAxis.min,
                                    max: yAxis.max,
                                    title: {
                                        display: true,
                                        text: 'Angle (°)'
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'top'
                                },
                                tooltip: {
                                    mode: 'index',
                                    intersect: false
                                }
                            }
                        }
                    });
                } else {
                    gimbalCtx.parentElement.innerHTML = '<div style="color: #888; padding: 20px;">No gimbal data columns found. Available columns: ' + (flightLog.headers ? flightLog.headers.filter(h => /gimbal/i.test(h)).join(', ') || 'none' : 'none') + '</div>';
                }
            }
            
            // Battery level chart
            const batteryCtx = document.getElementById('batteryChart');
            if (batteryCtx) {
                const batteryIndex = flightLog.headers ? flightLog.headers.findIndex(h => 
                    /battery.*level|battery.*percent|battery.*%/i.test(h)) : -1;
                
                if (batteryIndex >= 0) {
                    const batteryData = data.map((p, index) => {
                        const row = flightLog.allData[index];
                        return row && row[batteryIndex] ? parseFloat(row[batteryIndex]) : 0;
                    });
                    
                    const yAxis = calculateSmartYAxis(batteryData);
                    
                    new Chart(batteryCtx, {
                        type: 'line',
                        data: {
                            labels: timeLabels,
                            datasets: [{
                                label: 'Battery Level (%)',
                                data: batteryData,
                                borderColor: 'rgb(255, 99, 132)',
                                backgroundColor: 'rgba(255, 99, 132, 0.2)',
                                borderWidth: 1,
                                pointRadius: 0,
                                pointHoverRadius: 3,
                                tension: 0.1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    display: true,
                                    title: {
                                        display: true,
                                        text: 'Time'
                                    }
                                },
                                y: { 
                                    min: yAxis.min,
                                    max: yAxis.max,
                                    title: {
                                        display: true,
                                        text: 'Battery Level (%)'
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'top'
                                },
                                tooltip: {
                                    mode: 'index',
                                    intersect: false
                                }
                            }
                        }
                    });
                } else {
                    batteryCtx.parentElement.innerHTML = '<div style="color: #888; padding: 20px;">No battery data available</div>';
                }
            }
            
            // Battery temperature chart
            const batteryTempCtx = document.getElementById('batteryTempChart');
            if (batteryTempCtx) {
                const batteryTempIndex = flightLog.headers ? flightLog.headers.findIndex(h => 
                    /battery.*temp|temp.*battery/i.test(h)) : -1;
                
                if (batteryTempIndex >= 0) {
                    const batteryTempData = data.map((p, index) => {
                        const row = flightLog.allData[index];
                        return row && row[batteryTempIndex] ? parseFloat(row[batteryTempIndex]) : 0;
                    });
                    const yAxis = calculateSmartYAxis(batteryTempData);
                    new Chart(batteryTempCtx, {
                        type: 'line',
                        data: {
                            labels: timeLabels,
                            datasets: [{
                                label: 'Battery Temperature (°C)',
                                data: batteryTempData,
                                borderColor: 'rgb(255, 159, 64)',
                                backgroundColor: 'rgba(255, 159, 64, 0.2)',
                                borderWidth: 1,
                                pointRadius: 0,
                                pointHoverRadius: 3,
                                tension: 0.1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: { 
                                    min: yAxis.min,
                                    max: yAxis.max
                                }
                            }
                        }
                    });
                } else {
                    batteryTempCtx.parentElement.innerHTML = '<div style="color: #888; padding: 20px;">No battery temperature data available</div>';
                }
            }
        }

        // New parsing functions that return objects for multiple flight logs
        function parseKMLFlightLogToObject(xmlText, fileName) {
            try {
                // Parse XML
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                
                // Check for parsing errors
                const parseError = xmlDoc.querySelector('parsererror');
                if (parseError) {
                    const errorText = parseError.textContent || 'Unknown parsing error';
                    console.error('KML Parse Error:', errorText);
                    showToast('Error parsing KML file: ' + errorText);
                    return null;
                }

                // Find the LineString with coordinates
                const placemarks = xmlDoc.querySelectorAll('Placemark');
                let coordinatesText = null;
                let flightName = fileName.replace(/\.(kml|txt|csv)$/i, '');

                // Look for Placemark with LineString (flight path)
                for (const placemark of placemarks) {
                    const name = placemark.querySelector('name');
                    const lineString = placemark.querySelector('LineString');
                    
                    if (lineString) {
                        const coords = lineString.querySelector('coordinates');
                        if (coords && coords.textContent) {
                            coordinatesText = coords.textContent.trim();
                            if (name) {
                                flightName = name.textContent;
                            }
                            break;
                        }
                    }
                }

                if (!coordinatesText) {
                    console.error('No flight path found in KML file');
                    showToast('No flight path found in KML file');
                    return null;
                }

                // Parse coordinates - format is: lng,lat,alt (space or newline separated)
                const coordLines = coordinatesText.split(/[\s\n]+/).filter(line => line.trim());
                const data = [];

                for (let i = 0; i < coordLines.length; i++) {
                    const line = coordLines[i].trim();
                    if (!line) continue;

                    const parts = line.split(',');
                    if (parts.length >= 2) {
                        const lng = parseFloat(parts[0]);
                        const lat = parseFloat(parts[1]);
                        const alt = parts.length >= 3 ? parseFloat(parts[2]) : 0;

                        if (isNaN(lat) || isNaN(lng)) continue;

                        // KML doesn't have timestamps, so we'll use index-based time
                        const point = {
                            lat: lat,
                            lng: lng,
                            altitude: alt,
                            time: i, // Use index as time (seconds)
                            index: i
                        };

                        data.push(point);
                    }
                }

                if (data.length === 0) {
                    console.error('No valid coordinates found in KML file');
                    showToast('No valid coordinates found in KML file');
                    return null;
                }

                // Calculate flight times and distance
                const startTime = 0;
                const endTime = data.length - 1;
                let totalDistance = 0;
                for (let i = 1; i < data.length; i++) {
                    totalDistance += calculateDistance(
                        data[i-1].lat, data[i-1].lng,
                        data[i].lat, data[i].lng
                    );
                }

                return {
                    name: flightName,
                    fileName: fileName,
                    data: data,
                    headers: [],
                    allData: [],
                    messages: [],
                    stats: {
                        distance: totalDistance,
                        duration: formatTime(data.length),
                        startTime: startTime,
                        endTime: endTime
                    }
                };
            } catch (error) {
                console.error('Error parsing KML flight log:', error);
                showToast('Error parsing KML file: ' + error.message);
                return null;
            }
        }

        function parseDJIFlightLogToObject(text, fileName) {
            try {
                const lines = text.split('\n').filter(line => line.trim());
                if (lines.length === 0) {
                    showToast('Flight log file is empty');
                    return null;
                }

                // Try to detect format - DJI logs typically have headers
                const headerLine = lines[0];
                const isTabDelimited = headerLine.includes('\t');
                const delimiter = isTabDelimited ? '\t' : ',';

                // Parse header
                const headers = headerLine.split(delimiter).map(h => h.trim());
                
                // Find column indices
                const latIndex = findColumnIndex(headers, ['OSD.latitude', 'latitude', 'lat', 'GPS.latitude']);
                const lngIndex = findColumnIndex(headers, ['OSD.longitude', 'longitude', 'lng', 'lon', 'GPS.longitude']);
                const timeIndex = findColumnIndex(headers, ['OSD.flyTime', 'flyTime', 'time', 'timestamp', 'OSD.time']);
                const altIndex = findColumnIndex(headers, ['OSD.height', 'height', 'altitude', 'alt', 'OSD.altitude']);
                const messageIndex = findColumnIndex(headers, ['message', 'Message', 'MSG', 'msg', 'messages', 'Messages']);
                const aircraftIndex = findColumnIndex(headers, ['OSD.aircraftName', 'OSD.droneType', 'OSD.modelName', 'aircraft', 'Aircraft', 'drone', 'Drone', 'model', 'Model', 'aircraftType', 'AircraftType', 'OSD.aircraftType', 'OSD.droneName', 'droneName', 'DroneName']);

                if (latIndex === -1 || lngIndex === -1) {
                    console.error('Could not find latitude/longitude columns in flight log');
                    showToast('Could not find latitude/longitude columns in flight log');
                    return null;
                }

                // Parse data rows
                const data = [];
                const allData = [];
                const messages = [];
                
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(delimiter).map(v => v.trim());
                    const lat = parseFloat(values[latIndex]);
                    const lng = parseFloat(values[lngIndex]);

                    if (isNaN(lat) || isNaN(lng)) continue;

                    const pointTime = timeIndex !== -1 ? parseFloat(values[timeIndex]) || i : i;
                    
                    const point = {
                        lat: lat,
                        lng: lng,
                        time: pointTime,
                        altitude: altIndex !== -1 ? parseFloat(values[altIndex]) || 0 : 0,
                        index: i - 1
                    };

                    data.push(point);
                    allData.push(values); // Store all column values
                    
                    // Capture messages if available
                    if (messageIndex !== -1 && values[messageIndex] && values[messageIndex].trim()) {
                        messages.push({
                            time: pointTime, // Store raw time
                            text: values[messageIndex].trim(),
                            index: i - 1,
                            dataIndex: data.length // Store position in data array (before this point is added)
                        });
                    }
                }

                if (data.length === 0) {
                    console.error('No valid flight data found in log file');
                    showToast('No valid flight data found in log file');
                    return null;
                }

                // Calculate flight times and distance
                const startTime = data[0].time;
                const endTime = data[data.length - 1].time;
                const duration = endTime - startTime;
                
                let totalDistance = 0;
                for (let i = 1; i < data.length; i++) {
                    totalDistance += calculateDistance(
                        data[i-1].lat, data[i-1].lng,
                        data[i].lat, data[i].lng
                    );
                }

                const flightName = fileName.replace(/\.(txt|csv|kml)$/i, '');
                
                // Extract aircraft name from first data row if available
                let aircraftName = null;
                if (aircraftIndex !== -1 && allData.length > 0 && allData[0][aircraftIndex]) {
                    aircraftName = allData[0][aircraftIndex].trim();
                }

                return {
                    name: flightName,
                    fileName: fileName,
                    data: data,
                    headers: headers,
                    allData: allData,
                    messages: messages,
                    aircraftName: aircraftName,
                    stats: {
                        distance: totalDistance,
                        duration: formatTime(duration / 1000), // Convert to seconds if needed
                        startTime: startTime,
                        endTime: endTime
                    }
                };
            } catch (error) {
                console.error('Error parsing flight log:', error);
                showToast('Error parsing flight log: ' + error.message);
                return null;
            }
        }

        // Keep original functions for backward compatibility
        function parseKMLFlightLog(xmlText) {
            try {
                // Parse XML
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                
                // Check for parsing errors
                const parseError = xmlDoc.querySelector('parsererror');
                if (parseError) {
                    const errorText = parseError.textContent || 'Unknown parsing error';
                    console.error('KML Parse Error:', errorText);
                    showToast('Error parsing KML file: ' + errorText);
                    return;
                }

                // Find the LineString with coordinates
                const placemarks = xmlDoc.querySelectorAll('Placemark');
                let coordinatesText = null;
                let flightName = 'Flight';

                // Look for Placemark with LineString (flight path)
                for (const placemark of placemarks) {
                    const name = placemark.querySelector('name');
                    const lineString = placemark.querySelector('LineString');
                    
                    if (lineString) {
                        const coords = lineString.querySelector('coordinates');
                        if (coords && coords.textContent) {
                            coordinatesText = coords.textContent.trim();
                            if (name) {
                                flightName = name.textContent;
                            }
                            break;
                        }
                    }
                }

                if (!coordinatesText) {
                    console.error('No flight path found in KML file');
                    showToast('No flight path found in KML file');
                    return;
                }

                // Parse coordinates - format is: lng,lat,alt (space or newline separated)
                const coordLines = coordinatesText.split(/[\s\n]+/).filter(line => line.trim());
                flightLogData = [];

                for (let i = 0; i < coordLines.length; i++) {
                    const line = coordLines[i].trim();
                    if (!line) continue;

                    const parts = line.split(',');
                    if (parts.length >= 2) {
                        const lng = parseFloat(parts[0]);
                        const lat = parseFloat(parts[1]);
                        const alt = parts.length >= 3 ? parseFloat(parts[2]) : 0;

                        if (isNaN(lat) || isNaN(lng)) continue;

                        // KML doesn't have timestamps, so we'll use index-based time
                        // Assuming 1 second per point (can be adjusted)
                        const point = {
                            lat: lat,
                            lng: lng,
                            altitude: alt,
                            time: i, // Use index as time (seconds)
                            index: i
                        };

                        flightLogData.push(point);
                    }
                }

                if (flightLogData.length === 0) {
                    console.error('No valid coordinates found in KML file');
                    showToast('No valid coordinates found in KML file');
                    return;
                }

                // Calculate flight times
                flightStartTime = 0;
                flightEndTime = flightLogData.length - 1;
                const duration = flightLogData.length; // Duration in "points" (assume 1 point = 1 second)

                // Update UI (with null checks)
                const flightPointsEl = document.getElementById('flightPoints');
                const flightDistanceEl = document.getElementById('flightDistance');
                const flightTotalTimeEl = document.getElementById('flightTotalTime');
                const timelineSliderEl = document.getElementById('timelineSlider');
                
                if (flightPointsEl) flightPointsEl.textContent = flightLogData.length;
                
                // Calculate total distance
                let totalDistance = 0;
                for (let i = 1; i < flightLogData.length; i++) {
                    totalDistance += calculateDistance(
                        flightLogData[i-1].lat, flightLogData[i-1].lng,
                        flightLogData[i].lat, flightLogData[i].lng
                    );
                }
                if (flightDistanceEl) flightDistanceEl.textContent = totalDistance.toFixed(2) + ' km';
                
                // Calculate and display total time in minutes:seconds format
                if (flightLogData.length > 0) {
                    flightStartTime = flightLogData[0].time;
                    flightEndTime = flightLogData[flightLogData.length - 1].time;
                    const duration = flightEndTime - flightStartTime;
                    const totalTimeSeconds = duration / 1000; // Convert milliseconds to seconds
                    const minutes = Math.floor(totalTimeSeconds / 60);
                    const seconds = Math.floor(totalTimeSeconds % 60);
                    if (flightTotalTimeEl) flightTotalTimeEl.textContent = `${minutes}m ${seconds}s`;
                }

                // Draw flight path
                drawFlightPath();

                // Initialize timeline
                if (timelineSliderEl) {
                    timelineSliderEl.max = flightLogData.length - 1;
                    timelineSliderEl.value = 0;
                    updateTimelineSliderProgress();
                }

                // Activate node
                const arrayStatusEl = document.getElementById('arrayStatus');
                if (arrayStatusEl) arrayStatusEl.textContent = 'ACTIVE';
                updateNodePopupsWithDistance();

                // Set checkbox to actual drone location
                const actualCheckbox = document.getElementById('actualDroneCheckbox');
                if (actualCheckbox) {
                    actualCheckbox.checked = true;
                }
                
                // Update toggle visibility based on loaded data
                updateToggleVisibility();

                // Initialize marker at start position and zoom to EDSB sensor location
                if (flightLogData.length > 0) {
                    // Update flight position first to create the marker
                    updateFlightPosition(0);
                    // Zoom to EDSB sensor location with very close zoom level
                    if (map) {
                        // Use setTimeout to ensure marker is created before zooming
                        setTimeout(() => {
                            console.log('Zooming to EDSB sensor location:', ACOUSTIC_ARRAY.lat, ACOUSTIC_ARRAY.lng, 'at zoom level 20');
                            map.setView([ACOUSTIC_ARRAY.lat, ACOUSTIC_ARRAY.lng], 20, { animate: false });
                            // Force a second zoom to ensure it takes effect
                            setTimeout(() => {
                                map.setView([ACOUSTIC_ARRAY.lat, ACOUSTIC_ARRAY.lng], 20, { animate: false });
                            }, 50);
                        }, 200);
                    }
                } else if (map) {
                    // Fallback to acoustic array if no flight data
                    map.setView([ACOUSTIC_ARRAY.lat, ACOUSTIC_ARRAY.lng], 20);
                }

                console.log(`Parsed ${flightLogData.length} KML flight log points from: ${flightName}`);
                console.log('First point:', flightLogData[0]);
                console.log('Last point:', flightLogData[flightLogData.length - 1]);
            } catch (error) {
                console.error('Error parsing KML flight log:', error);
                console.error('Error stack:', error.stack);
                // Don't show alert popup, just log to console
            }
        }

        function parseDJIFlightLog(text) {
            try {
                const lines = text.split('\n').filter(line => line.trim());
                if (lines.length === 0) {
                    alert('Flight log file is empty');
                    return;
                }

                // Try to detect format - DJI logs typically have headers
                const headerLine = lines[0];
                const isTabDelimited = headerLine.includes('\t');
                const delimiter = isTabDelimited ? '\t' : ',';

                // Parse header
                const headers = headerLine.split(delimiter).map(h => h.trim());
                
                // Find column indices
                const latIndex = findColumnIndex(headers, ['OSD.latitude', 'latitude', 'lat', 'GPS.latitude']);
                const lngIndex = findColumnIndex(headers, ['OSD.longitude', 'longitude', 'lng', 'lon', 'GPS.longitude']);
                const timeIndex = findColumnIndex(headers, ['OSD.flyTime', 'flyTime', 'time', 'timestamp', 'OSD.time']);
                const altIndex = findColumnIndex(headers, ['OSD.height', 'height', 'altitude', 'alt', 'OSD.altitude']);

                if (latIndex === -1 || lngIndex === -1) {
                    console.error('Could not find latitude/longitude columns in flight log');
                    showToast('Could not find latitude/longitude columns in flight log');
                    return;
                }

                // Parse data rows
                flightLogData = [];
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(delimiter).map(v => v.trim());
                    const lat = parseFloat(values[latIndex]);
                    const lng = parseFloat(values[lngIndex]);

                    if (isNaN(lat) || isNaN(lng)) continue;

                    const point = {
                        lat: lat,
                        lng: lng,
                        time: timeIndex !== -1 ? parseFloat(values[timeIndex]) || i : i,
                        altitude: altIndex !== -1 ? parseFloat(values[altIndex]) || 0 : 0,
                        index: i - 1
                    };

                    flightLogData.push(point);
                }

                if (flightLogData.length === 0) {
                    console.error('No valid flight data found in log file');
                    showToast('No valid flight data found in log file');
                    return;
                }

                // Calculate flight times
                flightStartTime = flightLogData[0].time;
                flightEndTime = flightLogData[flightLogData.length - 1].time;
                const duration = flightEndTime - flightStartTime;

                // Update UI (with null checks)
                const flightPointsEl = document.getElementById('flightPoints');
                const flightDistanceEl = document.getElementById('flightDistance');
                const flightTotalTimeEl = document.getElementById('flightTotalTime');
                const timelineSliderEl = document.getElementById('timelineSlider');
                
                if (flightPointsEl) flightPointsEl.textContent = flightLogData.length;
                
                // Calculate total distance
                let totalDistance = 0;
                for (let i = 1; i < flightLogData.length; i++) {
                    totalDistance += calculateDistance(
                        flightLogData[i-1].lat, flightLogData[i-1].lng,
                        flightLogData[i].lat, flightLogData[i].lng
                    );
                }
                if (flightDistanceEl) flightDistanceEl.textContent = totalDistance.toFixed(2) + ' km';
                
                // Calculate and display total time in minutes:seconds format
                if (flightLogData.length > 0) {
                    flightStartTime = flightLogData[0].time;
                    flightEndTime = flightLogData[flightLogData.length - 1].time;
                    const duration = flightEndTime - flightStartTime;
                    const totalTimeSeconds = duration / 1000; // Convert milliseconds to seconds
                    const minutes = Math.floor(totalTimeSeconds / 60);
                    const seconds = Math.floor(totalTimeSeconds % 60);
                    if (flightTotalTimeEl) flightTotalTimeEl.textContent = `${minutes}m ${seconds}s`;
                }

                // Draw flight path
                drawFlightPath();

                // Initialize timeline
                if (timelineSliderEl) {
                    timelineSliderEl.max = flightLogData.length - 1;
                    timelineSliderEl.value = 0;
                    updateTimelineSliderProgress();
                }

                // Activate node
                const arrayStatusEl = document.getElementById('arrayStatus');
                if (arrayStatusEl) arrayStatusEl.textContent = 'ACTIVE';
                updateNodePopupsWithDistance();

                // Set checkbox to actual drone location
                const actualCheckbox = document.getElementById('actualDroneCheckbox');
                if (actualCheckbox) {
                    actualCheckbox.checked = true;
                }
                
                // Update toggle visibility based on loaded data
                updateToggleVisibility();
                
                // Update download button pulse
                updateDownloadButtonPulse();

                // Initialize marker at start position and zoom to EDSB sensor location
                if (flightLogData.length > 0) {
                    // Update flight position first to create the marker
                    updateFlightPosition(0);
                    // Zoom to EDSB sensor location with very close zoom level
                    if (map) {
                        // Use setTimeout to ensure marker is created before zooming
                        setTimeout(() => {
                            console.log('Zooming to EDSB sensor location:', ACOUSTIC_ARRAY.lat, ACOUSTIC_ARRAY.lng, 'at zoom level 20');
                            map.setView([ACOUSTIC_ARRAY.lat, ACOUSTIC_ARRAY.lng], 20, { animate: false });
                            // Force a second zoom to ensure it takes effect
                            setTimeout(() => {
                                map.setView([ACOUSTIC_ARRAY.lat, ACOUSTIC_ARRAY.lng], 20, { animate: false });
                            }, 50);
                        }, 200);
                    }
                } else if (map) {
                    // Fallback to acoustic array if no flight data
                    map.setView([ACOUSTIC_ARRAY.lat, ACOUSTIC_ARRAY.lng], 20);
                }

                console.log(`Parsed ${flightLogData.length} flight log points`);
            } catch (error) {
                console.error('Error parsing flight log:', error);
                // Don't show alert popup, just log to console
            }
        }

        function findColumnIndex(headers, possibleNames) {
            for (const name of possibleNames) {
                const index = headers.findIndex(h => h.toLowerCase().includes(name.toLowerCase()));
                if (index !== -1) return index;
            }
            return -1;
        }

        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}m ${secs}s`;
        }

        function formatTimeHMS(timeValue) {
            // Handle different time formats (seconds, milliseconds, or timestamp)
            let totalSeconds;
            if (timeValue > 1000000) {
                // Likely a timestamp in milliseconds
                totalSeconds = timeValue / 1000;
            } else {
                // Likely already in seconds
                totalSeconds = timeValue;
            }
            
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = Math.floor(totalSeconds % 60);
            
            // Format with leading zeros
            const h = hours.toString().padStart(2, '0');
            const m = minutes.toString().padStart(2, '0');
            const s = seconds.toString().padStart(2, '0');
            
            return `${h}:${m}:${s}`;
        }

        function drawFlightPath() {
            // Remove existing path
            if (flightPath) {
                map.removeLayer(flightPath);
            }

            if (flightLogData.length === 0) return;

            // Create polyline from flight data
            const coordinates = flightLogData.map(point => [point.lat, point.lng]);
            flightPath = L.polyline(coordinates, {
                color: '#5a8a6a',
                weight: 2,
                opacity: 0.7
            });
            
            // Only add to map if toggle is active (Show Track is enabled)
            const toggle = document.getElementById('toggleTrack');
            if (toggle && toggle.classList.contains('active')) {
                flightPath.addTo(map);
            }
        }

        function centerMapOnFlight() {
            if (flightLogData.length === 0) return;

            const bounds = flightLogData.map(point => [point.lat, point.lng]);
            map.fitBounds(bounds, { padding: [50, 50] });
        }
        
        function updateTriangulationLines(droneLat, droneLng) {
            // Remove all existing triangulation lines
            triangulationLines.forEach(line => {
                if (map.hasLayer(line)) {
                    map.removeLayer(line);
                }
            });
            triangulationLines = [];
            
            if (!triangulationLinesVisible) {
                return; // Don't create lines if triangulation is hidden
            }
            
            // Get all node positions
            const allNodes = [];
            
            // Add main acoustic node if it exists
            if (acousticNode) {
                allNodes.push({
                    lat: ACOUSTIC_ARRAY.lat,
                    lng: ACOUSTIC_ARRAY.lng
                });
            }
            
            // Add all detection nodes
            detectionNodes.forEach(node => {
                allNodes.push({
                    lat: node.lat,
                    lng: node.lng
                });
            });
            
            // Create triangulation lines from each node through the drone location
            // Only draw lines for nodes within detection range (300m)
            allNodes.forEach(node => {
                // Calculate distance using Haversine formula
                const distance = calculateHorizontalDistance(node.lat, node.lng, droneLat, droneLng);
                
                // Only create triangulation line if node is within detection range
                if (distance > MAX_DETECTION_DISTANCE) {
                    return; // Skip this node - out of range
                }
                
                // Calculate bearing from node to drone
                const deltaLat = droneLat - node.lat;
                const deltaLng = droneLng - node.lng;
                
                // Extend line past drone (extend by 50% of distance)
                const extensionFactor = 1.5;
                const extendedDistance = distance * extensionFactor;
                
                // Calculate extended point
                const bearingRad = Math.atan2(
                    deltaLng * Math.cos(node.lat * Math.PI / 180),
                    deltaLat
                );
                
                const extendedDeltaLat = (extendedDistance * Math.cos(bearingRad)) / 111000;
                const extendedDeltaLng = (extendedDistance * Math.sin(bearingRad)) / (111000 * Math.cos(node.lat * Math.PI / 180));
                
                const extendedLat = node.lat + extendedDeltaLat;
                const extendedLng = node.lng + extendedDeltaLng;
                
                // Create line from node through drone to extended point
                const line = L.polyline(
                    [[node.lat, node.lng], [droneLat, droneLng], [extendedLat, extendedLng]],
                    {
                        color: '#8B0000',
                        weight: 4,
                        opacity: 0.8,
                        dashArray: '8, 4',
                        className: 'triangulation-line'
                    }
                );
                
                if (triangulationLinesVisible) {
                    line.addTo(map);
                }
                
                triangulationLines.push(line);
            });
        }
        
        function toggleTriangulationLines() {
            triangulationLinesVisible = !triangulationLinesVisible;
            const toggle = document.getElementById('toggleTriangulation');
            
            if (!toggle) {
                console.error('Toggle triangulation element not found');
                return;
            }
            
            if (triangulationLinesVisible) {
                toggle.classList.add('active');
                // Show all triangulation lines
                triangulationLines.forEach(line => {
                    if (!map.hasLayer(line)) {
                        line.addTo(map);
                    }
                });
                // Update lines if drone marker exists
                // flightMarker removed - triangulation lines use current flight log position
                if (flightLogData && flightLogData.length > 0 && currentIndex < flightLogData.length) {
                    const currentPoint = flightLogData[currentIndex];
                    updateTriangulationLines(currentPoint.lat, currentPoint.lng);
                }
                console.log('Triangulation lines shown');
            } else {
                toggle.classList.remove('active');
                // Hide all triangulation lines
                triangulationLines.forEach(line => {
                    if (map.hasLayer(line)) {
                        map.removeLayer(line);
                    }
                });
                console.log('Triangulation lines hidden');
            }
        }
        
        // Make function available globally
        window.toggleTriangulationLines = toggleTriangulationLines;
        
        function toggleAcousticTriangulationLine() {
            acousticTriangulationLineVisible = !acousticTriangulationLineVisible;
            const toggle = document.getElementById('toggleAcousticTriangulation');
            
            if (!toggle) {
                console.error('Toggle acoustic triangulation element not found');
                return;
            }
            
            if (acousticTriangulationLineVisible) {
                toggle.classList.add('active');
                // Show acoustic triangulation line if it exists
                if (acousticEstimateTriangulationLine && !map.hasLayer(acousticEstimateTriangulationLine)) {
                    acousticEstimateTriangulationLine.addTo(map);
                }
                // Update display if acoustic estimate data exists
                if (acousticEstimateData && acousticEstimateData.length > 0) {
                    const currentIndex = parseInt(document.getElementById('acousticTimelineSlider').value) || 0;
                    updateAcousticEstimateDisplay(currentIndex);
                }
                console.log('Acoustic triangulation line shown');
            } else {
                toggle.classList.remove('active');
                // Hide acoustic triangulation line
                if (acousticEstimateTriangulationLine && map.hasLayer(acousticEstimateTriangulationLine)) {
                    map.removeLayer(acousticEstimateTriangulationLine);
                }
                console.log('Acoustic triangulation line hidden');
            }
            
            // Update legend if open
            if (legendVisible) {
                updateLegendVisibility();
            }
        }
        window.toggleAcousticTriangulationLine = toggleAcousticTriangulationLine;
        
        function toggleDroneDirectionalIndicator() {
            droneDirectionalIndicatorVisible = !droneDirectionalIndicatorVisible;
            const toggle = document.getElementById('toggleDroneDirectional');
            
            if (!toggle) {
                console.error('Toggle drone directional element not found');
                return;
            }
            
            if (droneDirectionalIndicatorVisible) {
                toggle.classList.add('active');
                // Update directional indicators if drone marker exists
                // flightMarker removed - directional indicators use current flight log position
                if (flightLogData && flightLogData.length > 0 && currentIndex < flightLogData.length) {
                    const currentPoint = flightLogData[currentIndex];
                    updateDirectionIndicator({ lat: currentPoint.lat, lng: currentPoint.lng });
                }
                console.log('Drone directional indicators shown');
            } else {
                toggle.classList.remove('active');
                // Hide all drone directional indicators
                if (currentDirectionWedge) {
                    map.removeLayer(currentDirectionWedge);
                }
                Object.keys(nodeDirectionWedges).forEach(nodeId => {
                    if (nodeDirectionWedges[nodeId]) {
                        map.removeLayer(nodeDirectionWedges[nodeId]);
                    }
                });
                console.log('Drone directional indicators hidden');
            }
        }
        window.toggleDroneDirectionalIndicator = toggleDroneDirectionalIndicator;
        
        function toggleAcousticDirectionalIndicator() {
            acousticDirectionalIndicatorVisible = !acousticDirectionalIndicatorVisible;
            const toggle = document.getElementById('toggleAcousticDirectional');
            
            if (!toggle) {
                console.error('Toggle acoustic directional element not found');
                return;
            }
            
            if (acousticDirectionalIndicatorVisible) {
                toggle.classList.add('active');
                // Update acoustic directional indicator if data exists
                if (acousticEstimateData && acousticEstimateData.length > 0) {
                    const currentIndex = parseInt(document.getElementById('acousticTimelineSlider').value) || 0;
                    updateAcousticEstimateDisplay(currentIndex);
                }
                console.log('Acoustic directional indicator shown');
            } else {
                toggle.classList.remove('active');
                // Hide acoustic directional indicator
                if (acousticEstimateDirectionWedge && map.hasLayer(acousticEstimateDirectionWedge)) {
                    map.removeLayer(acousticEstimateDirectionWedge);
                }
                console.log('Acoustic directional indicator hidden');
            }
        }
        window.toggleAcousticDirectionalIndicator = toggleAcousticDirectionalIndicator;
        
        function updateDroneLabel(lat, lng) {
            if (!droneLabelVisible) {
                // Remove label and pointer line if they exist and toggle is off
                if (droneLabel) {
                    if (map.hasLayer(droneLabel)) {
                        map.removeLayer(droneLabel);
                    }
                    if (droneLabel._pointerLine && map.hasLayer(droneLabel._pointerLine)) {
                        map.removeLayer(droneLabel._pointerLine);
                    }
                }
                return;
            }
            
            // Get actual drone marker position if it exists, otherwise use provided coordinates
            let droneLat = lat;
            let droneLng = lng;
            if (flightMarker && map.hasLayer(flightMarker)) {
                const markerPos = flightMarker.getLatLng();
                droneLat = markerPos.lat;
                droneLng = markerPos.lng;
            }
            
            // Calculate offset position for label (to the right of drone)
            const offsetLat = 0; // No vertical offset
            const offsetLng = 0.00015; // Small offset to the right (~15 meters)
            const labelLat = droneLat + offsetLat;
            const labelLng = droneLng + offsetLng;
            
            // If label already exists, update its position instead of recreating
            if (droneLabel && map.hasLayer(droneLabel)) {
                // Update label position
                droneLabel.setLatLng([labelLat, labelLng]);
                
                // Update pointer line
                if (droneLabel._pointerLine && map.hasLayer(droneLabel._pointerLine)) {
                    droneLabel._pointerLine.setLatLngs([[labelLat, labelLng], [droneLat, droneLng]]);
                } else {
                    // Create pointer line if it doesn't exist
                    const pointerLine = L.polyline(
                        [[labelLat, labelLng], [droneLat, droneLng]],
                        {
                            color: '#DC143C',
                            weight: 1,
                            opacity: 0.4,
                            dashArray: '2, 4',
                            className: 'drone-label-line'
                        }
                    );
                    pointerLine.addTo(map);
                    droneLabel._pointerLine = pointerLine;
                }
                
                // Update label text if altitude changed
                let altitudeText = '';
                if (showDroneAltitude && flightLogData && flightLogData.length > 0) {
                    const homePoint = flightLogData[0];
                    const homeAltitude = homePoint.altitude || 0;
                    
                    let currentAltitude = 0;
                    if (currentIndex < flightLogData.length) {
                        const currentPoint = flightLogData[currentIndex];
                        currentAltitude = currentPoint.altitude || 0;
                    }
                    
                    const altitudeAboveHome = currentAltitude - homeAltitude;
                    altitudeText = `${Math.round(altitudeAboveHome)}m`;
                }
                
                const labelText = altitudeText ? `DRONE LOCATION ${altitudeText} ↑` : 'DRONE LOCATION';
                const labelIcon = L.divIcon({
                    className: 'drone-label-container',
                    html: `<div class="drone-label-pointer"></div><div class="drone-label">${labelText}</div>`,
                    iconSize: [160, 20],
                    iconAnchor: [0, 10]
                });
                droneLabel.setIcon(labelIcon);
                
                // Store updated position
                droneLabel._droneLat = droneLat;
                droneLabel._droneLng = droneLng;
                
                return; // Exit early, label updated
            }
            
            // Remove existing label and pointer line if they exist (for recreation)
            if (droneLabel) {
                if (map.hasLayer(droneLabel)) {
                    map.removeLayer(droneLabel);
                }
                if (droneLabel._pointerLine && map.hasLayer(droneLabel._pointerLine)) {
                    map.removeLayer(droneLabel._pointerLine);
                }
            }
            
            // Get current point data to find altitude above home point
            let altitudeText = '';
            if (showDroneAltitude && flightLogData && flightLogData.length > 0) {
                const homePoint = flightLogData[0];
                const homeAltitude = homePoint.altitude || 0;
                
                // Use current flight log position
                let currentAltitude = 0;
                if (currentIndex < flightLogData.length) {
                    const currentPoint = flightLogData[currentIndex];
                    currentAltitude = currentPoint.altitude || 0;
                }
                
                // Calculate altitude above home point
                const altitudeAboveHome = currentAltitude - homeAltitude;
                altitudeText = `${Math.round(altitudeAboveHome)}m`;
            }
            
            // Create new label with pointer line - show altitude if available
            const labelText = altitudeText ? `DRONE LOCATION ${altitudeText} ↑` : 'DRONE LOCATION';
            const labelIcon = L.divIcon({
                className: 'drone-label-container',
                html: `<div class="drone-label-pointer"></div><div class="drone-label">${labelText}</div>`,
                iconSize: [160, 20],
                iconAnchor: [0, 10]
            });
            
            droneLabel = L.marker([labelLat, labelLng], {
                icon: labelIcon,
                zIndexOffset: 3000,
                interactive: false
            });
            
            // Create connecting line from label to actual drone position
            const pointerLine = L.polyline(
                [[labelLat, labelLng], [droneLat, droneLng]],
                {
                    color: '#DC143C',
                    weight: 1,
                    opacity: 0.4,
                    dashArray: '2, 4',
                    className: 'drone-label-line'
                }
            );
            
            droneLabel.addTo(map);
            pointerLine.addTo(map);
            
            // Store pointer line and position with label for updates
            droneLabel._pointerLine = pointerLine;
            droneLabel._droneLat = droneLat;
            droneLabel._droneLng = droneLng;
        }
        
        function toggleDroneLabel() {
            droneLabelVisible = !droneLabelVisible;
            const toggle = document.getElementById('toggleDroneLabel');
            
            if (!toggle) {
                console.error('Toggle drone label element not found');
                return;
            }
            
            if (droneLabelVisible) {
                toggle.classList.add('active');
                // Show label if drone marker exists
                // flightMarker removed - drone label uses current flight log position
                if (flightLogData && flightLogData.length > 0 && currentIndex < flightLogData.length) {
                    const currentPoint = flightLogData[currentIndex];
                    updateDroneLabel(currentPoint.lat, currentPoint.lng);
                }
                console.log('Drone label shown');
            } else {
                toggle.classList.remove('active');
                // Hide label and pointer line
                if (droneLabel) {
                    if (map.hasLayer(droneLabel)) {
                        map.removeLayer(droneLabel);
                    }
                    if (droneLabel._pointerLine && map.hasLayer(droneLabel._pointerLine)) {
                        map.removeLayer(droneLabel._pointerLine);
                    }
                }
                console.log('Drone label hidden');
            }
        }
        
        // Make function available globally
        window.toggleDroneLabel = toggleDroneLabel;
        
        function toggleDroneAltitude() {
            showDroneAltitude = !showDroneAltitude;
            const toggle = document.getElementById('toggleDroneAltitude');
            
            if (!toggle) {
                console.error('Toggle drone altitude element not found');
                return;
            }
            
            if (showDroneAltitude) {
                toggle.classList.add('active');
            } else {
                toggle.classList.remove('active');
            }
            
            // Update drone label if visible
            // flightMarker removed - drone label uses current flight log position
            if (flightLogData && flightLogData.length > 0 && currentIndex < flightLogData.length && droneLabelVisible) {
                const currentPoint = flightLogData[currentIndex];
                updateDroneLabel(currentPoint.lat, currentPoint.lng);
            }
        }
        window.toggleDroneAltitude = toggleDroneAltitude;
        
        function toggleHomePointLabel() {
            showHomePointLabel = !showHomePointLabel;
            const toggle = document.getElementById('toggleHomePointLabel');
            
            if (!toggle) {
                console.error('Toggle home point label element not found');
                return;
            }
            
            if (showHomePointLabel) {
                toggle.classList.add('active');
            } else {
                toggle.classList.remove('active');
            }
            
            // Update home point label if home point exists and is visible
            if (showHomePoint && homePointMarker && homePointMarker._latlng) {
                updateHomePointLabel(homePointMarker._latlng);
            } else if (!showHomePointLabel && homePointLabel) {
                // Hide label if toggle is off
                if (map.hasLayer(homePointLabel)) {
                    map.removeLayer(homePointLabel);
                }
                if (homePointLabel._pointerLine && map.hasLayer(homePointLabel._pointerLine)) {
                    map.removeLayer(homePointLabel._pointerLine);
                }
            }
        }
        window.toggleHomePointLabel = toggleHomePointLabel;
        
        // Function to update/create label for the acoustic array node (Sensor 1)
        function updateAcousticNodeLabel() {
            if (!nodeLabelsVisible || !acousticNode) return;
            
            // Remove existing label and pointer line if they exist
            if (acousticNode.label) {
                if (map.hasLayer(acousticNode.label)) {
                    map.removeLayer(acousticNode.label);
                }
                if (acousticNode.labelPointerLine && map.hasLayer(acousticNode.labelPointerLine)) {
                    map.removeLayer(acousticNode.labelPointerLine);
                }
            }
            // Remove proximity marker if it exists
            if (acousticNode.proximityMarker && map.hasLayer(acousticNode.proximityMarker)) {
                map.removeLayer(acousticNode.proximityMarker);
            }
            
            // Calculate offset position for label (to the right of node)
            const offsetLat = 0; // No vertical offset
            const offsetLng = 0.00015; // Small offset to the right (~15 meters)
            const labelLat = ACOUSTIC_ARRAY.lat + offsetLat;
            const labelLng = ACOUSTIC_ARRAY.lng + offsetLng;
            
            // Calculate where the pointer triangle tip is (right edge of pointer, which is 8px wide)
            // Pointer is 8px wide, gap is 8px, so pointer tip is 16px from left edge of icon
            // Convert to longitude offset
            const pointerTipOffsetLng = 0.000015; // Small offset for pointer tip position (~1.5 meters)
            
            // Calculate distance from home point if toggle is on
            let distanceText = '';
            if (showDistanceFromHome && flightLogData && flightLogData.length > 0 && currentIndex < flightLogData.length) {
                // Use current flight log position
                const currentPoint = flightLogData[currentIndex];
                // Use first point of flight log as home point
                const homePoint = flightLogData[0];
                const distance = calculateHorizontalDistance(homePoint.lat, homePoint.lng, currentPoint.lat, currentPoint.lng);
                
                distanceText = `<div class="node-label-distance">${Math.round(distance)}m</div>`;
            }
            
            // Create new label with pointer line - match drone label structure exactly
            // Include proximity text in same container so it's positioned relative to label (pixel-based, not geographic)
            const labelText = `<div class="node-label"><span class="node-label-text">EDSB SENSOR 1</span></div>`;
            const proximityHtml = showDistanceFromHome && distanceText ? distanceText : '';
            const containerHtml = `<div class="node-label-wrapper"><div class="node-label-row-simple"><div class="node-label-pointer"></div>${labelText}</div>${proximityHtml}</div>`;
            const iconHeight = showDistanceFromHome && distanceText ? 38 : 20;
            const labelIcon = L.divIcon({
                className: 'node-label-container-with-proximity',
                html: containerHtml,
                iconSize: [200, iconHeight],
                iconAnchor: [0, 10] // Anchor at left edge, vertically centered at 10px (center of label row)
            });
            
            const label = L.marker([labelLat, labelLng], {
                icon: labelIcon,
                zIndexOffset: 2000,
                interactive: false
            });
            
            // Create connecting line from label to node - simple horizontal line like drone label
            const pointerLine = L.polyline(
                [[labelLat, labelLng], [ACOUSTIC_ARRAY.lat, ACOUSTIC_ARRAY.lng]],
                {
                    color: '#4A9B9D',
                    weight: 1,
                    opacity: 0.4,
                    dashArray: '2, 4',
                    className: 'node-label-line'
                }
            );
            
            label.addTo(map);
            pointerLine.addTo(map);
            
            // Store label and pointer line with acoustic node
            acousticNode.label = label;
            acousticNode.labelPointerLine = pointerLine;
        }
        
        // Function to update/create label for a specific detection node (starting at Sensor 2)
        function updateNodeLabel(nodeId) {
            if (!nodeLabelsVisible) return;
            
            const node = detectionNodes.find(n => n.id === nodeId);
            if (!node) return;
            
            // Remove existing label and pointer line if they exist
            if (node.label) {
                if (map.hasLayer(node.label)) {
                    map.removeLayer(node.label);
                }
                if (node.labelPointerLine && map.hasLayer(node.labelPointerLine)) {
                    map.removeLayer(node.labelPointerLine);
                }
            }
            // Remove proximity marker if it exists
            if (node.proximityMarker && map.hasLayer(node.proximityMarker)) {
                map.removeLayer(node.proximityMarker);
            }
            
            // Calculate offset position for label (to the right of node)
            const offsetLat = 0; // No vertical offset
            const offsetLng = 0.00015; // Small offset to the right (~15 meters)
            const labelLat = node.lat + offsetLat;
            const labelLng = node.lng + offsetLng;
            
            // Detection nodes start at Sensor 2 (since acoustic array is Sensor 1)
            const sensorNumber = nodeId + 2;
            
            // Calculate distance from home point if toggle is on
            let distanceText = '';
            if (showDistanceFromHome && flightLogData && flightLogData.length > 0 && currentIndex < flightLogData.length) {
                // Use current flight log position
                const currentPoint = flightLogData[currentIndex];
                // Use first point of flight log as home point
                const homePoint = flightLogData[0];
                const distance = calculateHorizontalDistance(homePoint.lat, homePoint.lng, currentPoint.lat, currentPoint.lng);
                
                distanceText = `<div class="node-label-distance">${Math.round(distance)}m</div>`;
            }
            
            // Create new label with pointer line - match drone label structure exactly
            // Include proximity text in same container so it's positioned relative to label (pixel-based, not geographic)
            const labelText = `<div class="node-label"><span class="node-label-text">EDSB SENSOR ${sensorNumber}</span></div>`;
            const proximityHtml = showDistanceFromHome && distanceText ? distanceText : '';
            const containerHtml = `<div class="node-label-wrapper"><div class="node-label-row-simple"><div class="node-label-pointer"></div>${labelText}</div>${proximityHtml}</div>`;
            const iconHeight = showDistanceFromHome && distanceText ? 38 : 20;
            const labelIcon = L.divIcon({
                className: 'node-label-container-with-proximity',
                html: containerHtml,
                iconSize: [200, iconHeight],
                iconAnchor: [0, 10] // Anchor at left edge, vertically centered at 10px (center of label row)
            });
            
            const label = L.marker([labelLat, labelLng], {
                icon: labelIcon,
                zIndexOffset: 2000,
                interactive: false
            });
            
            // Create connecting line from label to node - simple horizontal line like drone label
            const pointerLine = L.polyline(
                [[labelLat, labelLng], [node.lat, node.lng]],
                {
                    color: '#4A9B9D',
                    weight: 1,
                    opacity: 0.4,
                    dashArray: '2, 4',
                    className: 'node-label-line'
                }
            );
            
            label.addTo(map);
            pointerLine.addTo(map);
            
            // Store label and pointer line with node
            node.label = label;
            node.labelPointerLine = pointerLine;
        }
        
        // Function to update all node labels
        function updateAllNodeLabels() {
            if (!nodeLabelsVisible) {
                // Remove acoustic array label if toggle is off
                if (acousticNode && acousticNode.label) {
                    if (map.hasLayer(acousticNode.label)) {
                        map.removeLayer(acousticNode.label);
                    }
                    if (acousticNode.labelPointerLine && map.hasLayer(acousticNode.labelPointerLine)) {
                        map.removeLayer(acousticNode.labelPointerLine);
                    }
                }
                // Remove all detection node labels if toggle is off
                detectionNodes.forEach(node => {
                    if (node.label && map.hasLayer(node.label)) {
                        map.removeLayer(node.label);
                    }
                    if (node.labelPointerLine && map.hasLayer(node.labelPointerLine)) {
                        map.removeLayer(node.labelPointerLine);
                    }
                });
                return;
            }
            
            // Create/update acoustic array label (Sensor 1)
            updateAcousticNodeLabel();
            
            // Create/update labels for all detection nodes (starting at Sensor 2)
            detectionNodes.forEach(node => {
                updateNodeLabel(node.id);
            });
        }
        
        // Toggle function for node labels
        function toggleNodeLabels() {
            nodeLabelsVisible = !nodeLabelsVisible;
            const toggle = document.getElementById('toggleNodeLabel');
            
            if (!toggle) {
                console.error('Toggle node label element not found');
                return;
            }
            
            if (nodeLabelsVisible) {
                toggle.classList.add('active');
                updateAllNodeLabels();
                console.log('Node labels shown');
            } else {
                toggle.classList.remove('active');
                updateAllNodeLabels();
                console.log('Node labels hidden');
            }
        }
        
        // Make function available globally
        window.toggleNodeLabels = toggleNodeLabels;
        
        function toggleDistanceFromHome() {
            showDistanceFromHome = !showDistanceFromHome;
            const toggle = document.getElementById('toggleDistanceFromHome');
            
            if (!toggle) {
                console.error('Toggle distance from home element not found');
                return;
            }
            
            if (showDistanceFromHome) {
                toggle.classList.add('active');
                // Update all node labels to show distance
                if (nodeLabelsVisible) {
                    updateAllNodeLabels();
                }
                console.log('Distance from home point shown');
            } else {
                toggle.classList.remove('active');
                // Update all node labels to hide distance
                if (nodeLabelsVisible) {
                    updateAllNodeLabels();
                }
                console.log('Distance from home point hidden');
            }
        }
        window.toggleDistanceFromHome = toggleDistanceFromHome;
        
        // createFlightMarker function completely removed - drone location marker code removed
        
        // Create/update drone location marker - replicating MQTT branch implementation
        function createFlightMarker(point) {
            // Ensure we have valid coordinates
            if (!point || isNaN(point.lat) || isNaN(point.lng)) {
                console.error('Invalid point coordinates:', point);
                return;
            }

            if (flightMarker) {
                // Update existing marker position - no offsets, use exact coordinates like MQTT branch
                flightMarker.setLatLng([point.lat, point.lng]);
                flightMarker._point = point;
                
                // Verify position after update
                const markerPos = flightMarker.getLatLng();
                console.log('Updated marker to:', markerPos.lat, markerPos.lng, 'Expected:', point.lat, point.lng);
                
                // Update popup content with coordinates
                const timeDisplay = typeof point.time === 'number' && point.time > 1000000
                    ? formatTime(point.time - flightStartTime)
                    : formatTime(point.time);
                const latFormatted = point.lat.toFixed(6);
                const lngFormatted = point.lng.toFixed(6);
                flightMarker.setPopupContent(`
                    <div style="
                        font-family: 'Courier New', monospace;
                        font-size: 11px;
                        color: #a0a0a0;
                        background: #0a0a0a;
                        padding: 5px;
                    ">
                        <strong style="color: #d4a574;">Drone Position</strong><br>
                        <span>Coordinates:</span><br>
                        <span>Lat: ${latFormatted}</span><br>
                        <span>Lng: ${lngFormatted}</span><br>
                        <span>Time: ${timeDisplay}</span><br>
                        <span>ALT: ${point.altitude ? point.altitude.toFixed(1) : '0.0'}m</span>
                    </div>
                `);
                return;
            }

            // Create new marker - smaller red circle with pulsing ring for drone location
            const droneIcon = L.divIcon({
                className: 'home-point-marker',
                html: '<div class="drone-location-pulse"></div><div class="drone-location-circle"></div>',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });

            console.log('Creating flight marker at coordinates:', point.lat, point.lng);
            flightMarker = L.marker([point.lat, point.lng], { 
                icon: droneIcon,
                zIndexOffset: 2000,
                draggable: false,
                interactive: true
            });
            flightMarker._point = point;
            flightMarker.addTo(map);
            
            // Verify the marker is at the correct position
            const markerPos = flightMarker.getLatLng();
            console.log('Marker created at:', markerPos.lat, markerPos.lng);
            console.log('Expected position:', point.lat, point.lng);
            console.log('Position match:', markerPos.lat === point.lat && markerPos.lng === point.lng);
            
            // Update drone label if visible
            if (droneLabelVisible) {
                updateDroneLabel(point.lat, point.lng);
            }
            
            // Format coordinates for popup
            const latFormatted = point.lat.toFixed(6);
            const lngFormatted = point.lng.toFixed(6);
            
            flightMarker.bindPopup(`
                <div style="
                    font-family: 'Courier New', monospace;
                    font-size: 11px;
                    color: #a0a0a0;
                    background: #0a0a0a;
                    padding: 5px;
                ">
                    <strong style="color: #d4a574;">Drone Position</strong><br>
                    <span>Coordinates:</span><br>
                    <span>Lat: ${latFormatted}</span><br>
                    <span>Lng: ${lngFormatted}</span><br>
                    <span>Time: ${formatTime(point.time - flightStartTime)}</span><br>
                    <span>ALT: ${point.altitude ? point.altitude.toFixed(1) : '0.0'}m</span>
                </div>
            `);
        }
        
        // Create home point marker
        function createHomePointMarker(homePoint) {
            // Remove existing home point marker if it exists
            if (homePointMarker) {
                if (map.hasLayer(homePointMarker)) {
                    map.removeLayer(homePointMarker);
                }
                if (homePointLabel && map.hasLayer(homePointLabel)) {
                    map.removeLayer(homePointLabel);
                    if (homePointLabel._pointerLine && map.hasLayer(homePointLabel._pointerLine)) {
                        map.removeLayer(homePointLabel._pointerLine);
                    }
                }
            }
            
            // Create home point marker (green circle)
            const homeIcon = L.divIcon({
                className: 'home-point-marker',
                html: '<div class="home-point-circle"></div>',
                iconSize: [12, 12],
                iconAnchor: [6, 6]
            });
            
            homePointMarker = L.marker([homePoint.lat, homePoint.lng], {
                icon: homeIcon,
                zIndexOffset: 1999
            });
            
            // Only add to map if toggle is on
            if (showHomePoint) {
                homePointMarker.addTo(map);
            }
            
            // Create home point label if both toggles are on
            if (showHomePointLabel && showHomePoint) {
                updateHomePointLabel(homePoint);
            }
        }
        
        // Toggle home point visibility
        function toggleHomePointVisibility() {
            showHomePoint = !showHomePoint;
            const toggle = document.getElementById('toggleHomePoint');
            
            if (!toggle) {
                console.error('Toggle home point element not found');
                return;
            }
            
            toggle.classList.toggle('active');
            
            if (homePointMarker) {
                if (showHomePoint) {
                    if (!map.hasLayer(homePointMarker)) {
                        homePointMarker.addTo(map);
                    }
                    // Show label if label toggle is also on
                    if (showHomePointLabel && homePointMarker._latlng) {
                        updateHomePointLabel(homePointMarker._latlng);
                    }
                } else {
                    if (map.hasLayer(homePointMarker)) {
                        map.removeLayer(homePointMarker);
                    }
                    // Hide label when marker is hidden
                    if (homePointLabel) {
                        if (map.hasLayer(homePointLabel)) {
                            map.removeLayer(homePointLabel);
                        }
                        if (homePointLabel._pointerLine && map.hasLayer(homePointLabel._pointerLine)) {
                            map.removeLayer(homePointLabel._pointerLine);
                        }
                    }
                }
            }
            
            // Update legend if open
            if (legendVisible) {
                updateLegendVisibility();
            }
        }
        window.toggleHomePointVisibility = toggleHomePointVisibility;
        
        // Update home point label
        function updateHomePointLabel(homePoint) {
            if (!showHomePointLabel || !showHomePoint) {
                if (homePointLabel) {
                    if (map.hasLayer(homePointLabel)) {
                        map.removeLayer(homePointLabel);
                    }
                    if (homePointLabel._pointerLine && map.hasLayer(homePointLabel._pointerLine)) {
                        map.removeLayer(homePointLabel._pointerLine);
                    }
                }
                return;
            }
            
            // Calculate offset position for label (to the right of home point)
            const offsetLat = 0;
            const offsetLng = 0.00015;
            const labelLat = homePoint.lat + offsetLat;
            const labelLng = homePoint.lng + offsetLng;
            
            // Calculate horizontal distance from home point to current drone position
            let distanceText = '';
            let arrowDirection = '→'; // Default to right arrow
            
            if (flightLogData && flightLogData.length > 0 && currentIndex < flightLogData.length) {
                // Get current drone position (prefer marker position if available)
                let currentLat, currentLng;
                if (flightMarker && map.hasLayer(flightMarker)) {
                    const markerPos = flightMarker.getLatLng();
                    currentLat = markerPos.lat;
                    currentLng = markerPos.lng;
                } else {
                    const currentPoint = flightLogData[currentIndex];
                    currentLat = currentPoint.lat;
                    currentLng = currentPoint.lng;
                }
                
                // Calculate horizontal distance
                const currentDistance = calculateHorizontalDistance(homePoint.lat, homePoint.lng, currentLat, currentLng);
                distanceText = `${Math.round(currentDistance)}m`;
                
                // Determine arrow direction based on distance change
                if (previousDistanceFromHome !== null) {
                    if (currentDistance > previousDistanceFromHome) {
                        arrowDirection = '→'; // Moving away (distance increasing)
                    } else if (currentDistance < previousDistanceFromHome) {
                        arrowDirection = '←'; // Moving towards (distance decreasing)
                    }
                    // If distance is the same, keep previous arrow direction
                }
                
                // Update previous distance for next comparison
                previousDistanceFromHome = currentDistance;
            } else {
                // Reset previous distance if no flight data
                previousDistanceFromHome = null;
            }
            
            // Create label text with distance and arrow
            const labelText = distanceText ? `HOME POINT ${distanceText} ${arrowDirection}` : 'HOME POINT';
            
            // If label already exists, update it instead of recreating
            if (homePointLabel && map.hasLayer(homePointLabel)) {
                // Update label icon with new text
                const labelIcon = L.divIcon({
                    className: 'home-point-label-container',
                    html: `<div class="home-point-label-pointer"></div><div class="home-point-label">${labelText}</div>`,
                    iconSize: [160, 20],
                    iconAnchor: [0, 10]
                });
                homePointLabel.setIcon(labelIcon);
                
                // Update pointer line if it exists
                if (homePointLabel._pointerLine && map.hasLayer(homePointLabel._pointerLine)) {
                    homePointLabel._pointerLine.setLatLngs([[labelLat, labelLng], [homePoint.lat, homePoint.lng]]);
                }
                
                return; // Exit early, label updated
            }
            
            // Remove existing label if it exists (for recreation)
            if (homePointLabel) {
                if (map.hasLayer(homePointLabel)) {
                    map.removeLayer(homePointLabel);
                }
                if (homePointLabel._pointerLine && map.hasLayer(homePointLabel._pointerLine)) {
                    map.removeLayer(homePointLabel._pointerLine);
                }
            }
            
            // Create new label
            const labelIcon = L.divIcon({
                className: 'home-point-label-container',
                html: `<div class="home-point-label-pointer"></div><div class="home-point-label">${labelText}</div>`,
                iconSize: [160, 20],
                iconAnchor: [0, 10]
            });
            
            homePointLabel = L.marker([labelLat, labelLng], {
                icon: labelIcon,
                zIndexOffset: 2001,
                interactive: false
            });
            
            // Create connecting line from label to home point
            const pointerLine = L.polyline(
                [[labelLat, labelLng], [homePoint.lat, homePoint.lng]],
                {
                    color: '#5a8a6a',
                    weight: 1,
                    opacity: 0.4,
                    dashArray: '2, 4',
                    className: 'home-point-label-line'
                }
            );
            
            homePointLabel.addTo(map);
            pointerLine.addTo(map);
            
            // Store pointer line with label
            homePointLabel._pointerLine = pointerLine;
        }

        function updateFlightPosition(index) {
            if (index < 0 || index >= flightLogData.length) {
                console.warn('Invalid index:', index, 'flightLogData length:', flightLogData.length);
                return;
            }

            currentIndex = index;
            const point = flightLogData[index];
            
            if (!point) {
                console.error('No point at index:', index);
                return;
            }

            console.log('Updating flight position to index:', index, 'coords:', point.lat, point.lng, 'point:', point);

            // Update drone location marker
            createFlightMarker(point);
            
            // Update drone label to follow the marker
            if (droneLabelVisible) {
                // Use a small delay to ensure marker position is updated first
                setTimeout(() => {
                    if (flightMarker && map.hasLayer(flightMarker)) {
                        const markerPos = flightMarker.getLatLng();
                        updateDroneLabel(markerPos.lat, markerPos.lng);
                    } else {
                        updateDroneLabel(point.lat, point.lng);
                    }
                }, 0);
            }
            
            // Update home point label to show distance and direction
            if (showHomePointLabel && showHomePoint && homePointMarker && homePointMarker._latlng) {
                updateHomePointLabel(homePointMarker._latlng);
            }

            // Update timeline
            const progress = (index / (flightLogData.length - 1)) * 100;
            const timelineSlider = document.getElementById('timelineSlider');
            if (timelineSlider) {
                timelineSlider.value = index;
                updateTimelineSliderProgress();
            }

            // Calculate current time for matching (handle both timestamp-based and index-based time)
            const currentTimeRaw = point.time - flightStartTime;
            
            // Check which checkboxes are selected (both can be selected simultaneously)
            const actualCheckbox = document.getElementById('actualDroneCheckbox');
            const acousticCheckbox = document.getElementById('acousticEstimateCheckbox');
            const isActualSelected = actualCheckbox && actualCheckbox.checked;
            const isAcousticSelected = acousticCheckbox && acousticCheckbox.checked;
            
            // Determine if times are in milliseconds by checking if currentTimeRaw > 1000 (unlikely to be > 1000 seconds for current position)
            // or by checking if flightStartTime/point.time are > 1000 (milliseconds)
            const isCurrentTimeMilliseconds = currentTimeRaw > 1000 || (typeof point.time === 'number' && point.time > 1000);
            const currentTime = isCurrentTimeMilliseconds ? currentTimeRaw / 1000 : currentTimeRaw; // Convert to seconds if needed
            
            // Debug logging
            if (isAcousticSelected && acousticEstimateData && acousticEstimateData.length > 0) {
                console.log(`[Playback] Frame ${index}: currentTime=${currentTime.toFixed(2)}s, isAcousticSelected=true, acousticDataLength=${acousticEstimateData.length}`);
            }
            
            // Update direction indicator when we have flight data (only for actual drone)
            const arrayStatusEl = document.getElementById('arrayStatus');
            const isActive = arrayStatusEl && arrayStatusEl.textContent === 'ACTIVE';
            
            // Update actual drone visuals if selected
            if (isActive && point && isActualSelected) {
                // Update direction indicator to point from node to drone (actual location)
                updateDirectionIndicator({lat: point.lat, lng: point.lng});
            } else if (!isActualSelected) {
                // Clear actual drone direction indicator when not selected
                if (currentDirectionWedge) {
                    map.removeLayer(currentDirectionWedge);
                    currentDirectionWedge = null;
                }
            }
            
            // Update acoustic estimate display if acoustic checkbox is selected
            // BUT: Don't override if acoustic playback is running independently
            // Only sync when acoustic playback is paused
            if (isAcousticSelected && acousticEstimateData && acousticEstimateData.length > 0 && !isAcousticPlaying) {
                // Find closest acoustic estimate by time
                // Only search if we have valid flight log time (between 0 and reasonable max)
                let closestIndex = 0;
                let minTimeDiff = Infinity;
                
                // Ensure currentTime is reasonable (not negative or extremely large)
                // Acoustic estimates are typically 0-180 seconds
                if (currentTime >= 0 && currentTime < 10000) {
                    for (let i = 0; i < acousticEstimateData.length; i++) {
                        const timePoint = acousticEstimateData[i];
                        const estimateTime = timePoint.time || 0;
                        const timeDiff = Math.abs(estimateTime - currentTime);
                        if (timeDiff < minTimeDiff) {
                            minTimeDiff = timeDiff;
                            closestIndex = i;
                        }
                    }
                } else {
                    // If time is invalid or out of range, use first index
                    closestIndex = 0;
                }
                
                // Ensure closestIndex is within bounds
                closestIndex = Math.max(0, Math.min(closestIndex, acousticEstimateData.length - 1));
                
                // Update currentAcousticIndex to match the synced position
                currentAcousticIndex = closestIndex;
                
                // Always update acoustic timeline slider during playback (even if time doesn't match perfectly)
                const acousticTimelineSlider = document.getElementById('acousticTimelineSlider');
                if (acousticTimelineSlider) {
                    // Ensure max is set correctly
                    const expectedMax = acousticEstimateData.length - 1;
                    if (parseInt(acousticTimelineSlider.max) !== expectedMax) {
                        acousticTimelineSlider.max = expectedMax;
                    }
                    
                    // Update slider value to match closest index
                    const sliderValue = Math.max(0, Math.min(closestIndex, expectedMax));
                    acousticTimelineSlider.value = sliderValue;
                    updateAcousticTimelineSliderProgress();
                    
                    // Update acoustic estimate display (direction indicator and triangulation line)
                    updateAcousticEstimateDisplay(closestIndex);
                    
                    // Update acoustic time display
                    updateAcousticTimeDisplay(closestIndex);
                    
                    console.log(`[Playback] Acoustic sync: flightTime=${currentTime.toFixed(2)}s, acousticIndex=${closestIndex}, acousticTime=${acousticEstimateData[closestIndex].time}s`);
                } else {
                    console.warn('Acoustic timeline slider not found!');
                }
            } else if (!isAcousticSelected) {
                // Clear acoustic visuals when not selected
                if (acousticEstimateDirectionWedge) {
                    map.removeLayer(acousticEstimateDirectionWedge);
                    acousticEstimateDirectionWedge = null;
                }
                if (acousticEstimateTriangulationLine) {
                    map.removeLayer(acousticEstimateTriangulationLine);
                    acousticEstimateTriangulationLine = null;
                }
            }
            
            if (simulationMode && edsbData) {
                // TDOA timeline removed
                console.log(`TDOA Simulation time: ${currentTime}s`);
            } else if (isActive) {
                // Apply 139-second audio offset: TDOA analysis starts 139s after CSV start
                const tdoaTime = Math.max(0, currentTime - 139.0);
                // TDOA timeline removed
                console.log(`Flight time: ${currentTime}s, TDOA time: ${tdoaTime}s (offset: 139s)`);
            }
            const totalTime = flightEndTime - flightStartTime;
            // Handle both timestamp-based and index-based time
            // Better detection: if totalTime > 1000, it's likely milliseconds (unlikely to have > 1000 second flights)
            const isTotalTimeMilliseconds = totalTime > 1000 || (typeof flightEndTime === 'number' && flightEndTime > 1000);
            
            // Current time is already converted to seconds above
            const displayCurrentTime = currentTime;
            
            // Convert total time to seconds if needed
            const displayTotalTime = isTotalTimeMilliseconds ? totalTime / 1000 : totalTime;
            
            // Ensure we're passing numbers, not strings
            const finalCurrentTime = Number(displayCurrentTime) || 0;
            const finalTotalTime = Number(displayTotalTime) || 0;
            
            document.getElementById('timeDisplay').textContent = 
                `${formatTime(finalCurrentTime)} / ${formatTime(finalTotalTime)}`;
            
            // Update all node popups with distance to drone
            updateNodePopupsWithDistance();
            
            // Update detection bubble states based on drone proximity
            updateDetectionBubbleStates();

            // Update coordinates in info panel
            document.getElementById('currentLat').textContent = point.lat.toFixed(6);
            document.getElementById('currentLng').textContent = point.lng.toFixed(6);
        }

        function toggleFlightLogPlayback() {
            if (flightLogData.length === 0) {
                alert('Please load a flight log first');
                return;
            }

            isPlaying = !isPlaying;
            const button = document.getElementById('playButton');
            
            if (isPlaying) {
                button.textContent = 'PAUSE';
                button.classList.add('playing');
                startFlightLogPlayback();
            } else {
                button.textContent = 'PLAY';
                button.classList.remove('playing');
                stopFlightLogPlayback();
            }
        }

        function startFlightLogPlayback() {
            if (playbackInterval) clearInterval(playbackInterval);
            
            if (flightLogData.length < 2) {
                console.error('Not enough flight log data for playback');
                return;
            }

            // Calculate actual time interval between data points
            // Calculate average time interval between consecutive points first
            let totalTimeDiff = 0;
            let timeDiffCount = 0;
            for (let i = 1; i < flightLogData.length; i++) {
                const prevTime = flightLogData[i - 1].time;
                const currTime = flightLogData[i].time;
                if (currTime > prevTime) {
                    totalTimeDiff += (currTime - prevTime);
                    timeDiffCount++;
                }
            }
            
            // Default to 200ms if we can't calculate (typical DJI log interval)
            const avgTimeInterval = timeDiffCount > 0 ? (totalTimeDiff / timeDiffCount) : 200;
            
            // Determine if times are in milliseconds or seconds
            // If average interval is < 10000 (10 seconds), it's likely milliseconds
            // If average interval is > 1000, it's likely seconds (unlikely for flight logs)
            const isMilliseconds = avgTimeInterval < 10000;
            
            // Convert to milliseconds: if already milliseconds, use as-is; if seconds, multiply by 1000
            const baseIntervalMs = isMilliseconds ? avgTimeInterval : avgTimeInterval * 1000;
            
            // Apply playback speed: at 1x speed, use actual interval; at 0.1x, use 10x longer
            const interval = baseIntervalMs / playbackSpeed;
            
            console.log(`Flight log playback: avgTimeInterval=${avgTimeInterval.toFixed(0)}ms, isMilliseconds=${isMilliseconds}, speed=${playbackSpeed}x, actualInterval=${interval.toFixed(0)}ms`);

            playbackInterval = setInterval(() => {
                if (currentIndex >= flightLogData.length - 1) {
                    stopFlightLogPlayback();
                    return;
                }
                currentIndex++;
                updateFlightPosition(currentIndex);
            }, interval);
        }

        function stopFlightLogPlayback() {
            if (playbackInterval) {
                clearInterval(playbackInterval);
                playbackInterval = null;
            }
        }

        function resetFlightLogPlayback() {
            stopFlightLogPlayback();
            isPlaying = false;
            const button = document.getElementById('playButton');
            if (button) {
                button.textContent = 'PLAY';
                button.classList.remove('playing');
            }
            currentIndex = 0;
            // Reset previous distance from home when resetting playback
            previousDistanceFromHome = null;
            if (flightLogData.length > 0) {
                updateFlightPosition(0);
            }
        }

        function toggleAcousticPlayback() {
            if (!acousticEstimateData || acousticEstimateData.length === 0) {
                alert('Please load an acoustic estimate file first');
                return;
            }

            isAcousticPlaying = !isAcousticPlaying;
            const button = document.getElementById('acousticPlayButton');
            
            if (isAcousticPlaying) {
                button.textContent = 'PAUSE';
                button.classList.add('playing');
                startAcousticPlayback();
            } else {
                button.textContent = 'PLAY';
                button.classList.remove('playing');
                stopAcousticPlayback();
            }
        }

        function startAcousticPlayback() {
            if (acousticPlaybackInterval) clearInterval(acousticPlaybackInterval);
            
            if (!acousticEstimateData || acousticEstimateData.length < 2) {
                console.error('Not enough acoustic estimate data for playback');
                return;
            }

            // Calculate actual time interval between data points
            // Find the average time difference between consecutive points
            let totalTimeDiff = 0;
            let timeDiffCount = 0;
            for (let i = 1; i < acousticEstimateData.length; i++) {
                const prevTime = acousticEstimateData[i - 1].time || 0;
                const currTime = acousticEstimateData[i].time || 0;
                if (currTime > prevTime) {
                    totalTimeDiff += (currTime - prevTime);
                    timeDiffCount++;
                }
            }
            
            // Default to 0.5 seconds if we can't calculate (user mentioned 0.5s increments)
            const avgTimeInterval = timeDiffCount > 0 ? (totalTimeDiff / timeDiffCount) : 0.5;
            
            // Convert time interval (in seconds) to milliseconds, then divide by speed
            // At 1x speed, we want to advance one data point every avgTimeInterval seconds
            const baseIntervalMs = avgTimeInterval * 1000; // Convert to milliseconds
            const interval = baseIntervalMs / acousticPlaybackSpeed;
            
            console.log(`Acoustic playback: avgTimeInterval=${avgTimeInterval.toFixed(3)}s, baseInterval=${baseIntervalMs.toFixed(0)}ms, speed=${acousticPlaybackSpeed}x, actualInterval=${interval.toFixed(0)}ms`);

            acousticPlaybackInterval = setInterval(() => {
                if (currentAcousticIndex >= acousticEstimateData.length - 1) {
                    stopAcousticPlayback();
                    return;
                }
                currentAcousticIndex++;
                updateAcousticEstimateDisplay(currentAcousticIndex);
                updateAcousticTimeDisplay(currentAcousticIndex);
                
                // Update acoustic timeline slider
                const acousticTimelineSlider = document.getElementById('acousticTimelineSlider');
                if (acousticTimelineSlider) {
                    acousticTimelineSlider.value = currentAcousticIndex;
                    updateAcousticTimelineSliderProgress();
                }
            }, interval);
        }

        function stopAcousticPlayback() {
            if (acousticPlaybackInterval) {
                clearInterval(acousticPlaybackInterval);
                acousticPlaybackInterval = null;
            }
        }

        function resetAcousticPlayback() {
            stopAcousticPlayback();
            isAcousticPlaying = false;
            const button = document.getElementById('acousticPlayButton');
            if (button) {
                button.textContent = 'PLAY';
                button.classList.remove('playing');
            }
            currentAcousticIndex = 0;
            if (acousticEstimateData && acousticEstimateData.length > 0) {
                updateAcousticEstimateDisplay(0);
                updateAcousticTimeDisplay(0);
                const acousticTimelineSlider = document.getElementById('acousticTimelineSlider');
                if (acousticTimelineSlider) {
                    acousticTimelineSlider.value = 0;
                    updateAcousticTimelineSliderProgress();
                }
            }
        }

        function updateSpeed(value) {
            playbackSpeed = parseFloat(value);
            document.getElementById('speedValue').textContent = playbackSpeed.toFixed(1) + 'x';
            
            // Restart playback with new speed if playing (flight log only)
            if (isPlaying) {
                stopFlightLogPlayback();
                startFlightLogPlayback();
            }
        }

        function updateAcousticSpeed(value) {
            acousticPlaybackSpeed = parseFloat(value);
            document.getElementById('acousticSpeedValue').textContent = acousticPlaybackSpeed.toFixed(1) + 'x';
            
            // Restart playback with new speed if playing (acoustic estimate only)
            if (isAcousticPlaying) {
                stopAcousticPlayback();
                startAcousticPlayback();
            }
        }

        function updateTimelineSliderProgress() {
            const slider = document.getElementById('timelineSlider');
            if (!slider) return;
            
            const value = parseFloat(slider.value) || 0;
            const max = parseFloat(slider.max) || 100;
            const percent = max > 0 ? (value / max) * 100 : 0;
            
            // Update the track pseudo-element via injected style
            const styleId = 'timeline-slider-track-style';
            let styleEl = document.getElementById(styleId);
            if (!styleEl) {
                styleEl = document.createElement('style');
                styleEl.id = styleId;
                document.head.appendChild(styleEl);
            }
            styleEl.textContent = `#timelineSlider::-webkit-slider-runnable-track { background: linear-gradient(to right, #4a7c59 0%, #4a7c59 ${percent}%, #1a1a1a ${percent}%) !important; }`;
        }

        function scrubTimeline(value) {
            const index = parseInt(value);
            if (index >= 0 && index < flightLogData.length) {
                currentIndex = index;
                updateFlightPosition(index);
                updateTimelineSliderProgress();
            }
        }

        function updateAcousticTimelineSliderProgress() {
            const slider = document.getElementById('acousticTimelineSlider');
            if (!slider) return;
            
            const value = parseFloat(slider.value) || 0;
            const max = parseFloat(slider.max) || 100;
            const percent = max > 0 ? (value / max) * 100 : 0;
            
            // Update the track pseudo-element via injected style
            const styleId = 'acoustic-timeline-slider-track-style';
            let styleEl = document.getElementById(styleId);
            if (!styleEl) {
                styleEl = document.createElement('style');
                styleEl.id = styleId;
                document.head.appendChild(styleEl);
            }
            styleEl.textContent = `#acousticTimelineSlider::-webkit-slider-runnable-track { background: linear-gradient(to right, #4a7c59 0%, #4a7c59 ${percent}%, #1a1a1a ${percent}%) !important; }`;
        }

        function scrubAcousticTimeline(value) {
            const index = parseInt(value);
            if (acousticEstimateData && index >= 0 && index < acousticEstimateData.length) {
                currentAcousticIndex = index;
                updateAcousticEstimateDisplay(index);
                updateAcousticTimeDisplay(index);
                updateAcousticTimelineSliderProgress();
            }
        }

        function updateAcousticTimeDisplay(index) {
            if (!acousticEstimateData || index < 0 || index >= acousticEstimateData.length) return;
            
            const timePoint = acousticEstimateData[index];
            const currentTime = timePoint.time || 0;
            const maxTime = Math.max(...acousticEstimateData.map(d => d.time));
            
            const acousticTimeDisplay = document.getElementById('acousticTimeDisplay');
            if (acousticTimeDisplay) {
                acousticTimeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(maxTime)}`;
            }
        }
        
        function scrubTdoaTimeline(value) {
            // TDOA timeline removed - function kept for compatibility but does nothing
            return;
            // Convert percentage to TDOA time range
            const maxTdoaTime = Math.max(...TDOA_DIRECTIONS.map(d => d.time));
            const tdoaTime = (parseFloat(value) / 100) * maxTdoaTime;
            
            // Find corresponding flight time (add 139s offset)
            const flightTime = tdoaTime + 139.0;
            
            // Convert flight time to index
            if (flightLogData.length > 0) {
                const targetTime = flightStartTime + flightTime;
                let closestIndex = 0;
                let minDiff = Math.abs(flightLogData[0].time - targetTime);
                
                for (let i = 1; i < flightLogData.length; i++) {
                    const diff = Math.abs(flightLogData[i].time - targetTime);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestIndex = i;
                    }
                }
                
                currentIndex = closestIndex;
                updateFlightPosition(closestIndex);
                
                // Update main timeline to match
                const timelineSlider = document.getElementById('timelineSlider');
                if (timelineSlider) {
                    timelineSlider.value = closestIndex;
                    updateTimelineSliderProgress();
                }
            }
        }
        
        function updateTdoaTimelineDisplay(tdoaTime) {
            // TDOA timeline removed - function kept for compatibility but does nothing
            return;
            if (simulationMode && edsbData && edsbData.tdoaData) {
                const tdoaData = edsbData.tdoaData;
                const maxTdoaTime = Math.max(...tdoaData.chunk_times);
                const percentage = Math.max(0, Math.min(100, (tdoaTime / maxTdoaTime) * 100));
                
                document.getElementById('tdoaTimelineSlider').value = percentage;
                document.getElementById('tdoaTimeDisplay').textContent = 
                    `${formatTime(Math.max(0, tdoaTime))} / ${formatTime(maxTdoaTime)}`;
            } else {
                const maxTdoaTime = Math.max(...TDOA_DIRECTIONS.map(d => d.time));
                const percentage = Math.max(0, Math.min(100, (tdoaTime / maxTdoaTime) * 100));
                
                document.getElementById('tdoaTimelineSlider').value = percentage;
                document.getElementById('tdoaTimeDisplay').textContent = 
                    `${formatTime(Math.max(0, tdoaTime))} / ${formatTime(maxTdoaTime)}`;
            }
        }

        function activateSimulation() {
            if (!simulationMode || !edsbData) {
                console.log('No simulation data available');
                return;
            }
            
            console.log('Activating TDOA simulation...');
            
            // Start playback from beginning
            currentIndex = 0;
            updateFlightPosition(0);
            
            // Start simulation playback
            if (!isPlaying) {
                toggleFlightLogPlayback();
            }
        }

        // Drone Simulator Functions
        async function startDroneSimulator() {
            try {
                // Call /start endpoint
                const response = await fetch('http://localhost:8080/start', {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                simulatorStarted = true;
                document.getElementById('simulatorStatus').textContent = 'RUNNING';
                document.getElementById('simulatorStartButton').textContent = 'RUNNING...';
                document.getElementById('simulatorStartButton').disabled = true;
                
                // Start polling position
                pollDronePosition();
                
                // Poll every 1.5 seconds (between 1-2 seconds)
                simulatorPollInterval = setInterval(pollDronePosition, 1500);
                
            } catch (error) {
                console.error('Error starting drone simulator:', error);
                document.getElementById('simulatorStatus').textContent = 'ERROR';
                alert('Failed to start simulator. Make sure the simulator is running on localhost:8080');
            }
        }

        async function pollDronePosition() {
            try {
                const response = await fetch('http://localhost:8080/position');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Handle null response (flight ended)
                if (!data || data.latitude === null || data.longitude === null) {
                    stopDroneSimulator();
                    document.getElementById('simulatorStatus').textContent = 'COMPLETE';
                    return;
                }
                
                // Extract data (WGS84 decimal degrees)
                const lat = parseFloat(data.latitude);
                const lng = parseFloat(data.longitude);
                const altitude = data.altitude !== null && data.altitude !== undefined ? parseFloat(data.altitude) : 0;
                const progress = data.progress !== null && data.progress !== undefined ? parseFloat(data.progress) : 0;
                
                // Validate coordinates
                if (isNaN(lat) || isNaN(lng)) {
                    console.error('Invalid coordinates:', data);
                    return;
                }
                
                // Update marker position
                // flightMarker removed - simulator no longer shows marker
                
                // Update UI
                document.getElementById('simulatorProgress').textContent = progress.toFixed(1) + '%';
                document.getElementById('simulatorAltitude').textContent = altitude.toFixed(1) + ' m';
                
                // Update all node popups with distance to drone
                updateNodePopupsWithDistance();
                
                // Update detection bubble states based on drone proximity
                updateDetectionBubbleStates();
                
                // Pan map to keep marker in view
                map.setView([lat, lng], map.getZoom(), { animate: true });
                
            } catch (error) {
                console.error('Error polling drone position:', error);
                document.getElementById('simulatorStatus').textContent = 'ERROR';
            }
        }

        function stopDroneSimulator() {
            if (simulatorPollInterval) {
                clearInterval(simulatorPollInterval);
                simulatorPollInterval = null;
            }
            
            simulatorStarted = false;
            document.getElementById('simulatorStatus').textContent = 'IDLE';
            document.getElementById('simulatorStartButton').textContent = 'START SIMULATOR';
            document.getElementById('simulatorStartButton').disabled = false;
        }

        // Node Control Functions
        function togglePlaceNodeMode() {
            placeNodeMode = !placeNodeMode;
            const button = document.getElementById('placeNodeButton');
            
            if (placeNodeMode) {
                button.textContent = 'Done';
                
                // Add click handler to map
                mapClickHandler = function(e) {
                    placeDetectionNode(e.latlng.lat, e.latlng.lng);
                };
                map.on('click', mapClickHandler);
                
                // Change cursor to indicate placement mode
                map.getContainer().style.cursor = 'crosshair';
            } else {
                button.textContent = 'ADD NODE';
                
                // Remove click handler
                if (mapClickHandler) {
                    map.off('click', mapClickHandler);
                    mapClickHandler = null;
                }
                
                // Reset cursor
                map.getContainer().style.cursor = '';
            }
        }

        function placeDetectionNode(lat, lng) {
            // Create purple marker for detection node using acoustic-node-marker style
            const nodeId = detectionNodes.length;
            const icon = L.divIcon({
                className: 'tactical-marker',
                html: `<div class="acoustic-node-marker"></div>`,
                iconSize: [12, 12],
                iconAnchor: [6, 6]
            });
            
            const nodeMarker = L.marker([lat, lng], { icon: icon });
            nodeMarker.addTo(map);
            
            // Store node first
            detectionNodes.push({
                marker: nodeMarker,
                lat: lat,
                lng: lng,
                id: nodeId,
                directionWedge: null,
                label: null,
                labelPointerLine: null
            });
            
            // Set popup content immediately with coordinates and remove button
            const node = detectionNodes[nodeId];
            let distanceText = 'N/A';
            let dronePos = null;
            // flightMarker removed - use current flight log position
            if (flightLogData && flightLogData.length > 0 && currentIndex < flightLogData.length) {
                const currentPoint = flightLogData[currentIndex];
                dronePos = { lat: currentPoint.lat, lng: currentPoint.lng };
                if (dronePos) {
                    const distance = calculateHorizontalDistance(node.lat, node.lng, dronePos.lat, dronePos.lng);
                    distanceText = `${distance.toFixed(1)} m`;
                }
            }
            
            nodeMarker.bindPopup(`
                <div style="
                    font-family: 'Courier New', monospace;
                    font-size: 11px;
                    color: #a0a0a0;
                    background: #0a0a0a;
                    padding: 5px;
                ">
                    <strong style="color: #d4a574;">Detection Node ${node.id + 1}</strong><br>
                    <span>LAT: ${node.lat.toFixed(6)}</span><br>
                    <span>LNG: ${node.lng.toFixed(6)}</span><br>
                    <span style="color: #d4a574;">DISTANCE: ${distanceText}</span><br>
                    <button onclick="removeNode(${node.id})" style="
                        background: #b85450;
                        border: 1px solid #b85450;
                        color: #fff;
                        padding: 3px 8px;
                        font-size: 9px;
                        cursor: pointer;
                        margin-top: 5px;
                    ">REMOVE</button>
                </div>
            `);
            
            // Initialize direction wedge for this node
            nodeDirectionWedges[nodeId] = null;
            
            // Update toggle visibility after adding node
            updateToggleVisibility();
            
            // Create label for this node if labels are visible
            if (nodeLabelsVisible) {
                updateNodeLabel(nodeId);
            }
            
            // Create mesh network connections to all existing nodes
            updateMeshNetwork();
            
            // Update detection bubbles
            updateDetectionBubbles();
            
            // Update node count
            document.getElementById('nodeCount').textContent = detectionNodes.length;
            
            // Update all node popups with distance to drone (to refresh distance if flight log exists)
            updateNodePopupsWithDistance();
            
            // Exit placement mode after placing a node
            if (placeNodeMode) {
                togglePlaceNodeMode();
            }
        }
        
        function updateMeshNetwork() {
            // Remove all existing mesh network lines
            meshNetworkLines.forEach(line => {
                if (map.hasLayer(line)) {
                    map.removeLayer(line);
                }
            });
            meshNetworkLines = [];
            
            // Get all node positions (main acoustic node + detection nodes)
            const allNodes = [];
            
            // Add main acoustic node if it exists
            if (acousticNode) {
                allNodes.push({
                    lat: ACOUSTIC_ARRAY.lat,
                    lng: ACOUSTIC_ARRAY.lng,
                    id: 'main'
                });
            }
            
            // Add all detection nodes
            detectionNodes.forEach(node => {
                allNodes.push({
                    lat: node.lat,
                    lng: node.lng,
                    id: node.id
                });
            });
            
            // Need at least 2 nodes to create connections
            if (allNodes.length < 2) {
                return;
            }
            
            // Create connections between all nodes (mesh network)
            for (let i = 0; i < allNodes.length; i++) {
                for (let j = i + 1; j < allNodes.length; j++) {
                    const node1 = allNodes[i];
                    const node2 = allNodes[j];
                    
                    // Create dotted line between nodes (darker)
                    const line = L.polyline(
                        [[node1.lat, node1.lng], [node2.lat, node2.lng]],
                        {
                            color: '#4A9B9D',
                            weight: 1,
                            opacity: 0.4,
                            dashArray: '5, 10',
                            className: 'mesh-network-line'
                        }
                    );
                    
                    // Add to map if mesh network is visible
                    if (meshNetworkVisible) {
                        line.addTo(map);
                    }
                    
                    meshNetworkLines.push(line);
                }
            }
            
            console.log(`Mesh network updated: ${meshNetworkLines.length} connections between ${allNodes.length} nodes`);
            
            // Update toggle visibility after mesh network update
            updateToggleVisibility();
        }
        
        function toggleMeshNetwork() {
            meshNetworkVisible = !meshNetworkVisible;
            const toggle = document.getElementById('toggleMesh');
            
            if (!toggle) {
                console.error('Toggle mesh element not found');
                return;
            }
            
            if (meshNetworkVisible) {
                toggle.classList.add('active');
                // Show all mesh network lines
                meshNetworkLines.forEach(line => {
                    if (!map.hasLayer(line)) {
                        line.addTo(map);
                    }
                });
                console.log('Mesh network shown:', meshNetworkLines.length, 'lines');
            } else {
                toggle.classList.remove('active');
                // Hide all mesh network lines
                meshNetworkLines.forEach(line => {
                    if (map.hasLayer(line)) {
                        map.removeLayer(line);
                    }
                });
                console.log('Mesh network hidden');
            }
            
            // Update legend if open
            if (legendVisible) {
                updateLegendVisibility();
            }
        }
        
        function updateDetectionBubbles() {
            // Remove all existing detection bubbles
            detectionBubbles.forEach(bubbleData => {
                if (map && map.hasLayer(bubbleData.bubble)) {
                    map.removeLayer(bubbleData.bubble);
                }
            });
            detectionBubbles = [];
            
            // Create detection bubbles for all nodes if toggle is on
            if (!detectionBubblesVisible || !map) {
                return;
            }
            
            // Add bubble for main acoustic node
            if (acousticNode) {
                const bubble = L.circle([ACOUSTIC_ARRAY.lat, ACOUSTIC_ARRAY.lng], {
                    radius: MAX_DETECTION_DISTANCE,
                    color: '#4A9B9D',
                    fillColor: '#4A9B9D',
                    fillOpacity: 0.08,
                    weight: 1,
                    opacity: 0.3,
                    className: 'detection-bubble'
                });
                
                bubble.addTo(map);
                detectionBubbles.push({
                    bubble: bubble,
                    node: null, // null indicates acoustic node
                    lat: ACOUSTIC_ARRAY.lat,
                    lng: ACOUSTIC_ARRAY.lng
                });
            }
            
            // Add bubbles for all detection nodes
            detectionNodes.forEach(node => {
                const bubble = L.circle([node.lat, node.lng], {
                    radius: MAX_DETECTION_DISTANCE,
                    color: '#4A9B9D',
                    fillColor: '#4A9B9D',
                    fillOpacity: 0.08,
                    weight: 1,
                    opacity: 0.3,
                    className: 'detection-bubble'
                });
                
                bubble.addTo(map);
                detectionBubbles.push({
                    bubble: bubble,
                    node: node,
                    lat: node.lat,
                    lng: node.lng
                });
            });
            
            // Update bubble states based on current drone position
            updateDetectionBubbleStates();
            
            console.log(`Detection bubbles updated: ${detectionBubbles.length} bubbles`);
        }

        // Function to update detection bubble states based on drone proximity
        function updateDetectionBubbleStates() {
            if (!detectionBubblesVisible || !map) {
                // Stop animation if bubbles are not visible
                if (bubblePulseAnimationId) {
                    cancelAnimationFrame(bubblePulseAnimationId);
                    bubblePulseAnimationId = null;
                }
                return;
            }

            // Get current drone position
            let dronePos = null;
            // flightMarker removed - use current flight log position instead
            if (flightLogData && flightLogData.length > 0 && currentIndex < flightLogData.length) {
                const currentPoint = flightLogData[currentIndex];
                dronePos = { lat: currentPoint.lat, lng: currentPoint.lng };
            }

            // Track which bubbles need pulsing
            let hasPulsingBubbles = false;

            // Update each bubble based on drone proximity
            detectionBubbles.forEach(bubbleData => {
                const bubble = bubbleData.bubble;
                let isDroneInRange = false;

                if (dronePos) {
                    const distance = calculateHorizontalDistance(
                        bubbleData.lat, 
                        bubbleData.lng, 
                        dronePos.lat, 
                        dronePos.lng
                    );
                    isDroneInRange = distance <= MAX_DETECTION_DISTANCE;
                }

                // Store detection state on bubble data
                bubbleData.isDroneInRange = isDroneInRange;

                // Update bubble styling based on drone proximity
                if (isDroneInRange) {
                    hasPulsingBubbles = true;
                    // Drone is within range - set red color (pulsing will be handled by animation)
                    bubble.setStyle({
                        color: 'rgba(255, 0, 0, 0.6)',
                        fillColor: 'rgba(255, 0, 0, 0.6)',
                        fillOpacity: 0.15,
                        weight: 2,
                        opacity: 0.6
                    });
                } else {
                    // Drone is not in range - normal color
                    bubble.setStyle({
                        color: '#4A9B9D',
                        fillColor: '#4A9B9D',
                        fillOpacity: 0.08,
                        weight: 1,
                        opacity: 0.3
                    });
                }
            });

            // Start or stop pulsing animation
            if (hasPulsingBubbles && !bubblePulseAnimationId) {
                startBubblePulseAnimation();
            } else if (!hasPulsingBubbles && bubblePulseAnimationId) {
                stopBubblePulseAnimation();
            }
        }

        // Function to animate pulsing bubbles
        function startBubblePulseAnimation() {
            if (bubblePulseAnimationId) {
                return; // Already animating
            }

            let startTime = null;
            const pulseDuration = 1500; // 1.5 seconds per pulse cycle

            function animatePulse(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;
                const progress = (elapsed % pulseDuration) / pulseDuration;

                // Calculate opacity: 0.15 to 0.35 (pulsing between these values)
                const minOpacity = 0.15;
                const maxOpacity = 0.35;
                // Use sine wave for smooth pulsing
                const opacity = minOpacity + (maxOpacity - minOpacity) * (0.5 + 0.5 * Math.sin(progress * Math.PI * 2));

                // Update all bubbles that have drone in range
                detectionBubbles.forEach(bubbleData => {
                    if (bubbleData.isDroneInRange) {
                        const bubble = bubbleData.bubble;
                        bubble.setStyle({
                            fillOpacity: opacity,
                            opacity: Math.min(0.6, opacity * 2) // Keep stroke opacity proportional
                        });
                    }
                });

                bubblePulseAnimationId = requestAnimationFrame(animatePulse);
            }

            bubblePulseAnimationId = requestAnimationFrame(animatePulse);
        }

        // Function to stop pulsing animation
        function stopBubblePulseAnimation() {
            if (bubblePulseAnimationId) {
                cancelAnimationFrame(bubblePulseAnimationId);
                bubblePulseAnimationId = null;
            }
        }
        
        function toggleDetectionBubbles() {
            detectionBubblesVisible = !detectionBubblesVisible;
            const toggle = document.getElementById('toggleDetectionBubble');
            
            if (!toggle) {
                console.error('Toggle detection bubble element not found');
                return;
            }
            
            if (detectionBubblesVisible) {
                toggle.classList.add('active');
                updateDetectionBubbles();
                console.log('Detection bubbles shown:', detectionBubbles.length, 'bubbles');
            } else {
                toggle.classList.remove('active');
                // Stop pulsing animation
                stopBubblePulseAnimation();
                // Hide all detection bubbles
                detectionBubbles.forEach(bubbleData => {
                    if (map && map.hasLayer(bubbleData.bubble)) {
                        map.removeLayer(bubbleData.bubble);
                    }
                });
                console.log('Detection bubbles hidden');
            }
            
            // Update legend if open
            if (legendVisible) {
                updateLegendVisibility();
            }
        }
        
        // Make functions available globally
        window.updateMeshNetwork = updateMeshNetwork;
        window.toggleMeshNetwork = toggleMeshNetwork;
        window.updateDetectionBubbles = updateDetectionBubbles;
        window.toggleDetectionBubbles = toggleDetectionBubbles;
        function removeNode(index) {
            if (index >= 0 && index < detectionNodes.length) {
                const node = detectionNodes[index];
                map.removeLayer(node.marker);
                
                // Helper function to stop wedge animation
                function stopWedgeAnimation(wedge) {
                    if (wedge && wedge._pulseAnimationId) {
                        cancelAnimationFrame(wedge._pulseAnimationId);
                        wedge._pulseAnimationId = null;
                    }
                }
                
                // Remove direction wedge if it exists
                if (node.directionWedge) {
                    stopWedgeAnimation(node.directionWedge);
                    map.removeLayer(node.directionWedge);
                }
                if (nodeDirectionWedges[node.id]) {
                    stopWedgeAnimation(nodeDirectionWedges[node.id]);
                    map.removeLayer(nodeDirectionWedges[node.id]);
                    delete nodeDirectionWedges[node.id];
                }
                
                // Remove label and pointer line if they exist
                if (node.label) {
                    if (map.hasLayer(node.label)) {
                        map.removeLayer(node.label);
                    }
                }
                if (node.labelPointerLine) {
                    if (map.hasLayer(node.labelPointerLine)) {
                        map.removeLayer(node.labelPointerLine);
                    }
                }
                
                detectionNodes.splice(index, 1);
                
                // Re-index remaining nodes
                detectionNodes.forEach((n, i) => {
                    n.id = i;
                });
                
                // Update toggle visibility after removing node
                updateToggleVisibility();
                
                // Update mesh network
                updateMeshNetwork();
                
                // Rebuild direction wedges map
                const newWedges = {};
                detectionNodes.forEach((n, i) => {
                    if (nodeDirectionWedges[n.id]) {
                        newWedges[i] = nodeDirectionWedges[n.id];
                    }
                });
                nodeDirectionWedges = newWedges;
                
                // Update mesh network connections
                updateMeshNetwork();
                
                // Update detection bubbles
                updateDetectionBubbles();
                
                // Update all node labels (to renumber them)
                if (nodeLabelsVisible) {
                    updateAllNodeLabels();
                }
                
                // Update node count
                document.getElementById('nodeCount').textContent = detectionNodes.length;
            }
        }

        // Make removeNode available globally for popup buttons
        window.removeNode = removeNode;
        
        // Update IMPORT FLIGHT LOG button centering based on panel state and flight logs
        function updateImportButtonCentering() {
            const panel = document.getElementById('flightPanel');
            const fileUploadDiv = panel ? panel.querySelector('.file-upload') : null;
            const buttonContainer = document.getElementById('importFlightLogButtonContainer');
            if (!panel || !fileUploadDiv || !buttonContainer) return;
            
            const hasFlightLogs = flightLogs && flightLogs.length > 0;
            const isExpanded = !panel.classList.contains('collapsed');
            
            if (isExpanded && !hasFlightLogs) {
                fileUploadDiv.style.display = 'flex';
                fileUploadDiv.style.flexDirection = 'column';
                fileUploadDiv.style.alignItems = 'center';
                fileUploadDiv.style.justifyContent = 'center';
                fileUploadDiv.style.width = '100%';
                buttonContainer.style.width = '100%';
                buttonContainer.style.display = 'flex';
                buttonContainer.style.flexDirection = 'column';
                buttonContainer.style.alignItems = 'center';
                buttonContainer.style.justifyContent = 'center';
                buttonContainer.style.gap = '15px';
                const buttons = buttonContainer.querySelectorAll('button');
                buttons.forEach(button => {
                    button.style.width = '100%';
                    button.style.maxWidth = '100%';
                });
            } else {
                fileUploadDiv.style.display = 'block';
                fileUploadDiv.classList.remove('centered');
                buttonContainer.style.width = '100%';
                buttonContainer.style.display = 'flex';
                buttonContainer.style.flexDirection = 'column';
                buttonContainer.style.alignItems = 'flex-start';
                buttonContainer.style.justifyContent = 'flex-start';
                buttonContainer.style.gap = '10px';
                const buttons = buttonContainer.querySelectorAll('button');
                buttons.forEach(button => {
                    button.style.width = '100%';
                });
            }
        }
        
        // Toggle base map menu - opens list directly with one click
        function toggleBaseMapMenu(event) {
            if (event) {
                event.stopPropagation();
            }
            const menu = document.getElementById('baseMapMenu');
            if (!menu) return;
            
            // Close other menus if needed
            const legendPanel = document.getElementById('legendPanel');
            if (legendPanel && !legendPanel.classList.contains('hidden')) {
                legendVisible = false;
                legendPanel.classList.add('hidden');
            }
            
            // Toggle menu - opens directly, shows all options immediately
            if (menu.style.display === 'none' || !menu.style.display) {
                menu.style.display = 'block';
            } else {
                menu.style.display = 'none';
            }
        }
        
        // Handle base map change
        function handleBaseMapChange(mapName) {
            if (!map) {
                console.error('Map not initialized');
                return;
            }
            
            if (!baseMaps || !baseMaps[mapName]) {
                console.error('Base map not found:', mapName);
                return;
            }
            
            // Remove current layer if it exists
            if (currentBaseLayer) {
                map.removeLayer(currentBaseLayer);
            }
            
            // Add new layer
            baseMaps[mapName].addTo(map);
            currentBaseLayer = baseMaps[mapName];
            
            // Close menu after selection
            const menu = document.getElementById('baseMapMenu');
            if (menu) {
                menu.style.display = 'none';
            }
        }
        
        // Tagline rotation functionality
        const taglines = [
            "The sky is not anonymous.",
            "The future of flight is visible.",
            "Airspace belongs to everyone."
        ];
        
        let currentTaglineIndex = 0;
        let taglineInterval = null;
        
        function startTaglineRotation() {
            const taglineText = document.getElementById('taglineText');
            if (!taglineText) return;
            
            // Only show tagline on very wide screens (1600px+) to prevent overlap
            // The tagline overlaps with "Broadcast your drone's live location" text when screen is narrow
            if (window.innerWidth < 1600) {
                taglineText.style.display = 'none';
                taglineText.style.visibility = 'hidden';
                return;
            }
            
            // Show tagline (remove inline display:none if present)
            taglineText.style.display = '';
            taglineText.style.visibility = '';
            
            function showNextTagline() {
                const currentTaglineElement = document.getElementById('taglineText');
                if (!currentTaglineElement) return;
                
                // Force a reflow to ensure transition starts
                currentTaglineElement.offsetHeight;
                
                // Start fade out - 2.5 seconds
                currentTaglineElement.classList.add('fade-out');
                
                setTimeout(() => {
                    // Update text while completely invisible
                    currentTaglineIndex = (currentTaglineIndex + 1) % taglines.length;
                    currentTaglineElement.textContent = taglines[currentTaglineIndex];
                    
                    // Force another reflow before fade in
                    currentTaglineElement.offsetHeight;
                    
                    // Start fade in - 2.5 seconds
                    currentTaglineElement.classList.remove('fade-out');
                }, 2500); // 2.5 second fade out duration
            }
            
            // Show first tagline immediately
            taglineText.textContent = taglines[0];
            taglineText.style.opacity = '1';
            
            // Rotate every 15 seconds (10s visible + 5s fade transition - 2.5s fade out + 2.5s fade in)
            if (taglineInterval) {
                clearInterval(taglineInterval);
            }
            taglineInterval = setInterval(showNextTagline, 15000);
        }
        
        function stopTaglineRotation() {
            if (taglineInterval) {
                clearInterval(taglineInterval);
                taglineInterval = null;
            }
        }
        
        // Panel collapse/expand functionality
        function togglePanel(panelId) {
            const panel = document.getElementById(panelId);
            const header = panel.previousElementSibling;
            
            panel.classList.toggle('collapsed');
            header.classList.toggle('collapsed');
            
            // Update button centering when flight panel is toggled
            if (panelId === 'flightPanel') {
                updateImportButtonCentering();
            }
        }
        
            // Update toggle visibility based on available data
        function updateToggleVisibility() {
            // Check both old flightLogData and new flightLogs array
            const hasFlightLog = (flightLogData && flightLogData.length > 0) || (flightLogs && flightLogs.length > 0);
            const hasAcousticEstimate = acousticEstimateData && acousticEstimateData.length > 0;
            const hasMultipleNodes = detectionNodes && detectionNodes.length > 1;
            const hasAnyData = hasFlightLog || hasAcousticEstimate;
            
            // Flight Log Controls: only show if flight log data exists
            const flightLogControls = document.getElementById('flightLogControls');
            if (flightLogControls) {
                flightLogControls.style.display = hasFlightLog ? 'block' : 'none';
                
                // Show/hide flight profile viewer section
                const flightProfileSection = document.getElementById('flightProfileViewerSection');
                if (flightProfileSection) {
                    flightProfileSection.style.display = hasFlightLog ? 'block' : 'none';
                }
            }
            
            // Flight Log Speed Control: only show if flight log data exists
            const flightLogSpeedControl = document.getElementById('flightLogSpeedControl');
            if (flightLogSpeedControl) {
                flightLogSpeedControl.style.display = hasFlightLog ? 'flex' : 'none';
            }
            
            // Flight Log Timeline: only show if flight log data exists
            const flightLogTimeline = document.getElementById('flightLogTimeline');
            if (flightLogTimeline) {
                flightLogTimeline.style.display = hasFlightLog ? 'block' : 'none';
            }
            
            // Data Source Checkboxes: show if flight log OR acoustic estimate exists
            const dataSourceCheckboxes = document.getElementById('dataSourceCheckboxes');
            if (dataSourceCheckboxes) {
                dataSourceCheckboxes.style.display = hasAnyData ? 'block' : 'none';
            }
            
            // Actual drone vector checkbox: only show if flight log data exists
            const actualDroneCheckboxLabel = document.getElementById('actualDroneCheckboxLabel');
            if (actualDroneCheckboxLabel) {
                actualDroneCheckboxLabel.style.display = hasFlightLog ? 'block' : 'none';
            }
            
            // Acoustic direction estimate checkbox: only show if acoustic estimate data exists
            const acousticEstimateCheckboxLabel = document.getElementById('acousticEstimateCheckboxLabel');
            if (acousticEstimateCheckboxLabel) {
                acousticEstimateCheckboxLabel.style.display = hasAcousticEstimate ? 'block' : 'none';
            }
            
            // Flight Log Stats: only show if flight log data exists
            const flightLogStats = document.getElementById('flightLogStats');
            if (flightLogStats) {
                flightLogStats.style.display = hasFlightLog ? 'block' : 'none';
            }
            
            // Show Drone toggle: only if flight log data exists
            const showDroneControl = document.getElementById('toggleControlShowDrone');
            if (showDroneControl) {
                showDroneControl.style.display = hasFlightLog ? 'flex' : 'none';
            }
            
            // Show Track toggle: only if flight log data exists
            const showTrackControl = document.getElementById('toggleControlShowTrack');
            if (showTrackControl) {
                showTrackControl.style.display = hasFlightLog ? 'flex' : 'none';
            }
            
            // Mesh Network toggle: only if more than one EDSB sensor (including acoustic node)
            const meshNetworkControl = document.getElementById('toggleControlMeshNetwork');
            if (meshNetworkControl) {
                const totalNodeCount = detectionNodes.length + (acousticNode ? 1 : 0);
                meshNetworkControl.style.display = totalNodeCount > 1 ? 'flex' : 'none';
            }
            
            // Detection Bubble toggle: only if there's at least one node (acoustic node always exists)
            const detectionBubbleControl = document.getElementById('toggleControlDetectionBubble');
            if (detectionBubbleControl) {
                const nodeCount = detectionNodes.length + (acousticNode ? 1 : 0);
                detectionBubbleControl.style.display = nodeCount > 0 ? 'flex' : 'none';
            }
            
            // Vectors section: only if flight log data exists
            const vectorsSection = document.getElementById('vectorsSection');
            if (vectorsSection) {
                vectorsSection.style.display = hasFlightLog ? 'block' : 'none';
            }
            
            // Actual drone vector: only if flight log data exists
            const actualDroneVectorControl = document.getElementById('toggleControlActualDroneVector');
            if (actualDroneVectorControl) {
                actualDroneVectorControl.style.display = hasFlightLog ? 'flex' : 'none';
            }
            
            // Acoustic estimate vector: only if acoustic estimate data exists
            const acousticEstimateVectorControl = document.getElementById('toggleControlAcousticEstimateVector');
            if (acousticEstimateVectorControl) {
                acousticEstimateVectorControl.style.display = hasAcousticEstimate ? 'flex' : 'none';
            }
            
            // Directional Indicators section: only if any data exists
            const directionalIndicatorsSection = document.getElementById('directionalIndicatorsSection');
            if (directionalIndicatorsSection) {
                directionalIndicatorsSection.style.display = hasAnyData ? 'block' : 'none';
            }
            
            // Actual drone directional indicator: only if flight log data exists
            const droneDirectionalControl = document.getElementById('toggleControlDroneDirectional');
            if (droneDirectionalControl) {
                droneDirectionalControl.style.display = hasFlightLog ? 'flex' : 'none';
            }
            
            // Acoustic estimate directional indicator: only if acoustic estimate data exists
            const acousticDirectionalControl = document.getElementById('toggleControlAcousticDirectional');
            if (acousticDirectionalControl) {
                acousticDirectionalControl.style.display = hasAcousticEstimate ? 'flex' : 'none';
            }
            
            // Drone Label toggle: only if flight log data exists
            const droneLabelControl = document.getElementById('toggleControlDroneLabel');
            if (droneLabelControl) {
                droneLabelControl.style.display = hasFlightLog ? 'flex' : 'none';
            }
            
            // Drone Altitude Label toggle: only if flight log data exists
            const droneAltitudeControl = document.getElementById('toggleControlDroneAltitude');
            if (droneAltitudeControl) {
                droneAltitudeControl.style.display = hasFlightLog ? 'flex' : 'none';
            }
            
            // Home Point Location toggle: only if flight log data exists
            const homePointControl = document.getElementById('toggleControlHomePoint');
            if (homePointControl) {
                homePointControl.style.display = hasFlightLog ? 'flex' : 'none';
            }
            
            // Home Point Label toggle: only if flight log data exists
            const homePointLabelControl = document.getElementById('toggleControlHomePointLabel');
            if (homePointLabelControl) {
                homePointLabelControl.style.display = hasFlightLog ? 'flex' : 'none';
            }
            
            // Distance from Home Point toggle: only if flight log data exists
            const distanceFromHomeControl = document.getElementById('toggleControlDistanceFromHome');
            if (distanceFromHomeControl) {
                distanceFromHomeControl.style.display = hasFlightLog ? 'flex' : 'none';
            }
        }
        
        // Toggle visibility functions
        function toggleDroneVisibility() {
            const toggle = document.getElementById('toggleDrone');
            toggle.classList.toggle('active');
            
            // flightMarker removed - toggle no longer controls marker visibility
            // Drone label can still be toggled if needed
            if (toggle.classList.contains('active')) {
                // Update drone label if visible and flight log is playing
                if (droneLabelVisible && flightLogData && flightLogData.length > 0 && currentIndex < flightLogData.length) {
                    const currentPoint = flightLogData[currentIndex];
                    updateDroneLabel(currentPoint.lat, currentPoint.lng);
                }
            } else {
                // Hide drone label when toggle is off
                if (droneLabel) {
                    if (map.hasLayer(droneLabel)) {
                        map.removeLayer(droneLabel);
                    }
                    if (droneLabel._pointerLine && map.hasLayer(droneLabel._pointerLine)) {
                        map.removeLayer(droneLabel._pointerLine);
                    }
                }
            }
            
            // Always update triangulation lines if their toggle is on (independent of drone visibility)
            if (triangulationLinesVisible && flightLogData && flightLogData.length > 0 && currentIndex < flightLogData.length) {
                const currentPoint = flightLogData[currentIndex];
                updateTriangulationLines(currentPoint.lat, currentPoint.lng);
            }
            
            // Update legend if open
            if (legendVisible) {
                updateLegendVisibility();
            }
        }
        
        function toggleTrackVisibility() {
            const toggle = document.getElementById('toggleTrack');
            toggle.classList.toggle('active');
            const isActive = toggle.classList.contains('active');
            
            // Update all flight log polylines
            flightLogs.forEach(flightLog => {
                if (flightLog.polyline) {
                    if (isActive && flightLog.visible) {
                        if (!map.hasLayer(flightLog.polyline)) {
                            flightLog.polyline.addTo(map);
                        }
                    } else {
                        if (map.hasLayer(flightLog.polyline)) {
                            map.removeLayer(flightLog.polyline);
                        }
                    }
                }
            });
            
            // Also update the old flightPath for backward compatibility
            if (flightPath) {
                if (isActive) {
                    if (!map.hasLayer(flightPath)) {
                        flightPath.addTo(map);
                    }
                } else {
                    if (map.hasLayer(flightPath)) {
                        map.removeLayer(flightPath);
                    }
                }
            }
            
            // Update legend if open
            if (legendVisible) {
                updateLegendVisibility();
            }
        }

        // Initialize on page load
        // Legend toggle function
        function toggleLegend() {
            legendVisible = !legendVisible;
            const legendPanel = document.getElementById('legendPanel');
            const legendBtn = document.getElementById('legendBtn');
            
            if (legendPanel && legendBtn) {
                if (legendVisible) {
                    updateLegendVisibility(); // Update legend when opening
                    legendPanel.classList.add('visible');
                    legendBtn.textContent = 'Hide Legend';
                } else {
                    legendPanel.classList.remove('visible');
                    legendBtn.textContent = 'Legend';
                }
            }
        }
        
        // Update legend to only show items that are actually visible on the map
        function updateLegendVisibility() {
            // Acoustic estimate vector - show if acoustic estimate data exists and toggle is active
            const acousticVectorItem = document.querySelector('[data-legend="acoustic-vector"]');
            const hasAcousticEstimate = acousticEstimateData && acousticEstimateData.length > 0;
            const acousticTriangulationToggle = document.getElementById('toggleAcousticTriangulation');
            const acousticVectorVisible = hasAcousticEstimate && 
                acousticTriangulationToggle && acousticTriangulationToggle.classList.contains('active');
            if (acousticVectorItem) {
                acousticVectorItem.style.display = acousticVectorVisible ? 'flex' : 'none';
            }
            
            // Flight logs - show individual entries for each visible flight log
            const flightLogsLegendContainer = document.getElementById('flightLogsLegendContainer');
            const trackToggle = document.getElementById('toggleTrack');
            const isTrackVisible = trackToggle && trackToggle.classList.contains('active');
            const visibleFlightLogs = flightLogs.filter(fl => fl.visible && fl.polyline && fl.data && fl.data.length > 0);
            
            if (flightLogsLegendContainer) {
                if (visibleFlightLogs.length > 0 && isTrackVisible) {
                    flightLogsLegendContainer.innerHTML = '';
                    visibleFlightLogs.forEach(flightLog => {
                        const legendItem = document.createElement('div');
                        legendItem.className = 'legend-item';
                        legendItem.style.display = 'flex';
                        // Use green for selected, red for unselected
                        const lineColor = flightLog.selected ? '#5a8a6a' : '#dd9999';
                        legendItem.innerHTML = `
                            <div class="legend-symbol">
                                <div class="legend-line" style="border-color: ${lineColor}; border-style: solid;"></div>
                            </div>
                            <span style="font-size: 11px;">${flightLog.name}</span>
                        `;
                        flightLogsLegendContainer.appendChild(legendItem);
                    });
                    flightLogsLegendContainer.style.display = 'block';
                } else {
                    flightLogsLegendContainer.style.display = 'none';
                    flightLogsLegendContainer.innerHTML = '';
                }
            }
            
            // Home point location - show if home point marker exists and toggle is active
            const homePointLocationItem = document.querySelector('[data-legend="home-point-location"]');
            const homePointToggle = document.getElementById('toggleHomePoint');
            const homePointLocationVisible = homePointMarker && map.hasLayer(homePointMarker) && 
                homePointToggle && homePointToggle.classList.contains('active');
            if (homePointLocationItem) {
                homePointLocationItem.style.display = homePointLocationVisible ? 'flex' : 'none';
            }
            
            // Drone location - always show (reference item)
            // No conditional display needed - it's always visible
            
            // EDSB locations - show if detection nodes exist
            const edsbLocationsItem = document.querySelector('[data-legend="edsb-locations"]');
            const hasEDSBNodes = detectionNodes && detectionNodes.length > 0;
            if (edsbLocationsItem) {
                edsbLocationsItem.style.display = hasEDSBNodes ? 'flex' : 'none';
            }
            
            // Detection bubble - show if detection nodes exist and toggle is active
            const detectionBubbleItem = document.querySelector('[data-legend="detection-bubble"]');
            const detectionBubbleToggle = document.getElementById('toggleDetectionBubble');
            const detectionBubbleVisible = hasEDSBNodes && 
                detectionBubbleToggle && detectionBubbleToggle.classList.contains('active');
            if (detectionBubbleItem) {
                detectionBubbleItem.style.display = detectionBubbleVisible ? 'flex' : 'none';
            }
            
            // Mesh Network - show if multiple nodes exist and toggle is active
            const meshNetworkItem = document.querySelector('[data-legend="mesh-network"]');
            const meshToggle = document.getElementById('toggleMesh');
            const hasMultipleNodes = detectionNodes && detectionNodes.length > 1;
            const meshNetworkVisible = hasMultipleNodes && 
                meshToggle && meshToggle.classList.contains('active');
            if (meshNetworkItem) {
                meshNetworkItem.style.display = meshNetworkVisible ? 'flex' : 'none';
            }
            
            // MQTT Drones - always show (default legend item)
            const mqttDronesItem = document.querySelector('[data-legend="mqtt-drones"]');
            if (mqttDronesItem) {
                mqttDronesItem.style.display = 'flex';
            }
            
            // Drone location - hide this item, we only want the "Drone" item to show
            const droneLocationItem = document.querySelector('[data-legend="drone-location"]');
            if (droneLocationItem) {
                droneLocationItem.style.display = 'none'; // Always hide, use mqtt-drones item instead
            }
        }
        window.updateLegendVisibility = updateLegendVisibility;
        
        // ==================== MQTT Functions ====================

        /**
         * Initialize and connect to MQTT broker
         */
        function initMQTT() {
            try {
                // Create a client instance with random client ID
                const clientId = "eagle_eyes_web_" + Math.random().toString(16).substr(2, 8);

                // Extract hostname and port from WebSocket URL
                // Format: wss://mqtt-telemetry.eagleeyessearch.com:8084
                const url = new URL(MQTT_BROKER_URL);
                const hostname = url.hostname;
                const port = parseInt(url.port) || (url.protocol === 'wss:' ? 443 : 80);
                // Try common WebSocket paths: /, /mqtt, /ws
                const path = url.pathname && url.pathname !== '/' ? url.pathname : '/';

                console.log(`Connecting to MQTT broker: ${hostname}:${port}${path}`);
                console.log(`Full WebSocket URL would be: ${url.protocol}//${hostname}:${port}${path}`);

                mqttClient = new Paho.MQTT.Client(hostname, port, path, clientId);

                // Set callback handlers
                mqttClient.onConnectionLost = onMQTTConnectionLost;
                mqttClient.onMessageArrived = onMQTTMessageArrived;

                // Connect options
                const connectOptions = {
                    useSSL: url.protocol === 'wss:',
                    userName: MQTT_LICENSE_KEY,
                    password: MQTT_LICENSE_KEY,
                    keepAliveInterval: 60,
                    cleanSession: true,
                    onSuccess: onMQTTConnect,
                    onFailure: onMQTTConnectFailure
                };

                // Connect to broker
                mqttClient.connect(connectOptions);

                console.log('MQTT connection initiated...');
            } catch (error) {
                console.error('Error initializing MQTT:', error);
                showToast('MQTT initialization failed: ' + error.message);
            }
        }

        /**
         * Called when MQTT connection is established
         */
        function onMQTTConnect() {
            console.log('Connected to MQTT broker');
            mqttConnected = true;

            // Update header status indicator
            const headerStatusText = document.getElementById('mqttStatusText');
            const headerStatusDot = document.getElementById('mqttStatusDot');
            if (headerStatusText) {
                headerStatusText.textContent = 'CONNECTED';
                headerStatusText.style.color = '#5a8a6a';
            }
            if (headerStatusDot) {
                headerStatusDot.className = 'status-dot connected';
            }

            // Subscribe to the public topic
            try {
                mqttClient.subscribe(MQTT_TOPIC, {
                    qos: 1,
                    onSuccess: function() {
                        console.log('Subscribed to MQTT topic: ' + MQTT_TOPIC);
                        showToast('Connected to drone telemetry stream');
                    },
                    onFailure: function(error) {
                        console.error('Failed to subscribe to topic:', error);
                        showToast('Failed to subscribe to telemetry topic');
                    }
                });
            } catch (error) {
                console.error('Error subscribing to topic:', error);
            }
        }

        /**
         * Called when MQTT connection fails
         */
        function onMQTTConnectFailure(error) {
            console.error('MQTT connection failed:', error);
            mqttConnected = false;

            // Update header status indicator
            const headerStatusText = document.getElementById('mqttStatusText');
            const headerStatusDot = document.getElementById('mqttStatusDot');
            if (headerStatusText) {
                headerStatusText.textContent = 'CONNECTION FAILED';
                headerStatusText.style.color = '#dc143c';
            }
            if (headerStatusDot) {
                headerStatusDot.className = 'status-dot failed';
            }

            showToast('MQTT connection failed: ' + (error.errorMessage || 'Unknown error'));
        }

        /**
         * Called when MQTT connection is lost
         */
        function onMQTTConnectionLost(responseObject) {
            console.log('MQTT connection lost');
            mqttConnected = false;

            // Update header status indicator
            const headerStatusText = document.getElementById('mqttStatusText');
            const headerStatusDot = document.getElementById('mqttStatusDot');
            if (headerStatusText) {
                headerStatusText.textContent = 'DISCONNECTED';
                headerStatusText.style.color = '#d4a574';
            }
            if (headerStatusDot) {
                headerStatusDot.className = 'status-dot disconnected';
            }

            if (responseObject.errorCode !== 0) {
                console.error('MQTT connection lost:', responseObject.errorMessage);
                showToast('Drone telemetry connection lost');
            }

            // Client will attempt to reconnect automatically if reconnect option is set
        }

        /**
         * Called when an MQTT message arrives
         */
        function onMQTTMessageArrived(message) {
            try {
                const payload = message.payloadString;
                const telemetryData = JSON.parse(payload);

                // Validate telemetry data
                if (!telemetryData.type || telemetryData.type !== 'drone_telemetry') {
                    console.warn('Received non-telemetry message:', telemetryData.type);
                    return;
                }

                if (!telemetryData.drone_id) {
                    console.warn('Received telemetry without drone_id');
                    return;
                }

                // Process the telemetry data
                processDroneTelemetry(telemetryData);

            } catch (error) {
                console.error('Error processing MQTT message:', error);
            }
        }

        /**
         * Process incoming drone telemetry data
         */
        function processDroneTelemetry(telemetryData) {
            const droneId = telemetryData.drone_id;
            const droneName = telemetryData.drone_name || droneId;

            // Store latest telemetry data
            mqttDroneData[droneId] = telemetryData;
            
            // Update last update timestamp
            mqttDroneLastUpdate[droneId] = Date.now();
            
            // Clear existing timeout for this drone
            if (mqttDroneTimeouts[droneId]) {
                clearTimeout(mqttDroneTimeouts[droneId]);
                delete mqttDroneTimeouts[droneId];
            }
            
            // Set timeout to remove drone after 5 minutes of no updates
            mqttDroneTimeouts[droneId] = setTimeout(() => {
                removeMQTTDrone(droneId);
            }, 5 * 60 * 1000); // 5 minutes

            // Extract GPS location
            const gpsLocation = telemetryData.state?.drone_gps_location;
            if (!gpsLocation || !gpsLocation.lat || !gpsLocation.lng) {
                console.warn('Telemetry missing GPS location for drone:', droneId);
                return;
            }

            const lat = gpsLocation.lat;
            const lng = gpsLocation.lng;
            const altitude = gpsLocation.altitude_ahl_m || gpsLocation.altitude_asl_m || 0;

            // Update or create drone marker
            updateMQTTDroneMarker(droneId, droneName, lat, lng, altitude, telemetryData);

            // Update or create drone path
            updateMQTTDronePath(droneId, lat, lng);
            
            // Update legend visibility
            updateLegendVisibility();

            console.log(`Updated drone ${droneName} at [${lat.toFixed(6)}, ${lng.toFixed(6)}], alt: ${altitude.toFixed(1)}m`);
        }
        
        /**
         * Remove an MQTT drone from the map
         */
        function removeMQTTDrone(droneId) {
            const marker = mqttDroneMarkers[droneId];
            const path = mqttDronePaths[droneId];
            
            if (marker) {
                if (marker.labelMarker) {
                    map.removeLayer(marker.labelMarker);
                }
                map.removeLayer(marker);
                delete mqttDroneMarkers[droneId];
            }
            
            if (path) {
                map.removeLayer(path);
                delete mqttDronePaths[droneId];
            }
            
            delete mqttDroneData[droneId];
            delete mqttDroneLastUpdate[droneId];
            if (mqttDroneTimeouts[droneId]) {
                clearTimeout(mqttDroneTimeouts[droneId]);
                delete mqttDroneTimeouts[droneId];
            }
            
            // Update legend visibility
            updateLegendVisibility();
            
            console.log(`Removed stale drone: ${droneId}`);
        }

        /**
         * Update or create a marker for an MQTT drone
         */
        function updateMQTTDroneMarker(droneId, droneName, lat, lng, altitude, telemetryData) {
            if (!map) return;

            let marker = mqttDroneMarkers[droneId];

            if (!marker) {
                // Create new marker - smaller red circle with pulsing ring for drone location
                const droneIcon = L.divIcon({
                    className: 'home-point-marker',
                    html: '<div class="drone-location-pulse"></div><div class="drone-location-circle"></div>',
                    iconSize: [16, 16],
                    iconAnchor: [8, 8]
                });

                marker = L.marker([lat, lng], { icon: droneIcon }).addTo(map);
                mqttDroneMarkers[droneId] = marker;

                // Don't create label for MQTT drones by default (but marker is still clickable)
                marker.labelMarker = null;

            } else {
                // Update existing marker position
                marker.setLatLng([lat, lng]);
                // No label to update - labels are not shown for MQTT drones
            }

            // Calculate time since last update (minutes and seconds only, or just minutes if > 5 min)
            const lastUpdate = mqttDroneLastUpdate[droneId] || Date.now();
            const timeSinceUpdate = Date.now() - lastUpdate;
            const totalMinutes = Math.floor(timeSinceUpdate / (1000 * 60));
            const seconds = Math.floor((timeSinceUpdate % (1000 * 60)) / 1000);
            
            let timeSinceUpdateStr;
            if (totalMinutes > 5) {
                timeSinceUpdateStr = `${totalMinutes}m`;
            } else {
                timeSinceUpdateStr = `${totalMinutes}m ${seconds}s`;
            }

            // Update popup with telemetry data
            const batteryPercent = telemetryData.state?.misc?.battery_percent || 'N/A';
            const airspeed = telemetryData.state?.misc?.airspeed_mps;
            const yaw = telemetryData.state?.drone_pose?.yaw_deg;

            // Format coordinates for popup
            const latFormatted = lat.toFixed(6);
            const lngFormatted = lng.toFixed(6);
            
            const popupContent = `
                <div style="font-family: 'Courier New', monospace; font-size: 12px; color: #a0a0a0;">
                    <strong style="color: #d4a574;">${droneName}</strong><br>
                    <strong>Coordinates:</strong><br>
                    <strong>Lat: ${latFormatted}</strong><br>
                    <strong>Lng: ${lngFormatted}</strong><br>
                    <strong>ID:</strong> ${droneId}<br>
                    <strong>Alt:</strong> ${altitude.toFixed(1)} m<br>
                    ${yaw !== null && yaw !== undefined ? `<strong>Yaw:</strong> ${yaw.toFixed(1)}°<br>` : ''}
                    ${batteryPercent !== 'N/A' ? `<strong>Battery:</strong> ${batteryPercent}%<br>` : ''}
                    <strong>Speed:</strong> ${airspeed !== null && airspeed !== undefined ? `${airspeed.toFixed(1)} m/s` : 'N/A'}<br>
                    <strong>LAST UPDATE:</strong> ${timeSinceUpdateStr}<br>
                </div>
            `;

            // Bind popup to marker (marker is clickable even without label)
            marker.bindPopup(popupContent);
        }

        /**
         * Update or create a path polyline for an MQTT drone
         */
        function updateMQTTDronePath(droneId, lat, lng) {
            if (!map) return;

            let path = mqttDronePaths[droneId];

            if (!path) {
                // Create new path
                path = L.polyline([[lat, lng]], {
                    color: '#DC143C',
                    weight: 3,
                    opacity: 0.7
                }).addTo(map);

                mqttDronePaths[droneId] = path;
            } else {
                // Add new point to existing path
                const latLngs = path.getLatLngs();
                latLngs.push([lat, lng]);

                // Limit path length to last 1000 points to prevent memory issues
                if (latLngs.length > 1000) {
                    latLngs.shift();
                }

                path.setLatLngs(latLngs);
            }
        }

        /**
         * Disconnect from MQTT broker
         */
        function disconnectMQTT() {
            if (mqttClient && mqttConnected) {
                try {
                    mqttClient.disconnect();
                    console.log('Disconnected from MQTT broker');
                    mqttConnected = false;
                } catch (error) {
                    console.error('Error disconnecting from MQTT:', error);
                }
            }
        }

        /**
         * Clear all MQTT drone markers and paths
         */
        function clearMQTTDrones() {
            // Remove all markers
            Object.values(mqttDroneMarkers).forEach(marker => {
                if (marker.labelMarker) {
                    map.removeLayer(marker.labelMarker);
                }
                map.removeLayer(marker);
            });

            // Remove all paths
            Object.values(mqttDronePaths).forEach(path => {
                map.removeLayer(path);
            });

            // Clear storage
            mqttDroneMarkers = {};
            mqttDronePaths = {};
            mqttDroneData = {};
            mqttDroneLastUpdate = {};
            Object.values(mqttDroneTimeouts).forEach(timeout => clearTimeout(timeout));
            mqttDroneTimeouts = {};

            // Update legend visibility
            updateLegendVisibility();

            console.log('Cleared all MQTT drone markers and paths');
        }
        
        // Update download button pulse based on data availability
        function updateDownloadButtonPulse() {
            const downloadBtn = document.getElementById('downloadTestDataBtn');
            if (!downloadBtn) return;
            
            const hasFlightLog = flightLogData && flightLogData.length > 0;
            const hasAcousticEstimate = acousticEstimateData && acousticEstimateData.length > 0;
            
            // Pulse if no flight log and no acoustic estimate (even if nodes exist)
            if (!hasFlightLog && !hasAcousticEstimate) {
                downloadBtn.classList.add('pulse');
            } else {
                downloadBtn.classList.remove('pulse');
            }
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            
            // Initialize header MQTT status indicator
            const headerStatusText = document.getElementById('mqttStatusText');
            const headerStatusDot = document.getElementById('mqttStatusDot');
            if (headerStatusText) {
                headerStatusText.textContent = 'DISCONNECTED';
                headerStatusText.style.color = '#d4a574';
            }
            if (headerStatusDot) {
                headerStatusDot.className = 'status-dot disconnected';
            }
            
            // Initialize legend - make it visible by default
            const legendPanel = document.getElementById('legendPanel');
            if (legendPanel) {
                legendPanel.classList.remove('visible');
                updateLegendVisibility();
            }
            
            // Initialize MQTT connection
            initMQTT();
            
            // Initialize download button pulse state
            updateDownloadButtonPulse();
            
            // Initialize IMPORT FLIGHT LOG button centering
            updateImportButtonCentering();
            
            // Start tagline rotation (desktop only)
            startTaglineRotation();
            
            // Restart tagline rotation on window resize to handle mobile/desktop switch
            let resizeTimeout;
            window.addEventListener('resize', function() {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(function() {
                    stopTaglineRotation();
                    startTaglineRotation();
                }, 250);
            });
            
            // Add event listeners for checkboxes
            const actualDroneCheckbox = document.getElementById('actualDroneCheckbox');
            const acousticEstimateCheckbox = document.getElementById('acousticEstimateCheckbox');
            
            if (actualDroneCheckbox) {
                actualDroneCheckbox.addEventListener('change', function() {
                    // Update display based on current position
                    if (flightLogData.length > 0) {
                        updateFlightPosition(currentIndex);
                    }
                });
            }
            
            if (acousticEstimateCheckbox) {
                acousticEstimateCheckbox.addEventListener('change', function() {
                    // Update display based on current position
                    if (flightLogData.length > 0) {
                        updateFlightPosition(currentIndex);
                    }
                    // Also update acoustic estimate if we're on acoustic timeline
                    if (acousticEstimateData.length > 0) {
                        updateAcousticEstimateDisplay(currentAcousticIndex);
                    }
                });
            }
        });
        
        // ==================== 3D Flight Profile Viewer ====================
        let flightProfileScene = null;
        let flightProfileCamera = null;
        let flightProfileRenderer = null;
        let flightProfileControls = null;
        
        function openFlightProfileViewer() {
            const modal = document.getElementById('flightProfileModal');
            if (!modal) return;
            
            // Get current flight log data
            const currentLog = flightLogs.find(log => log.selected) || (flightLogData.length > 0 ? { data: flightLogData } : null);
            if (!currentLog || !currentLog.data || currentLog.data.length === 0) {
                showToast('No flight log data available');
                return;
            }
            
            // Add click-outside-to-close functionality
            modal.onclick = function(event) {
                if (event.target === modal) {
                    closeFlightProfileViewer();
                }
            };
            
            modal.style.display = 'flex';
            
            // Add click-outside-to-close functionality
            modal.onclick = function(event) {
                if (event.target === modal) {
                    closeFlightProfileViewer();
                }
            };
            
            // Initialize 3D scene
            initFlightProfile3D(currentLog.data);
        }
        
        function closeFlightProfileViewer() {
            const modal = document.getElementById('flightProfileModal');
            if (modal) {
                modal.style.display = 'none';
            }
            
            // Clean up Three.js resources
            if (flightProfileControls) {
                flightProfileControls.dispose();
                flightProfileControls = null;
            }
            if (flightProfileRenderer) {
                const canvas = flightProfileRenderer.domElement;
                if (canvas && canvas.parentNode) {
                    canvas.parentNode.removeChild(canvas);
                }
                flightProfileRenderer.dispose();
                flightProfileRenderer = null;
            }
            flightProfileScene = null;
            flightProfileCamera = null;
        }
        
        function initFlightProfile3D(flightData) {
            const canvasContainer = document.getElementById('flightProfileCanvas');
            if (!canvasContainer) return;
            
            // Clear previous renderer
            if (flightProfileRenderer) {
                const oldCanvas = flightProfileRenderer.domElement;
                if (oldCanvas && oldCanvas.parentNode) {
                    oldCanvas.parentNode.removeChild(oldCanvas);
                }
                flightProfileRenderer.dispose();
            }
            
            // Create scene
            flightProfileScene = new THREE.Scene();
            // Set scene background to dark green/black for military theme
            flightProfileScene.background = new THREE.Color(0x0a0a0a);
            
            // Add ambient light so objects are visible
            const ambientLight = new THREE.AmbientLight(0x4a7c59, 0.4);
            flightProfileScene.add(ambientLight);
            
            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0x5a8a6a, 0.8);
            directionalLight.position.set(1, 1, 1);
            flightProfileScene.add(directionalLight);
            
            // Create camera
            const width = canvasContainer.clientWidth;
            const height = canvasContainer.clientHeight;
            flightProfileCamera = new THREE.PerspectiveCamera(45, width / height, 0.1, 10000);
            
            // Create renderer
            flightProfileRenderer = new THREE.WebGLRenderer({ antialias: true });
            flightProfileRenderer.setSize(width, height);
            flightProfileRenderer.setPixelRatio(window.devicePixelRatio);
            canvasContainer.appendChild(flightProfileRenderer.domElement);
            
            // Calculate flight path bounds and center
            let minLat = Infinity, maxLat = -Infinity;
            let minLng = Infinity, maxLng = -Infinity;
            let minAlt = Infinity, maxAlt = -Infinity;
            
            flightData.forEach(point => {
                minLat = Math.min(minLat, point.lat);
                maxLat = Math.max(maxLat, point.lat);
                minLng = Math.min(minLng, point.lng);
                maxLng = Math.max(maxLng, point.lng);
                minAlt = Math.min(minAlt, point.altitude || 0);
                maxAlt = Math.max(maxAlt, point.altitude || 0);
            });
            
            const centerLat = (minLat + maxLat) / 2;
            const centerLng = (minLng + maxLng) / 2;
            const centerAlt = (minAlt + maxAlt) / 2;
            
            // Convert lat/lng to meters (approximate)
            const latToMeters = 111000; // ~111km per degree latitude
            const lngToMeters = 111000 * Math.cos(centerLat * Math.PI / 180);
            
            // Calculate actual extents in meters for axes
            const extentX = (maxLng - minLng) * lngToMeters;
            const extentY = (maxLat - minLat) * latToMeters;
            const extentZ = (maxAlt - minAlt) || 100;
            
            // Create flight path geometry
            const points = [];
            flightData.forEach(point => {
                const x = (point.lng - centerLng) * lngToMeters;
                const y = (point.lat - centerLat) * latToMeters;
                const z = (point.altitude || 0) - minAlt; // Normalize altitude
                points.push(new THREE.Vector3(x, z, y)); // Swap Y and Z for vertical profile view
            });
            
            // Create path line
            if (points.length === 0) {
                console.error('No points to render');
                showToast('Error: No valid flight path points');
                return;
            }
            
            console.log('Creating flight path with', points.length, 'points');
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0x5a8a6a, linewidth: 3 });
            const line = new THREE.Line(geometry, material);
            flightProfileScene.add(line);
            console.log('Flight path line added');
            
            // Add point markers with better visibility
            const pointGeometry = new THREE.SphereGeometry(3, 12, 12);
            const pointMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4a7c59,
                emissive: 0x2a5c39,
                emissiveIntensity: 0.5
            });
            
            // Green dots removed per user request
            
            // Add grid helper
            const gridSize = Math.max(
                (maxLng - minLng) * lngToMeters,
                (maxLat - minLat) * latToMeters,
                (maxAlt - minAlt) || 100
            );
            
            // Ensure gridSize is valid
            if (gridSize <= 0 || !isFinite(gridSize)) {
                console.error('Invalid gridSize:', gridSize);
                showToast('Error: Invalid flight log data');
                return;
            }
            
            const gridHelper = new THREE.GridHelper(gridSize, 20, 0x4a7c59, 0x1a1a1a);
            flightProfileScene.add(gridHelper);
            
            // Calculate grid spacing for scale labels on grid
            const gridSpacing = gridSize / 20; // Grid has 20 divisions
            
            // Add scale labels to grid edges showing distance per square (more subtle)
            const createScaleLabel = (text, color = 0x5a8a6a) => {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 128;
                canvas.height = 48;
                
                // More subtle background
                context.fillStyle = 'rgba(0, 0, 0, 0.5)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // Smaller, more subtle font
                context.font = 'Bold 18px Arial';
                context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture, 
                    transparent: true,
                    opacity: 0.7 // More subtle
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(gridSize * 0.12, gridSize * 0.06, 1);
                return sprite;
            };
            
            // Add single small scale label in corner (showing distance per square)
            const gridEdge = gridSize / 2;
            const cornerOffset = gridSize * 0.4; // Position in corner, not center
            const labelHeight = 0.2; // Slightly above ground
            
            // Format grid spacing text - "One square equals X by X meters"
            let spacingText = '';
            if (gridSpacing >= 1000) {
                const kmValue = (gridSpacing / 1000).toFixed(1);
                spacingText = `One square equals ${kmValue} by ${kmValue} kilometers`;
            } else {
                const mValue = Math.round(gridSpacing);
                spacingText = `One square equals ${mValue} by ${mValue} meters`;
            }
            
            // Create clean, professional scale label - subtle but legible
            const createSmallScaleLabel = (text, color = 0x5a8a6a) => {
                // Higher resolution canvas to prevent blurriness
                const scale = 2; // Retina scale for crisp text
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 280 * scale;
                canvas.height = 40 * scale;
                
                // Scale context for retina
                context.scale(scale, scale);
                
                // Subtle background
                context.fillStyle = 'rgba(0, 0, 0, 0.5)';
                context.fillRect(0, 0, 280, 40);
                
                // Clean, legible font - not too big, not too small
                context.font = '14px "Courier New", monospace';
                context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, 140, 20);
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.minFilter = THREE.LinearFilter; // Prevent blurring
                texture.magFilter = THREE.LinearFilter;
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture, 
                    transparent: true,
                    opacity: 0.75 // Subtle but visible
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                // Smaller scale - proportional to grid but not overwhelming
                sprite.scale.set(gridSize * 0.15, gridSize * 0.04, 1);
                return sprite;
            };
            
            // Scale label removed per user request
            
            // Add cardinal direction labels on center sides of grid using sprites (with error handling)
            try {
                const createTextSprite = (text, color = 0x5a8a6a) => {
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 256;
                    canvas.height = 256;
                    
                    // More subtle background
                    context.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    context.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Smaller, more subtle font
                    context.font = 'Bold 80px Arial';
                    context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.fillText(text, canvas.width / 2, canvas.height / 2);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const spriteMaterial = new THREE.SpriteMaterial({ 
                        map: texture, 
                        transparent: true,
                        opacity: 0.6 // More subtle
                    });
                    const sprite = new THREE.Sprite(spriteMaterial);
                    sprite.scale.set(gridSize * 0.08, gridSize * 0.08, 1); // Smaller
                    return sprite;
                };
                
                // Add cardinal direction labels at the center of each side of the grid
                const labelDistance = gridSize / 2; // Center of each side
                const cardinalLabelHeight = 0.5; // Above ground, clear of scale label
                
                // North (center of north side)
                const northSprite = createTextSprite('N', 0x5a8a6a);
                northSprite.position.set(0, cardinalLabelHeight, labelDistance);
                flightProfileScene.add(northSprite);
                
                // East (center of east side)
                const eastSprite = createTextSprite('E', 0x5a8a6a);
                eastSprite.position.set(labelDistance, cardinalLabelHeight, 0);
                eastSprite.rotation.y = Math.PI / 2; // Rotate to face outward
                flightProfileScene.add(eastSprite);
                
                // South (center of south side)
                const southSprite = createTextSprite('S', 0x5a8a6a);
                southSprite.position.set(0, cardinalLabelHeight, -labelDistance);
                flightProfileScene.add(southSprite);
                
                // West (center of west side)
                const westSprite = createTextSprite('W', 0x5a8a6a);
                westSprite.position.set(-labelDistance, cardinalLabelHeight, 0);
                westSprite.rotation.y = Math.PI / 2; // Rotate to face outward
                flightProfileScene.add(westSprite);
            } catch (spriteError) {
                console.warn('Error creating cardinal direction sprites:', spriteError);
                // Continue without sprites - scene should still render
            }
            
            // Remove axes from 3D scene - no longer needed
            
            // Update header with range information
            const formatDistance = (meters) => {
                if (meters >= 1000) {
                    return `${(meters / 1000).toFixed(1)} km`;
                } else {
                    return `${Math.round(meters)} m`;
                }
            };
            
            const rangesPanel = document.getElementById('flightProfileRanges');
            if (rangesPanel) {
                rangesPanel.innerHTML = `
                    <span>Height Range: ${formatDistance(extentZ)}</span>
                    <span>Distance Range North To South: ${formatDistance(extentY)}</span>
                    <span>Distance Range East To West: ${formatDistance(extentX)}</span>
                `;
            }
            
            // Calculate depth for camera positioning (must be done before camera setup)
            const depth = Math.max((maxAlt - minAlt) || 100, 50); // Ensure minimum depth
            
            // Set initial camera position - angled view to show vertical and horizontal profile
            const distance = Math.max(gridSize * 1.5, 200); // Ensure minimum distance
            const centerY = depth * 0.3;
            flightProfileCamera.position.set(distance * 0.7, depth * 0.6, distance * 0.7);
            flightProfileCamera.lookAt(0, centerY, 0);
            flightProfileCamera.updateProjectionMatrix();
            
            // Update controls target if they exist
            if (flightProfileControls) {
                flightProfileControls.target.set(0, centerY, 0);
                flightProfileControls.update();
            }
            
            // Add OrbitControls for drag-to-rotate
            try {
                if (typeof THREE !== 'undefined' && typeof THREE.OrbitControls !== 'undefined') {
                    flightProfileControls = new THREE.OrbitControls(flightProfileCamera, flightProfileRenderer.domElement);
                    flightProfileControls.enableDamping = true;
                    flightProfileControls.dampingFactor = 0.05;
                    flightProfileControls.minDistance = Math.max(gridSize * 0.5, 100);
                    flightProfileControls.maxDistance = Math.max(gridSize * 3, 1000);
                    const centerY = depth * 0.3;
                    flightProfileControls.target.set(0, centerY, 0);
                    flightProfileControls.update();
                } else {
                    console.warn('OrbitControls not available, implementing manual drag controls');
                    // Implement simple manual drag controls
                    let isDragging = false;
                    let previousMousePosition = { x: 0, y: 0 };
                    
                    flightProfileRenderer.domElement.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        previousMousePosition = { x: e.clientX, y: e.clientY };
                    });
                    
                    flightProfileRenderer.domElement.addEventListener('mousemove', (e) => {
                        if (!isDragging) return;
                        
                        const deltaX = e.clientX - previousMousePosition.x;
                        const deltaY = e.clientY - previousMousePosition.y;
                        
                        // Rotate camera around the target
                        const spherical = new THREE.Spherical();
                        spherical.setFromVector3(flightProfileCamera.position.clone().sub(new THREE.Vector3(0, depth * 0.3, 0)));
                        spherical.theta -= deltaX * 0.01;
                        spherical.phi += deltaY * 0.01;
                        spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                        
                        flightProfileCamera.position.setFromSpherical(spherical);
                        flightProfileCamera.position.add(new THREE.Vector3(0, depth * 0.3, 0));
                        flightProfileCamera.lookAt(0, depth * 0.3, 0);
                        
                        previousMousePosition = { x: e.clientX, y: e.clientY };
                    });
                    
                    flightProfileRenderer.domElement.addEventListener('mouseup', () => {
                        isDragging = false;
                    });
                    
                    flightProfileRenderer.domElement.addEventListener('mouseleave', () => {
                        isDragging = false;
                    });
                }
            } catch (error) {
                console.error('Error setting up controls:', error);
            }
            
            // Ensure initial render happens immediately - CRITICAL
            console.log('About to render 3D scene:', {
                hasScene: !!flightProfileScene,
                hasCamera: !!flightProfileCamera,
                hasRenderer: !!flightProfileRenderer,
                gridSize: gridSize,
                pointsCount: points.length,
                sceneChildren: flightProfileScene ? flightProfileScene.children.length : 0
            });
            
            // Force render immediately
            try {
                if (flightProfileScene && flightProfileCamera && flightProfileRenderer) {
                    flightProfileRenderer.render(flightProfileScene, flightProfileCamera);
                    console.log('✓ Initial render completed successfully');
                } else {
                    console.error('✗ Missing required components:', {
                        scene: !!flightProfileScene,
                        camera: !!flightProfileCamera,
                        renderer: !!flightProfileRenderer
                    });
                }
            } catch (renderError) {
                console.error('✗ Render error:', renderError);
            }
            
            // Handle window resize
            window.addEventListener('resize', onFlightProfileResize);
            
            // Start animation loop
            animateFlightProfile();
        }
        
        function onFlightProfileResize() {
            if (!flightProfileCamera || !flightProfileRenderer) return;
            
            const canvasContainer = document.getElementById('flightProfileCanvas');
            if (!canvasContainer) return;
            
            const width = canvasContainer.clientWidth;
            const height = canvasContainer.clientHeight;
            
            flightProfileCamera.aspect = width / height;
            flightProfileCamera.updateProjectionMatrix();
            flightProfileRenderer.setSize(width, height);
        }
        
        function animateFlightProfile() {
            if (!flightProfileRenderer || !flightProfileScene || !flightProfileCamera) return;
            
            requestAnimationFrame(animateFlightProfile);
            
            // Update controls
            if (flightProfileControls) {
                flightProfileControls.update();
            }
            
            // Axes are now displayed in the side panel, no need to update position
            
            flightProfileRenderer.render(flightProfileScene, flightProfileCamera);
        }
        
        // Close modal on escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const modal = document.getElementById('flightProfileModal');
                if (modal && modal.style.display !== 'none') {
                    closeFlightProfileViewer();
                }
            }
        });
    </script>
</body>
</html>

